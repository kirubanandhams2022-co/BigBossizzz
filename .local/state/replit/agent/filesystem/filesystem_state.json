{"file_contents":{"app.py":{"content":"import os\nimport logging\nfrom flask import Flask, flash, redirect, url_for, request\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom flask_mail import Mail\nfrom flask_socketio import SocketIO\nfrom flask_wtf.csrf import CSRFProtect, CSRFError\nfrom sqlalchemy.orm import DeclarativeBase\nimport redis\n# Simple ProxyFix implementation for compatibility\nclass ProxyFix:\n    def __init__(self, app, x_proto=1, x_host=1):\n        self.app = app\n        \n    def __call__(self, environ, start_response):\n        return self.app(environ, start_response)\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\nlogin_manager = LoginManager()\nmail = Mail()\nsocketio = SocketIO()\ncsrf = CSRFProtect()\n\n# Redis connection for real-time features\ntry:\n    redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)\n    redis_client.ping()  # Test connection\nexcept:\n    redis_client = None  # Fallback to in-memory storage\n\n# Create the app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Configure the database with performance optimizations\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\", \"postgresql://localhost/proctoring_db\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n    \"pool_size\": 20,\n    \"max_overflow\": 30,\n    \"pool_timeout\": 30,\n}\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False  # Disable event system for performance\n\n# Configure email\napp.config['MAIL_SERVER'] = os.environ.get('MAIL_SERVER', 'smtp.gmail.com')\napp.config['MAIL_PORT'] = int(os.environ.get('MAIL_PORT', '587'))\napp.config['MAIL_USE_TLS'] = os.environ.get('MAIL_USE_TLS', 'true').lower() in ['true', 'on', '1']\napp.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')\napp.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')\napp.config['MAIL_DEFAULT_SENDER'] = os.environ.get('MAIL_DEFAULT_SENDER') or os.environ.get('MAIL_USERNAME')\n\n# Initialize extensions\ndb.init_app(app)\nlogin_manager.init_app(app)\nmail.init_app(app)\ncsrf.init_app(app)\n# üîí SECURITY: Restrict CORS origins to known domains\nallowed_origins = [\n    \"http://localhost:5000\",\n    \"https://localhost:5000\", \n    \"http://127.0.0.1:5000\",\n    \"https://127.0.0.1:5000\"\n]\n# Allow additional origins from environment for production\nif os.environ.get('ALLOWED_ORIGINS'):\n    allowed_origins.extend(os.environ.get('ALLOWED_ORIGINS').split(','))\n\nsocketio.init_app(app, async_mode='eventlet', cors_allowed_origins=allowed_origins, message_queue=f'redis://localhost:6379/0' if redis_client else None)\n\n# Configure login manager  \nlogin_manager.login_view = 'login'  # type: ignore\nlogin_manager.login_message = 'Please log in to access this page.'\nlogin_manager.login_message_category = 'info'\n\n# CSRF Error Handler\n@app.errorhandler(CSRFError)\ndef handle_csrf_error(e):\n    flash('Security token expired or missing. Please try again.', 'error')\n    return redirect(url_for('index'))\n\n@login_manager.user_loader\ndef load_user(user_id):\n    try:\n        # Import User lazily to avoid circular imports\n        from models import User\n        return User.query.get(int(user_id))\n    except (ValueError, TypeError, ImportError):\n        return None\n\nwith app.app_context():\n    # Import models once to ensure tables are created\n    try:\n        import models\n        db.create_all()\n        \n        # Use the already imported User model\n        User = models.User\n    except Exception as e:\n        logging.error(f\"Database initialization error: {e}\")\n        # Import User as fallback\n        from models import User\n    \n    # üîí SECURITY: Default accounts only in development mode\n    # Production systems should use proper user management\n    is_development = os.environ.get('FLASK_ENV') == 'development' or os.environ.get('DEBUG') == 'true'\n    \n    if is_development:\n        # Default Admin Account (DEV ONLY)\n        if not User.query.filter_by(email='admin@platform.com').first():\n            admin = User()\n            admin.username = 'admin'\n            admin.email = 'admin@platform.com'\n            admin.role = 'admin'\n            admin.set_password('admin123')\n            admin.is_verified = True\n            db.session.add(admin)\n            logging.info(\"‚ö†Ô∏è DEV: Created default admin account (admin@platform.com)\")\n        \n        # Default Host Account (DEV ONLY)\n        if not User.query.filter_by(email='host@platform.com').first():\n            host = User()\n            host.username = 'host'\n            host.email = 'host@platform.com'\n            host.role = 'host'\n            host.set_password('host123')\n            host.is_verified = True\n            db.session.add(host)\n            logging.info(\"‚ö†Ô∏è DEV: Created default host account (host@platform.com)\")\n        \n        # Default Participant Account (DEV ONLY)\n        if not User.query.filter_by(email='participant@platform.com').first():\n            participant = User()\n            participant.username = 'participant'\n            participant.email = 'participant@platform.com'\n            participant.role = 'participant'\n            participant.set_password('participant123')\n            participant.is_verified = True\n            db.session.add(participant)\n            logging.info(\"‚ö†Ô∏è DEV: Created default participant account (participant@platform.com)\")\n    else:\n        logging.info(\"üîí PRODUCTION: Skipping default account creation for security\")\n    \n    db.session.commit()\n    \n    # Initialize RBAC system with default roles and permissions\n    try:\n        from rbac_service import initialize_rbac_system\n        result = initialize_rbac_system()\n        print(f\"‚úÖ RBAC initialized: {result['permissions_created']} permissions, {result['roles_created']} roles created\")\n    except ImportError:\n        print(\"‚ö†Ô∏è RBAC system not available - continuing without initialization\")\n    except Exception as e:\n        print(f\"‚ö†Ô∏è RBAC initialization error: {e}\")\n    \n    # Add context processor for RBAC permissions\n    try:\n        from rbac_decorators import permission_context_processor\n        app.context_processor(permission_context_processor)\n        print(\"‚úÖ RBAC context processor registered\")\n    except ImportError:\n        print(\"‚ö†Ô∏è RBAC context processor not available\")\n\n# Import routes\nfrom routes import *\n\n# Only define run functionality if needed\ndef run_app():\n    \"\"\"Start the application server\"\"\"\n    try:\n        app.run(host='0.0.0.0', port=5000, debug=True)  # type: ignore\n    except Exception as e:\n        logging.error(f\"Failed to start application: {e}\")\n\nif __name__ == '__main__':\n    run_app()\n","size_bytes":6797},"email_service.py":{"content":"\"\"\"\nAcademic Email Service - Completely FREE using Brevo API\nReplaces the broken Flask-Mail system with reliable Brevo service\n300 emails/day forever free - perfect for academic institutions\n\"\"\"\n\nimport os\nimport requests\nimport logging\nfrom typing import Optional\nfrom flask import url_for\nfrom datetime import datetime\n\nclass BrevoEmailService:\n    \"\"\"\n    Completely free email service using Brevo API\n    - 300 emails/day forever free\n    - Perfect for academic institutions\n    - Professional email templates\n    \"\"\"\n    \n    def __init__(self):\n        self.api_key = os.environ.get('BREVO_API_KEY', '')\n        self.sender_email = os.environ.get('BREVO_SENDER_EMAIL', '')\n        self.sender_name = os.environ.get('BREVO_SENDER_NAME', 'BigBossizzz Academic Platform')\n        self.api_url = 'https://api.brevo.com/v3/smtp/email'\n        self.headers = {\n            'accept': 'application/json',\n            'content-type': 'application/json',\n            'api-key': self.api_key\n        }\n        \n        # Validate critical configuration with development flexibility\n        if not self.api_key:\n            raise ValueError(\"‚ùå CRITICAL: BREVO_API_KEY not set. Email system cannot function!\")\n        \n        # Handle sender email - strict for production, fallback for development  \n        if not self.sender_email:\n            is_production = os.environ.get('FLASK_ENV') == 'production'\n            if is_production:\n                logging.error(\"‚ùå PRODUCTION: BREVO_SENDER_EMAIL required! Please configure verified domain.\")\n                self.sender_email = \"noreply@bigbossizzz.com\"  # Will likely bounce in production\n            else:\n                logging.warning(\"‚ö†Ô∏è DEVELOPMENT: Using fallback sender. Set BREVO_SENDER_EMAIL for production!\")\n                self.sender_email = \"noreply@bigbossizzz.com\"  # Development fallback\n    \n    def send_email(self, \n                   to_email: str, \n                   subject: str, \n                   html_content: Optional[str] = None,\n                   text_content: Optional[str] = None,\n                   from_email: Optional[str] = None,\n                   from_name: str = \"BigBossizzz Academic Platform\") -> bool:\n        \"\"\"Send email using Brevo's free API\"\"\"\n        \n        if not self.api_key:\n            logging.error(\"Cannot send email: BREVO_API_KEY not configured\")\n            return False\n        \n        # Use configured sender or fail with clear error\n        if not from_email:\n            if self.sender_email:\n                from_email = self.sender_email\n            else:\n                logging.error(\"‚ùå No sender email configured. Set BREVO_SENDER_EMAIL environment variable.\")\n                return False\n        \n        # Use configured sender name\n        if not from_name or from_name == \"BigBossizzz Academic Platform\":\n            from_name = self.sender_name\n        \n        # Prepare email data\n        email_data = {\n            \"sender\": {\n                \"name\": from_name,\n                \"email\": from_email\n            },\n            \"to\": [{\"email\": to_email}],\n            \"subject\": subject\n        }\n        \n        # Add content (prefer HTML over text)\n        if html_content:\n            email_data[\"htmlContent\"] = html_content\n        elif text_content:\n            email_data[\"textContent\"] = text_content\n        else:\n            logging.error(\"No email content provided\")\n            return False\n        \n        try:\n            response = requests.post(\n                self.api_url,\n                json=email_data,\n                headers=self.headers,\n                timeout=30\n            )\n            \n            if response.status_code == 201:\n                logging.info(f\"‚úÖ Email sent successfully to {to_email}\")\n                return True\n            else:\n                logging.error(f\"‚ùå Failed to send email: {response.status_code} - {response.text}\")\n                return False\n                \n        except requests.exceptions.RequestException as e:\n            logging.error(f\"‚ùå Email service error: {e}\")\n            return False\n\n# Global email service instance\nbrevo_service = BrevoEmailService()\n\ndef send_verification_email(user):\n    \"\"\"Send email verification to user - Compatible with existing registration flow\"\"\"\n    try:\n        # Use existing verification token (already generated and committed in register)\n        token = user.verification_token\n        if not token:\n            logging.error(\"‚ùå No verification token found for user\")\n            return False\n        verification_url = url_for('verify_email', token=token, _external=True)\n        \n        subject = 'üéì Verify Your BigBossizzz Academic Account'\n        \n        html_content = f\"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <style>\n                .container {{ max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }}\n                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }}\n                .eye-logo {{ font-size: 48px; margin-bottom: 10px; }}\n                .content {{ padding: 30px; background-color: #f8f9fa; }}\n                .button {{ display: inline-block; padding: 15px 30px; background: #28a745; color: white; text-decoration: none; border-radius: 8px; font-weight: bold; }}\n                .verification-box {{ background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #28a745; }}\n                .footer {{ text-align: center; padding: 20px; color: #6c757d; font-size: 12px; }}\n                .url-box {{ background: #e9ecef; padding: 10px; border-radius: 4px; font-family: monospace; word-break: break-all; margin: 10px 0; }}\n            </style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <div class=\"header\">\n                    <div class=\"eye-logo\">üëÅÔ∏è</div>\n                    <h1>BigBossizzz</h1>\n                    <p>Academic Examination Platform</p>\n                </div>\n                <div class=\"content\">\n                    <h2>Welcome {user.username}!</h2>\n                    <p>Thank you for joining BigBossizzz as a <strong>{user.role.title()}</strong>.</p>\n                    \n                    <div class=\"verification-box\">\n                        <h3>üìß Verify Your Academic Email</h3>\n                        <p>To complete your registration and access academic features, please verify your email address.</p>\n                        \n                        <div style=\"text-align: center; margin: 25px 0;\">\n                            <a href=\"{verification_url}\" class=\"button\">‚úÖ Verify Email Address</a>\n                        </div>\n                    </div>\n                    \n                    <p><strong>Can't click the button?</strong> Copy and paste this link:</p>\n                    <div class=\"url-box\">{verification_url}</div>\n                    \n                    <p>‚è∞ <strong>Important:</strong> This verification link expires in 24 hours for security.</p>\n                    \n                    <h3>üìö What's Next After Verification:</h3>\n                    <ul>\n                        <li>Access to academic dashboard</li>\n                        <li>Join or create quiz sessions</li>\n                        <li>Proctored examination system</li>\n                        <li>Real-time academic monitoring</li>\n                    </ul>\n                </div>\n                <div class=\"footer\">\n                    <p>¬© 2025 BigBossizzz Academic Platform</p>\n                    <p>This is an automated academic verification email.</p>\n                    <p>If you didn't create this account, please ignore this email.</p>\n                </div>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        # Send using Brevo\n        return brevo_service.send_email(\n            to_email=user.email,\n            subject=subject,\n            html_content=html_content,\n            from_name=\"BigBossizzz Academic Team\"\n        )\n        \n    except Exception as e:\n        logging.error(f\"‚ùå Failed to send verification email to {user.email}: {str(e)}\")\n        return False\n\ndef send_credentials_email(user, temp_password):\n    \"\"\"Send login credentials to verified user\"\"\"\n    try:\n        subject = 'üîë Your BigBossizzz Academic Login Credentials'\n        \n        html_content = f\"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <style>\n                .container {{ max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }}\n                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }}\n                .content {{ padding: 30px; background-color: #f8f9fa; }}\n                .credentials {{ background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #28a745; }}\n                .button {{ display: inline-block; padding: 12px 30px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }}\n                .warning {{ background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 15px 0; }}\n            </style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <div class=\"header\">\n                    <h1>üëÅÔ∏è BigBossizzz</h1>\n                    <p>Your Academic Account is Ready!</p>\n                </div>\n                <div class=\"content\">\n                    <h2>üéì Hello {user.username}!</h2>\n                    <p>Your academic account has been verified successfully. You can now access the BigBossizzz examination platform.</p>\n                    \n                    <div class=\"credentials\">\n                        <h3>üîê Your Login Credentials:</h3>\n                        <table style=\"width: 100%; font-family: monospace;\">\n                            <tr><td><strong>Username:</strong></td><td>{user.username}</td></tr>\n                            <tr><td><strong>Email:</strong></td><td>{user.email}</td></tr>\n                            <tr><td><strong>Password:</strong></td><td>{temp_password}</td></tr>\n                            <tr><td><strong>Role:</strong></td><td>{user.role.title()}</td></tr>\n                        </table>\n                    </div>\n                    \n                    <div class=\"warning\">\n                        ‚ö†Ô∏è <strong>Security Notice:</strong> Please change your password after first login for account security.\n                    </div>\n                    \n                    <p style=\"text-align: center;\">\n                        <a href=\"{url_for('login', _external=True)}\" class=\"button\">üöÄ Login to Platform</a>\n                    </p>\n                    \n                    <h3>üìö Academic Features Available:</h3>\n                    <ul>\n                        <li>Secure proctored examinations</li>\n                        <li>Real-time violation monitoring</li>\n                        <li>Academic progress tracking</li>\n                        <li>Course and quiz management</li>\n                    </ul>\n                </div>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        return brevo_service.send_email(\n            to_email=user.email,\n            subject=subject,\n            html_content=html_content,\n            from_name=\"BigBossizzz Academic Team\"\n        )\n        \n    except Exception as e:\n        logging.error(f\"‚ùå Failed to send credentials email: {str(e)}\")\n        return False\n\ndef send_login_notification(user, login_event=None):\n    \"\"\"Send login notification (compatible with routes.py)\"\"\"\n    try:\n        subject = f'üîî Academic Login Alert - {user.username}'\n        \n        login_time = login_event.login_time if login_event else datetime.now()\n        \n        html_content = f\"\"\"\n        <div style=\"font-family: Arial, sans-serif; max-width: 500px;\">\n            <h3>üëÅÔ∏è BigBossizzz Academic Login Alert</h3>\n            <p><strong>Account:</strong> {user.username} ({user.email})</p>\n            <p><strong>Role:</strong> {user.role.title()}</p>\n            <p><strong>Login Time:</strong> {login_time.strftime('%Y-%m-%d %H:%M:%S')}</p>\n            <p><strong>Academic Platform:</strong> BigBossizzz</p>\n            <p>If this wasn't you, please contact academic support immediately.</p>\n        </div>\n        \"\"\"\n        \n        return brevo_service.send_email(\n            to_email=user.email,\n            subject=subject,\n            html_content=html_content,\n            from_name=\"BigBossizzz Academic Security\"\n        )\n        \n    except Exception as e:\n        logging.error(f\"‚ùå Login notification failed: {str(e)}\")\n        return False\n\ndef send_host_login_notification(host, user=None, login_event=None):\n    \"\"\"Send special login notification for hosts/admins (compatible with routes.py)\"\"\"\n    # Handle the specific signature expected by routes.py\n    actual_user = user if user else host\n    return send_login_notification(actual_user, login_event)\n\ndef send_violation_alert(instructor_email: str, student_name: str,\n                       quiz_title: str, violation_details: str) -> bool:\n    \"\"\"Send real-time violation alert to instructor\"\"\"\n    try:\n        subject = f\"üö® URGENT: Academic Violation Alert - {student_name}\"\n        \n        html_content = f\"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <style>\n                .container {{ max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }}\n                .alert {{ background: #dc3545; color: white; padding: 20px; text-align: center; }}\n                .content {{ padding: 20px; }}\n                .violation-box {{ background: #fff3cd; border: 2px solid #ffc107; padding: 20px; border-radius: 8px; margin: 20px 0; }}\n                .button {{ display: inline-block; padding: 12px 24px; background: #dc3545; color: white; text-decoration: none; border-radius: 5px; }}\n                .urgent {{ font-size: 18px; font-weight: bold; color: #dc3545; }}\n            </style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <div class=\"alert\">\n                    <h1>üö® URGENT ACADEMIC VIOLATION</h1>\n                    <p>Immediate attention required</p>\n                </div>\n                <div class=\"content\">\n                    <p class=\"urgent\">Academic integrity violation detected during examination!</p>\n                    \n                    <div class=\"violation-box\">\n                        <h3>üìã Violation Details:</h3>\n                        <p><strong>Student:</strong> {student_name}</p>\n                        <p><strong>Examination:</strong> {quiz_title}</p>\n                        <p><strong>Violation:</strong> {violation_details}</p>\n                        <p><strong>Time:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}</p>\n                    </div>\n                    \n                    <p><strong>Action Required:</strong> Please review the live monitoring dashboard immediately to assess the situation.</p>\n                    \n                    <p style=\"text-align: center;\">\n                        <a href=\"{url_for('admin_dashboard', _external=True)}\" class=\"button\">üîç View Admin Dashboard</a>\n                    </p>\n                    \n                    <hr>\n                    <p style=\"color: #666; font-size: 12px;\">\n                        This is an automated academic integrity alert from BigBossizzz platform.\n                        Immediate instructor review recommended.\n                    </p>\n                </div>\n            </div>\n        </body>\n        </html>\n        \"\"\"\n        \n        return brevo_service.send_email(\n            to_email=instructor_email,\n            subject=subject,\n            html_content=html_content,\n            from_name=\"BigBossizzz Academic Security\"\n        )\n        \n    except Exception as e:\n        logging.error(f\"‚ùå Failed to send violation alert: {str(e)}\")\n        return False\n\ndef test_email_service():\n    \"\"\"Test if the email service is working\"\"\"\n    return brevo_service.api_key and len(brevo_service.api_key) > 10","size_bytes":16304},"forms.py":{"content":"from flask_wtf import FlaskForm\nfrom flask_wtf.file import FileField, FileAllowed\nfrom wtforms import StringField, PasswordField, TextAreaField, SelectField, IntegerField, BooleanField, FieldList, FormField, DateField\nfrom wtforms.validators import DataRequired, Email, Length, EqualTo, NumberRange, Optional, URL\nfrom wtforms.widgets import TextArea\n\nclass RegistrationForm(FlaskForm):\n    username = StringField('Username', validators=[\n        DataRequired(), \n        Length(min=4, max=20, message='Username must be between 4 and 20 characters')\n    ])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Password', validators=[\n        DataRequired(), \n        Length(min=6, message='Password must be at least 6 characters')\n    ])\n    confirm_password = PasswordField('Confirm Password', validators=[\n        DataRequired(), \n        EqualTo('password', message='Passwords must match')\n    ])\n    role = SelectField('Role', choices=[\n        ('participant', 'Participant'),\n        ('host', 'Host')\n    ], validators=[DataRequired()])\n\nclass LoginForm(FlaskForm):\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Password', validators=[DataRequired()])\n\nclass QuizForm(FlaskForm):\n    title = StringField('Quiz Title', validators=[\n        DataRequired(), \n        Length(max=200, message='Title cannot exceed 200 characters')\n    ])\n    description = TextAreaField('Description', widget=TextArea())\n    time_limit = IntegerField('Time Limit (minutes)', validators=[\n        DataRequired(), \n        NumberRange(min=1, max=300, message='Time limit must be between 1 and 300 minutes')\n    ], default=60)\n    proctoring_enabled = BooleanField('Enable Proctoring', default=True)\n    quiz_file = FileField('Upload Quiz File (Multiple formats supported)', validators=[\n        FileAllowed(['txt', 'csv', 'xlsx', 'xls', 'docx', 'pdf'], 'Supported formats: TXT, CSV, Excel (XLSX/XLS), Word (DOCX), PDF')\n    ])\n    create_from_file = BooleanField('Create Quiz from Uploaded File', default=False)\n\nclass QuestionOptionForm(FlaskForm):\n    option_text = StringField('Option', validators=[DataRequired(), Length(max=500)])\n    is_correct = BooleanField('Correct Answer')\n\nclass QuestionForm(FlaskForm):\n    question_text = TextAreaField('Question', validators=[DataRequired()], widget=TextArea())\n    question_type = SelectField('Question Type', choices=[\n        ('multiple_choice', 'Multiple Choice'),\n        ('true_false', 'True/False'),\n        ('text', 'Text Answer'),\n        ('code_submission', 'Code Submission'),\n        ('file_upload', 'File Upload'),\n        ('drawing', 'Drawing/Diagram')\n    ], default='multiple_choice')\n    points = IntegerField('Points', validators=[\n        DataRequired(), \n        NumberRange(min=1, max=10, message='Points must be between 1 and 10')\n    ], default=1)\n    options = FieldList(FormField(QuestionOptionForm), min_entries=4)\n    \n    # Advanced question type fields\n    programming_language = SelectField('Programming Language', choices=[\n        ('', 'Select Language'),\n        ('python', 'Python'),\n        ('javascript', 'JavaScript'),\n        ('java', 'Java'),\n        ('cpp', 'C++'),\n        ('c', 'C'),\n        ('sql', 'SQL'),\n        ('html', 'HTML'),\n        ('css', 'CSS')\n    ], default='')\n    starter_code = TextAreaField('Starter Code Template', widget=TextArea())\n    sample_output = TextAreaField('Expected Output Example', widget=TextArea())\n    allowed_file_types = StringField('Allowed File Types (e.g., pdf,docx,jpg,png)', default='pdf,docx,jpg,png,txt')\n    max_file_size_mb = IntegerField('Max File Size (MB)', validators=[\n        NumberRange(min=1, max=100, message='File size must be between 1 and 100 MB')\n    ], default=10)\n    canvas_width = IntegerField('Canvas Width (pixels)', validators=[\n        NumberRange(min=200, max=1200, message='Width must be between 200 and 1200 pixels')\n    ], default=800)\n    canvas_height = IntegerField('Canvas Height (pixels)', validators=[\n        NumberRange(min=200, max=800, message='Height must be between 200 and 800 pixels')\n    ], default=600)\n\nclass ProfileForm(FlaskForm):\n    username = StringField('Username', validators=[\n        DataRequired(), \n        Length(min=4, max=20, message='Username must be between 4 and 20 characters')\n    ])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    current_password = PasswordField('Current Password')\n    new_password = PasswordField('New Password', validators=[\n        Length(min=6, message='Password must be at least 6 characters')\n    ])\n    confirm_password = PasswordField('Confirm New Password', validators=[\n        EqualTo('new_password', message='Passwords must match')\n    ])\n","size_bytes":4779},"main.py":{"content":"from app import app  # noqa: F401\n","size_bytes":34},"models.py":{"content":"from datetime import datetime\nfrom app import db\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport secrets\nimport json\nfrom sqlalchemy.ext.hybrid import hybrid_property\n\n# New Course Management System\nclass Course(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text)\n    code = db.Column(db.String(20), unique=True, nullable=False)\n    max_participants = db.Column(db.Integer, default=100)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    is_active = db.Column(db.Boolean, default=True)\n    display_order = db.Column(db.Integer, default=0)  # For drag-and-drop ordering\n    \n    # Relationships\n    host_assignments = db.relationship('HostCourseAssignment', backref='course', lazy=True, cascade='all, delete-orphan')\n    participant_enrollments = db.relationship('ParticipantEnrollment', backref='course', lazy=True, cascade='all, delete-orphan')\n    quizzes = db.relationship('Quiz', backref='course', lazy=True)\n    \n    def __repr__(self):\n        return f'<Course {self.code}: {self.name}>'\n\nclass HostCourseAssignment(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    host_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)\n    assigned_at = db.Column(db.DateTime, default=datetime.utcnow)\n    assigned_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    \n    # Relationships\n    host = db.relationship('User', foreign_keys=[host_id], backref='host_course_assignments')\n    assigned_by_user = db.relationship('User', foreign_keys=[assigned_by])\n    \n    def __repr__(self):\n        return f'<HostAssignment {self.host_id}->{self.course_id}>'\n\nclass ParticipantEnrollment(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    participant_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=False)\n    enrolled_at = db.Column(db.DateTime, default=datetime.utcnow)\n    enrolled_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    \n    # Relationships\n    participant = db.relationship('User', foreign_keys=[participant_id], backref='course_enrollments')\n    enrolled_by_user = db.relationship('User', foreign_keys=[enrolled_by])\n    \n    def __repr__(self):\n        return f'<Enrollment {self.participant_id}->{self.course_id}>'\n\nclass User(UserMixin, db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    role = db.Column(db.String(20), nullable=False, default='participant')  # 'host', 'participant', 'admin'\n    is_verified = db.Column(db.Boolean, default=False)\n    verification_token = db.Column(db.String(100), unique=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_login = db.Column(db.DateTime)\n    profile_picture = db.Column(db.String(200), default='default.png')\n    \n    # LTI Integration fields\n    lti_user_id = db.Column(db.String(255), unique=True, index=True)  # LTI user identifier\n    lti_consumer_key = db.Column(db.String(255))  # LMS consumer key\n    lti_context_id = db.Column(db.String(255))  # Course/context identifier\n    lti_resource_link_id = db.Column(db.String(255))  # Specific resource link\n    lti_grade_passback_url = db.Column(db.String(500))  # Grade passback service URL\n    lti_result_sourcedid = db.Column(db.String(255))  # Grade passback identifier\n    \n    # Relationships\n    created_quizzes = db.relationship('Quiz', backref='creator', lazy=True, cascade='all, delete-orphan')\n    quiz_attempts = db.relationship('QuizAttempt', backref='participant', lazy=True, cascade='all, delete-orphan')\n    user_roles = db.relationship('UserRole', foreign_keys='UserRole.user_id', backref='user', lazy=True, cascade='all, delete-orphan')\n    \n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n    \n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n    \n    def generate_verification_token(self):\n        self.verification_token = secrets.token_urlsafe(32)\n        return self.verification_token\n    \n    def verify_email(self, token):\n        if self.verification_token == token:\n            self.is_verified = True\n            self.verification_token = None\n            return True\n        return False\n    \n    \n    # New RBAC methods\n    def has_permission(self, permission_name):\n        \"\"\"Check if user has a specific permission through their roles\"\"\"\n        try:\n            for user_role in self.user_roles:\n                if user_role.role:\n                    for role_permission in user_role.role.role_permissions:\n                        if role_permission.permission and role_permission.permission.name == permission_name:\n                            return True\n        except Exception:\n            pass\n        return False\n    \n    def has_any_permission(self, permission_names):\n        \"\"\"Check if user has any of the specified permissions\"\"\"\n        return any(self.has_permission(perm) for perm in permission_names)\n    \n    def has_all_permissions(self, permission_names):\n        \"\"\"Check if user has all of the specified permissions\"\"\"\n        return all(self.has_permission(perm) for perm in permission_names)\n    \n    def get_all_permissions(self):\n        \"\"\"Get all permissions for this user through their roles\"\"\"\n        permissions = set()\n        try:\n            for user_role in self.user_roles:\n                if user_role.role:\n                    for role_permission in user_role.role.role_permissions:\n                        if role_permission.permission:\n                            permissions.add(role_permission.permission.name)\n        except Exception:\n            pass\n        return list(permissions)\n    \n    def add_role(self, role_name):\n        \"\"\"Add a role to this user\"\"\"\n        from models import Role, UserRole  # Import here to avoid circular imports\n        role = Role.query.filter_by(name=role_name).first()\n        if role and not self.has_role(role_name):\n            user_role = UserRole()\n            user_role.user_id = self.id\n            user_role.role_id = role.id\n            db.session.add(user_role)\n            return True\n        return False\n    \n    def remove_role(self, role_name):\n        \"\"\"Remove a role from this user\"\"\"\n        from models import Role, UserRole  # Import here to avoid circular imports\n        role = Role.query.filter_by(name=role_name).first()\n        if role:\n            user_role = UserRole.query.filter_by(user_id=self.id, role_id=role.id).first()\n            if user_role:\n                db.session.delete(user_role)\n                return True\n        return False\n    \n    def has_role(self, role_name):\n        \"\"\"Check if user has a specific role\"\"\"\n        try:\n            return any(ur.role.name == role_name for ur in self.user_roles if ur.role)\n        except Exception:\n            return False\n    \n    def get_roles(self):\n        \"\"\"Get all role names for this user\"\"\"\n        try:\n            return [ur.role.name for ur in self.user_roles if ur.role]\n        except Exception:\n            return []\n    \n    # Legacy role methods for backward compatibility with safety checks\n    def is_admin(self):\n        # First check RBAC system\n        try:\n            if hasattr(self, 'user_roles') and self.user_roles:\n                return self.has_role('admin')\n        except:\n            pass\n        # Fallback to simple role column\n        return self.role == 'admin'\n    \n    def is_host(self):\n        # First check RBAC system\n        try:\n            if hasattr(self, 'user_roles') and self.user_roles:\n                return self.has_role('host')\n        except:\n            pass\n        # Fallback to simple role column\n        return self.role == 'host'\n    \n    def is_participant(self):\n        # First check RBAC system  \n        try:\n            if hasattr(self, 'user_roles') and self.user_roles:\n                return self.has_role('participant')\n        except:\n            pass\n        # Fallback to simple role column\n        return self.role == 'participant'\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n\nclass Quiz(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text)\n    creator_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    course_id = db.Column(db.Integer, db.ForeignKey('course.id'), nullable=True)  # Add course relationship\n    time_limit = db.Column(db.Integer, default=60)  # in minutes\n    is_active = db.Column(db.Boolean, default=True)\n    proctoring_enabled = db.Column(db.Boolean, default=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # New columns for advanced features\n    allow_view_responses = db.Column(db.Boolean, default=True)\n    auto_generate_from_upload = db.Column(db.Boolean, default=False)\n    draft_from_upload_id = db.Column(db.Integer, db.ForeignKey('upload_record.id'))\n    is_deleted = db.Column(db.Boolean, default=False)\n    \n    # Security settings\n    max_violations_allowed = db.Column(db.Integer, default=3)\n    auto_terminate_on_violation = db.Column(db.Boolean, default=True)\n    face_detection_required = db.Column(db.Boolean, default=True)\n    \n    # Question randomization\n    shuffle_questions = db.Column(db.Boolean, default=True)\n    screen_recording_required = db.Column(db.Boolean, default=False)\n    browser_lockdown = db.Column(db.Boolean, default=True)\n    \n    # Ordering for drag-and-drop\n    display_order = db.Column(db.Integer, default=0)  # For course-level quiz ordering\n    \n    # Relationships\n    questions = db.relationship('Question', backref='quiz', lazy=True, cascade='all, delete-orphan')\n    attempts = db.relationship('QuizAttempt', backref='quiz', lazy=True, cascade='all, delete-orphan')\n    \n    def __repr__(self):\n        return f'<Quiz {self.title}>'\n\nclass Question(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    question_text = db.Column(db.Text, nullable=False)\n    question_type = db.Column(db.String(20), default='multiple_choice')  # 'multiple_choice', 'text', 'true_false', 'code_submission', 'file_upload', 'drawing'\n    points = db.Column(db.Integer, default=1)\n    order = db.Column(db.Integer, default=0)\n    \n    # Advanced question type specific fields\n    programming_language = db.Column(db.String(50))  # For code_submission: 'python', 'javascript', 'java', etc.\n    starter_code = db.Column(db.Text)  # For code_submission: initial code template\n    allowed_file_types = db.Column(db.String(200))  # For file_upload: 'pdf,docx,jpg,png'\n    max_file_size_mb = db.Column(db.Integer, default=10)  # For file_upload: max size in MB\n    canvas_width = db.Column(db.Integer, default=800)  # For drawing: canvas dimensions\n    canvas_height = db.Column(db.Integer, default=600)  # For drawing: canvas dimensions\n    sample_output = db.Column(db.Text)  # For code_submission: expected output example\n    \n    # Relationships\n    options = db.relationship('QuestionOption', backref='question', lazy=True, cascade='all, delete-orphan')\n    answers = db.relationship('Answer', backref='question', lazy=True, cascade='all, delete-orphan')\n    \n    def get_shuffled_options(self):\n        \"\"\"Return shuffled options for this question\"\"\"\n        import random\n        from app import db\n        options = db.session.query(QuestionOption).filter_by(question_id=self.id).all()\n        random.shuffle(options)\n        return options\n    \n    def __repr__(self):\n        return f'<Question {self.id}>'\n\nclass QuestionOption(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    question_id = db.Column(db.Integer, db.ForeignKey('question.id'), nullable=False)\n    option_text = db.Column(db.String(500), nullable=False)\n    is_correct = db.Column(db.Boolean, default=False)\n    order = db.Column(db.Integer, default=0)\n    \n    def __repr__(self):\n        return f'<Option {self.option_text}>'\n\nclass QuizAttempt(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    participant_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    started_at = db.Column(db.DateTime, default=datetime.utcnow)\n    completed_at = db.Column(db.DateTime)\n    score = db.Column(db.Float)\n    total_points = db.Column(db.Integer)\n    status = db.Column(db.String(20), default='in_progress')  # 'in_progress', 'completed', 'abandoned', 'terminated'\n    force_submitted = db.Column(db.Boolean, default=False)\n    termination_reason = db.Column(db.Text)\n    is_flagged = db.Column(db.Boolean, default=False)\n    \n    # Highest risk violation summary fields for performance optimization\n    highest_risk_level = db.Column(db.String(20), default='low')  # 'low', 'medium', 'high', 'critical'\n    highest_risk_severity = db.Column(db.Integer, default=1)  # 1=low, 2=medium, 3=high, 4=critical\n    violation_counts_json = db.Column(db.Text)  # JSON: {\"low\": 2, \"medium\": 1, \"high\": 0, \"critical\": 0}\n    \n    # Relationships (participant and quiz backrefs are defined in User and Quiz models)\n    answers = db.relationship('Answer', backref='attempt', lazy=True, cascade='all, delete-orphan')\n    \n    def calculate_score(self):\n        correct_answers = 0\n        total_points = 0\n        \n        from app import db\n        # Get answers with their associated questions\n        answers_with_questions = db.session.query(Answer, Question).join(\n            Question, Answer.question_id == Question.id\n        ).filter(Answer.attempt_id == self.id).all()\n        \n        for answer, question in answers_with_questions:\n            total_points += question.points\n            if answer.is_correct:\n                correct_answers += question.points\n        \n        self.score = (correct_answers / total_points * 100) if total_points > 0 else 0\n        self.total_points = total_points\n        return self.score\n    \n    def update_highest_risk(self, new_severity_level):\n        \"\"\"Update highest risk summary when a new violation is added\"\"\"\n        import json\n        \n        # Severity mapping: critical > high > medium > low\n        severity_map = {'low': 1, 'medium': 2, 'high': 3, 'critical': 4}\n        new_severity_score = severity_map.get(new_severity_level, 1)\n        \n        # Update highest risk if new violation is more severe\n        if new_severity_score > self.highest_risk_severity:\n            self.highest_risk_level = new_severity_level\n            self.highest_risk_severity = new_severity_score\n        \n        # Update violation counts\n        try:\n            counts = json.loads(self.violation_counts_json) if self.violation_counts_json else {}\n        except (json.JSONDecodeError, TypeError):\n            counts = {}\n        \n        # Initialize counts if missing\n        for level in ['low', 'medium', 'high', 'critical']:\n            if level not in counts:\n                counts[level] = 0\n        \n        # Increment count for this severity level\n        counts[new_severity_level] = counts.get(new_severity_level, 0) + 1\n        \n        # Save updated counts\n        self.violation_counts_json = json.dumps(counts)\n    \n    def __repr__(self):\n        return f'<Attempt {self.id}>'\n\nclass Answer(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    attempt_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    question_id = db.Column(db.Integer, db.ForeignKey('question.id'), nullable=False)\n    selected_option_id = db.Column(db.Integer, db.ForeignKey('question_option.id'))\n    text_answer = db.Column(db.Text)\n    is_correct = db.Column(db.Boolean)\n    answered_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Advanced answer types\n    code_submission = db.Column(db.Text)  # For programming code answers\n    uploaded_file_path = db.Column(db.String(500))  # File path for uploaded files\n    uploaded_file_name = db.Column(db.String(200))  # Original filename\n    uploaded_file_size = db.Column(db.Integer)  # File size in bytes\n    drawing_data = db.Column(db.Text)  # JSON data for drawing/canvas answers\n    execution_output = db.Column(db.Text)  # For code execution results\n    execution_error = db.Column(db.Text)  # For code execution errors\n    \n    def __repr__(self):\n        return f'<Answer {self.id}>'\n\nclass ProctoringEvent(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    attempt_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    event_type = db.Column(db.String(50), nullable=False)  # 'tab_switch', 'window_blur', 'multiple_faces', etc.\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n    details = db.Column(db.Text)  # Additional event details\n    severity = db.Column(db.String(20), default='low')  # 'low', 'medium', 'high'\n    description = db.Column(db.Text)  # Add description field\n    \n    # Add the missing relationship\n    attempt = db.relationship('QuizAttempt', backref='proctoring_events', lazy=True)\n    \n    def __repr__(self):\n        return f'<ProctoringEvent {self.event_type}>'\n\nclass AlertThreshold(db.Model):\n    \"\"\"Model to store customizable alert thresholds for proctoring events\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), nullable=False)  # Human readable name\n    event_type = db.Column(db.String(50), nullable=False)  # 'tab_switch', 'window_blur', etc.\n    \n    # Threshold settings\n    low_threshold = db.Column(db.Integer, default=5)     # Count for low severity\n    medium_threshold = db.Column(db.Integer, default=3)  # Count for medium severity  \n    high_threshold = db.Column(db.Integer, default=1)    # Count for high severity\n    \n    # Time window for counting events (in minutes)\n    time_window = db.Column(db.Integer, default=10)\n    \n    # Actions to take when threshold is exceeded\n    send_alert = db.Column(db.Boolean, default=True)\n    notify_proctor = db.Column(db.Boolean, default=True)\n    auto_flag_attempt = db.Column(db.Boolean, default=False)\n    auto_terminate = db.Column(db.Boolean, default=False)\n    \n    # Scope settings\n    is_global = db.Column(db.Boolean, default=True)\n    created_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    is_active = db.Column(db.Boolean, default=True)\n    \n    # Relationships\n    creator = db.relationship('User', backref='created_thresholds')\n    quiz_overrides = db.relationship('QuizThresholdOverride', backref='threshold', cascade='all, delete-orphan')\n    \n    def __repr__(self):\n        return f'<AlertThreshold {self.name}>'\n\nclass QuizThresholdOverride(db.Model):\n    \"\"\"Model to override global thresholds for specific quizzes\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    threshold_id = db.Column(db.Integer, db.ForeignKey('alert_threshold.id'), nullable=False)\n    \n    # Override values (NULL means use global threshold)\n    low_threshold = db.Column(db.Integer, nullable=True)\n    medium_threshold = db.Column(db.Integer, nullable=True)\n    high_threshold = db.Column(db.Integer, nullable=True)\n    time_window = db.Column(db.Integer, nullable=True)\n    \n    # Action overrides\n    send_alert = db.Column(db.Boolean, nullable=True)\n    notify_proctor = db.Column(db.Boolean, nullable=True)\n    auto_flag_attempt = db.Column(db.Boolean, nullable=True)\n    auto_terminate = db.Column(db.Boolean, nullable=True)\n    \n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    quiz = db.relationship('Quiz', backref='threshold_overrides')\n    \n    def __repr__(self):\n        return f'<QuizThresholdOverride Quiz:{self.quiz_id} Threshold:{self.threshold_id}>'\n\nclass AlertTrigger(db.Model):\n    \"\"\"Model to log when alert thresholds are exceeded\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    attempt_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    threshold_id = db.Column(db.Integer, db.ForeignKey('alert_threshold.id'), nullable=False)\n    \n    # Event details\n    event_type = db.Column(db.String(50), nullable=False)\n    trigger_count = db.Column(db.Integer, nullable=False)  # Number of events that triggered this\n    severity_level = db.Column(db.String(20), nullable=False)  # 'low', 'medium', 'high'\n    \n    # Actions taken\n    alert_sent = db.Column(db.Boolean, default=False)\n    proctor_notified = db.Column(db.Boolean, default=False)\n    attempt_flagged = db.Column(db.Boolean, default=False)\n    attempt_terminated = db.Column(db.Boolean, default=False)\n    \n    # Metadata\n    triggered_at = db.Column(db.DateTime, default=datetime.utcnow)\n    resolved_at = db.Column(db.DateTime, nullable=True)\n    resolved_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    notes = db.Column(db.Text, nullable=True)\n    \n    # Relationships\n    attempt = db.relationship('QuizAttempt', backref='alert_triggers')\n    threshold = db.relationship('AlertThreshold', backref='triggered_alerts')\n    resolver = db.relationship('User', foreign_keys=[resolved_by])\n    \n    def __repr__(self):\n        return f'<AlertTrigger {self.event_type} - {self.severity_level}>'\n\nclass LoginEvent(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    login_time = db.Column(db.DateTime, default=datetime.utcnow)\n    ip_address = db.Column(db.String(45))  # IPv6 support\n    user_agent = db.Column(db.Text)\n    device_info = db.Column(db.Text)  # Browser, OS details\n    location_data = db.Column(db.Text)  # Location if available\n    is_suspicious = db.Column(db.Boolean, default=False)\n    \n    # Relationships\n    user = db.relationship('User', backref=db.backref('login_events', lazy=True))\n    \n    def __repr__(self):\n        return f'<LoginEvent {self.user_id} at {self.login_time}>'\n\nclass UserViolation(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    violation_count = db.Column(db.Integer, default=0)\n    is_flagged = db.Column(db.Boolean, default=False)\n    flagged_at = db.Column(db.DateTime)\n    flagged_by = db.Column(db.Integer, db.ForeignKey('user.id'))  # Admin who flagged\n    can_retake = db.Column(db.Boolean, default=False)\n    retake_approved_by = db.Column(db.Integer, db.ForeignKey('user.id'))\n    retake_approved_at = db.Column(db.DateTime)\n    notes = db.Column(db.Text)\n    \n    # Relationships\n    user = db.relationship('User', foreign_keys=[user_id], backref=db.backref('violations', lazy=True))\n    flagged_by_admin = db.relationship('User', foreign_keys=[flagged_by])\n    approved_by_admin = db.relationship('User', foreign_keys=[retake_approved_by])\n    \n    def __repr__(self):\n        return f'<UserViolation {self.user_id} - {self.violation_count} violations>'\n\n# New models for advanced features\n\nclass UploadRecord(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    host_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    filename = db.Column(db.String(200), nullable=False)\n    mime_type = db.Column(db.String(100))\n    stored_path = db.Column(db.String(500))\n    parsed = db.Column(db.Boolean, default=False)\n    parsed_to_quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'))\n    candidate_questions_json = db.Column(db.Text)  # JSON string of candidate questions\n    uploaded_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    host = db.relationship('User', backref='uploads')\n    \n    def __repr__(self):\n        return f'<UploadRecord {self.filename}>'\n\nclass DeviceLog(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'))\n    ip_address = db.Column(db.String(45))  # IPv6 compatible\n    user_agent = db.Column(db.Text)\n    device_type = db.Column(db.String(50))\n    browser_info = db.Column(db.Text)\n    screen_resolution = db.Column(db.String(20))\n    timezone = db.Column(db.String(50))\n    logged_in_at = db.Column(db.DateTime, default=datetime.utcnow)\n    session_duration = db.Column(db.Integer)  # in minutes\n    is_suspicious = db.Column(db.Boolean, default=False)\n    \n    # Relationships\n    user = db.relationship('User', backref='device_logs')\n    quiz = db.relationship('Quiz', backref='device_logs')\n    \n    def __repr__(self):\n        return f'<DeviceLog {self.user_id}-{self.ip_address}>'\n\nclass SecurityAlert(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'))\n    attempt_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'))\n    alert_type = db.Column(db.String(50), nullable=False)  # 'multiple_faces', 'suspicious_behavior', 'device_change', etc.\n    severity = db.Column(db.String(20), default='medium')  # 'low', 'medium', 'high', 'critical'\n    description = db.Column(db.Text)\n    auto_action_taken = db.Column(db.String(100))  # 'warning_sent', 'quiz_terminated', 'flagged_for_review'\n    resolved = db.Column(db.Boolean, default=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    resolved_at = db.Column(db.DateTime)\n    resolved_by = db.Column(db.Integer, db.ForeignKey('user.id'))\n    \n    # Relationships\n    user = db.relationship('User', foreign_keys=[user_id], backref='security_alerts')\n    quiz = db.relationship('Quiz', backref='security_alerts')\n    attempt = db.relationship('QuizAttempt', backref='security_alerts')\n    resolver = db.relationship('User', foreign_keys=[resolved_by])\n    \n    def __repr__(self):\n        return f'<SecurityAlert {self.alert_type}-{self.severity}>'\n\nclass CollaborationSignal(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    signal_type = db.Column(db.String(50), nullable=False)  # 'answer_similarity', 'simultaneous_answers', 'timing_correlation', 'shared_ip'\n    score = db.Column(db.Float, nullable=False)  # 0.0 to 1.0\n    severity = db.Column(db.String(20), default='info')  # 'info', 'warn', 'high'\n    participants = db.Column(db.JSON)  # Array of user_ids involved\n    window_start = db.Column(db.DateTime)\n    window_end = db.Column(db.DateTime)\n    details = db.Column(db.JSON)  # Additional signal details\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    status = db.Column(db.String(20), default='open')  # 'open', 'acknowledged', 'resolved'\n    resolved_by = db.Column(db.Integer, db.ForeignKey('user.id'))\n    resolved_at = db.Column(db.DateTime)\n    notes = db.Column(db.Text)\n    \n    # Relationships\n    quiz = db.relationship('Quiz', backref='collaboration_signals')\n    resolver = db.relationship('User', foreign_keys=[resolved_by])\n    \n    def __repr__(self):\n        return f'<CollaborationSignal {self.signal_type} for quiz {self.quiz_id}>'\n\nclass AttemptSimilarity(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    attempt_a_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    attempt_b_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    jaccard_score = db.Column(db.Float, default=0.0)\n    timing_correlation = db.Column(db.Float, default=0.0)\n    coanswer_count = db.Column(db.Integer, default=0)\n    last_updated = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    quiz = db.relationship('Quiz', backref='attempt_similarities')\n    attempt_a = db.relationship('QuizAttempt', foreign_keys=[attempt_a_id])\n    attempt_b = db.relationship('QuizAttempt', foreign_keys=[attempt_b_id])\n    \n    # Ensure unique combination\n    __table_args__ = (db.UniqueConstraint('quiz_id', 'attempt_a_id', 'attempt_b_id', name='uq_attempt_similarity'),)\n    \n    def __repr__(self):\n        return f'<AttemptSimilarity {self.attempt_a_id}-{self.attempt_b_id}: {self.jaccard_score}>'\n\n# Real-time Collaboration Heatmap Models\nclass InteractionEvent(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    attempt_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    question_id = db.Column(db.Integer, db.ForeignKey('question.id'), nullable=True)\n    event_type = db.Column(db.String(50), nullable=False)  # 'click', 'focus', 'scroll', 'hover', 'answer_change'\n    element_selector = db.Column(db.String(200))  # CSS selector or element identifier\n    x_coordinate = db.Column(db.Integer)  # Click/hover position\n    y_coordinate = db.Column(db.Integer)\n    viewport_width = db.Column(db.Integer)\n    viewport_height = db.Column(db.Integer)\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n    duration = db.Column(db.Float)  # For focus/hover events - time spent\n    event_metadata = db.Column(db.Text)  # JSON metadata for additional context\n    \n    # Relationships\n    attempt = db.relationship('QuizAttempt', backref='interaction_events')\n    question = db.relationship('Question', backref='interaction_events')\n    \n    def __repr__(self):\n        return f'<InteractionEvent {self.event_type} on Question {self.question_id}>'\n\nclass QuestionHeatmapData(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    question_id = db.Column(db.Integer, db.ForeignKey('question.id'), nullable=False)\n    \n    # Aggregated metrics\n    total_participants = db.Column(db.Integer, default=0)\n    average_time_spent = db.Column(db.Float, default=0.0)  # in seconds\n    total_clicks = db.Column(db.Integer, default=0)\n    total_hovers = db.Column(db.Integer, default=0)\n    correct_answer_rate = db.Column(db.Float, default=0.0)  # percentage\n    difficulty_score = db.Column(db.Float, default=0.0)  # calculated difficulty\n    engagement_score = db.Column(db.Float, default=0.0)  # based on interactions\n    \n    # Hotspot data (JSON)\n    click_hotspots = db.Column(db.Text)  # JSON array of click coordinates\n    hover_hotspots = db.Column(db.Text)  # JSON array of hover coordinates\n    scroll_patterns = db.Column(db.Text)  # JSON data about scroll behavior\n    \n    # Timestamps\n    last_updated = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    quiz = db.relationship('Quiz', backref='heatmap_data')\n    question = db.relationship('Question', backref='heatmap_data')\n    \n    def __repr__(self):\n        return f'<HeatmapData Quiz:{self.quiz_id} Question:{self.question_id}>'\n\nclass CollaborationInsight(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_id = db.Column(db.Integer, db.ForeignKey('quiz.id'), nullable=False)\n    insight_type = db.Column(db.String(50), nullable=False)  # 'difficulty_pattern', 'engagement_drop', 'confusion_area', 'performance_trend'\n    title = db.Column(db.String(200), nullable=False)\n    description = db.Column(db.Text, nullable=False)\n    severity = db.Column(db.String(20), default='low')  # 'low', 'medium', 'high', 'critical'\n    \n    # Context data\n    affected_questions = db.Column(db.Text)  # JSON array of question IDs\n    metric_values = db.Column(db.Text)  # JSON object with relevant metrics\n    suggested_actions = db.Column(db.Text)  # JSON array of recommendations\n    \n    # Status and timestamps\n    is_active = db.Column(db.Boolean, default=True)\n    is_acknowledged = db.Column(db.Boolean, default=False)\n    acknowledged_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    acknowledged_at = db.Column(db.DateTime)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationships\n    quiz = db.relationship('Quiz', backref='collaboration_insights')\n    acknowledger = db.relationship('User', foreign_keys=[acknowledged_by])\n    \n    def __repr__(self):\n        return f'<CollaborationInsight {self.insight_type} for Quiz {self.quiz_id}>'\n\n# AI-Powered Plagiarism Detection Models\nclass PlagiarismAnalysis(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    quiz_attempt_id = db.Column(db.Integer, db.ForeignKey('quiz_attempt.id'), nullable=False)\n    question_id = db.Column(db.Integer, db.ForeignKey('question.id'), nullable=False)\n    answer_id = db.Column(db.Integer, db.ForeignKey('answer.id'), nullable=False)\n    \n    # Analysis Results\n    overall_similarity_score = db.Column(db.Float, nullable=False)  # 0.0 to 1.0\n    risk_level = db.Column(db.String(20), nullable=False)  # 'low', 'medium', 'high', 'critical'\n    \n    # Algorithm-specific scores\n    cosine_similarity = db.Column(db.Float)\n    jaccard_similarity = db.Column(db.Float)\n    levenshtein_similarity = db.Column(db.Float)\n    semantic_similarity = db.Column(db.Float)\n    \n    # Analysis metadata\n    analyzed_text = db.Column(db.Text, nullable=False)\n    analysis_method = db.Column(db.String(50), default='multi_algorithm')\n    confidence_score = db.Column(db.Float)  # How confident we are in the result\n    \n    # Detection flags\n    is_flagged = db.Column(db.Boolean, default=False)\n    requires_review = db.Column(db.Boolean, default=False)\n    is_reviewed = db.Column(db.Boolean, default=False)\n    reviewed_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    reviewed_at = db.Column(db.DateTime)\n    review_decision = db.Column(db.String(20))  # 'innocent', 'suspicious', 'plagiarized'\n    review_notes = db.Column(db.Text)\n    \n    # Timestamps\n    analyzed_at = db.Column(db.DateTime, default=datetime.utcnow)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    quiz_attempt = db.relationship('QuizAttempt', backref='plagiarism_analyses')\n    question = db.relationship('Question', backref='plagiarism_analyses')\n    answer = db.relationship('Answer', backref='plagiarism_analysis', uselist=False)\n    reviewer = db.relationship('User', foreign_keys=[reviewed_by])\n    matches = db.relationship('PlagiarismMatch', backref='analysis', cascade='all, delete-orphan')\n    \n    def get_risk_color(self):\n        colors = {\n            'low': 'success',\n            'medium': 'warning', \n            'high': 'danger',\n            'critical': 'dark'\n        }\n        return colors.get(self.risk_level, 'secondary')\n    \n    def get_risk_percentage(self):\n        return round(self.overall_similarity_score * 100, 1)\n    \n    def __repr__(self):\n        return f'<PlagiarismAnalysis {self.id}: {self.risk_level} ({self.overall_similarity_score:.2f})>'\n\nclass PlagiarismMatch(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    analysis_id = db.Column(db.Integer, db.ForeignKey('plagiarism_analysis.id'), nullable=False)\n    \n    # Match information\n    matched_against_id = db.Column(db.Integer, db.ForeignKey('answer.id'), nullable=False)\n    similarity_score = db.Column(db.Float, nullable=False)\n    match_type = db.Column(db.String(30), nullable=False)  # 'exact', 'paraphrase', 'structural', 'semantic'\n    \n    # Text analysis\n    matched_text_segment = db.Column(db.Text)  # The specific text that matched\n    original_text_segment = db.Column(db.Text)  # The text it matched against\n    \n    # Position information\n    start_position = db.Column(db.Integer)  # Character position in original text\n    end_position = db.Column(db.Integer)\n    \n    # Match metadata\n    algorithm_used = db.Column(db.String(50))  # Which algorithm detected this match\n    confidence = db.Column(db.Float)  # Confidence in this specific match\n    \n    # Timestamps\n    detected_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    matched_against = db.relationship('Answer', foreign_keys=[matched_against_id])\n    \n    def __repr__(self):\n        return f'<PlagiarismMatch {self.match_type}: {self.similarity_score:.2f}>'\n\n# RBAC (Role-Based Access Control) Models\n\nclass Role(db.Model):\n    \"\"\"Roles that can be assigned to users (admin, host, participant, etc.)\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True, nullable=False)\n    display_name = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.Text)\n    is_active = db.Column(db.Boolean, default=True)\n    is_system_role = db.Column(db.Boolean, default=False)  # System roles cannot be deleted\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))\n    \n    # Relationships\n    role_permissions = db.relationship('RolePermission', backref='role', lazy=True, cascade='all, delete-orphan')\n    user_roles = db.relationship('UserRole', backref='role', lazy=True, cascade='all, delete-orphan')\n    \n    @property\n    def permission_count(self):\n        try:\n            return len(list(self.role_permissions))\n        except Exception:\n            return 0\n    \n    @property\n    def user_count(self):\n        try:\n            return len(list(self.user_roles))\n        except Exception:\n            return 0\n    \n    def get_permissions(self):\n        \"\"\"Get all permission names for this role\"\"\"\n        try:\n            return [rp.permission.name for rp in self.role_permissions if rp.permission]\n        except Exception:\n            return []\n    \n    def has_permission(self, permission_name):\n        \"\"\"Check if this role has a specific permission\"\"\"\n        try:\n            return any(rp.permission.name == permission_name for rp in self.role_permissions if rp.permission)\n        except Exception:\n            return False\n    \n    def add_permission(self, permission_name):\n        \"\"\"Add a permission to this role\"\"\"\n        permission = Permission.query.filter_by(name=permission_name).first()\n        if permission and not self.has_permission(permission_name):\n            role_permission = RolePermission()\n            role_permission.role_id = self.id\n            role_permission.permission_id = permission.id\n            db.session.add(role_permission)\n            return True\n        return False\n    \n    def remove_permission(self, permission_name):\n        \"\"\"Remove a permission from this role\"\"\"\n        permission = Permission.query.filter_by(name=permission_name).first()\n        if permission:\n            role_permission = RolePermission.query.filter_by(\n                role_id=self.id, \n                permission_id=permission.id\n            ).first()\n            if role_permission:\n                db.session.delete(role_permission)\n                return True\n        return False\n    \n    def __repr__(self):\n        return f'<Role {self.name}>'\n\nclass Permission(db.Model):\n    \"\"\"Individual permissions that can be granted to roles\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    display_name = db.Column(db.String(150), nullable=False)\n    description = db.Column(db.Text)\n    category = db.Column(db.String(50), nullable=False)  # e.g., 'quiz', 'user', 'system', 'reports'\n    is_active = db.Column(db.Boolean, default=True)\n    is_system_permission = db.Column(db.Boolean, default=False)  # System permissions cannot be deleted\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    role_permissions = db.relationship('RolePermission', backref='permission', lazy=True, cascade='all, delete-orphan')\n    \n    @property\n    def role_count(self):\n        try:\n            return len(list(self.role_permissions))\n        except Exception:\n            return 0\n    \n    def get_roles(self):\n        \"\"\"Get all role names that have this permission\"\"\"\n        try:\n            return [rp.role.name for rp in self.role_permissions if rp.role]\n        except Exception:\n            return []\n    \n    def __repr__(self):\n        return f'<Permission {self.name}>'\n\nclass RolePermission(db.Model):\n    \"\"\"Association table for roles and permissions (many-to-many)\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    role_id = db.Column(db.Integer, db.ForeignKey('role.id'), nullable=False)\n    permission_id = db.Column(db.Integer, db.ForeignKey('permission.id'), nullable=False)\n    granted_at = db.Column(db.DateTime, default=datetime.utcnow)\n    granted_by = db.Column(db.Integer, db.ForeignKey('user.id'))\n    \n    # Ensure unique combinations\n    __table_args__ = (db.UniqueConstraint('role_id', 'permission_id', name='unique_role_permission'),)\n    \n    def __repr__(self):\n        return f'<RolePermission {self.role_id}->{self.permission_id}>'\n\nclass UserRole(db.Model):\n    \"\"\"Association table for users and roles (many-to-many)\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    role_id = db.Column(db.Integer, db.ForeignKey('role.id'), nullable=False)\n    assigned_at = db.Column(db.DateTime, default=datetime.utcnow)\n    assigned_by = db.Column(db.Integer, db.ForeignKey('user.id'))\n    is_active = db.Column(db.Boolean, default=True)\n    expires_at = db.Column(db.DateTime)  # Optional expiration date\n    \n    # Ensure unique combinations\n    __table_args__ = (db.UniqueConstraint('user_id', 'role_id', name='unique_user_role'),)\n    \n    # Relationships\n    assigned_by_user = db.relationship('User', foreign_keys=[assigned_by])\n    \n    @property\n    def is_expired(self):\n        return self.expires_at and datetime.utcnow() > self.expires_at\n    \n    def __repr__(self):\n        return f'<UserRole {self.user_id}->{self.role_id}>'\n\nclass RoleAuditLog(db.Model):\n    \"\"\"Audit log for role and permission changes\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    action = db.Column(db.String(50), nullable=False)  # 'create', 'update', 'delete', 'assign', 'revoke'\n    entity_type = db.Column(db.String(20), nullable=False)  # 'role', 'permission', 'user_role'\n    entity_id = db.Column(db.Integer, nullable=False)\n    target_user_id = db.Column(db.Integer, db.ForeignKey('user.id'))  # User affected by the change\n    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    old_values = db.Column(db.Text)  # JSON string of old values\n    new_values = db.Column(db.Text)  # JSON string of new values\n    reason = db.Column(db.Text)  # Optional reason for the change\n    ip_address = db.Column(db.String(45))  # IPv4 or IPv6\n    user_agent = db.Column(db.String(500))\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    target_user = db.relationship('User', foreign_keys=[target_user_id])\n    performed_by_user = db.relationship('User', foreign_keys=[performed_by])\n    \n    def __repr__(self):\n        return f'<RoleAuditLog {self.action} {self.entity_type}:{self.entity_id}>'\n","size_bytes":43997},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"flask-mail>=0.10.0\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"wtforms>=3.2.1\",\n    \"werkzeug>=3.1.3\",\n    \"sqlalchemy>=2.0.43\",\n    \"flask-login>=0.6.3\",\n    \"flask-wtf>=1.2.2\",\n    \"sendgrid>=6.12.4\",\n    \"reportlab>=4.4.3\",\n    \"openpyxl>=3.1.5\",\n    \"xlsxwriter>=3.2.5\",\n    \"pypdf2>=3.0.1\",\n    \"python-docx>=1.2.0\",\n    \"pandas>=2.3.2\",\n    \"flask-socketio>=5.5.1\",\n    \"eventlet>=0.40.3\",\n    \"docx>=0.2.4\",\n    \"requests>=2.32.5\",\n]\n","size_bytes":687},"replit.md":{"content":"# Proctoring Platform\n\n## Overview\n\nThis is a comprehensive online examination and quiz management system with advanced proctoring capabilities. The platform supports role-based access with three user types: administrators, hosts (who create and manage quizzes), and participants (who take quizzes). The system includes real-time proctoring features, email verification, quiz creation tools, and comprehensive result tracking.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Framework\n- **Flask-based web application** with SQLAlchemy ORM for database operations\n- **Role-based authentication** using Flask-Login with three user roles (admin, host, participant)\n- **Email verification system** with token-based account activation\n- **Session management** with secure session handling and proxy fix middleware\n\n### Database Design\n- **PostgreSQL database** with SQLAlchemy models for Users, Quizzes, Questions, QuestionOptions, QuizAttempts, Answers, and ProctoringEvents\n- **User model** includes verification tokens, password hashing, and role management\n- **Quiz model** supports multiple question types (multiple choice, true/false, text) with time limits and proctoring settings\n- **Attempt tracking** with comprehensive answer storage and proctoring event logging\n\n### Frontend Architecture\n- **Jinja2 templating** with Bootstrap dark theme for responsive UI\n- **Client-side JavaScript** for quiz timer, auto-save functionality, and proctoring controls\n- **Real-time proctoring** using WebRTC for camera access and browser behavior monitoring\n- **Progressive enhancement** with fallback support for non-JavaScript environments\n\n### Authentication & Authorization\n- **Password-based authentication** with werkzeug password hashing\n- **Email verification workflow** requiring users to verify email before receiving login credentials\n- **Role-based access control** with different dashboard views and permissions per role\n- **Session-based login** with secure cookie handling\n\n### Proctoring System\n- **Browser-based monitoring** including tab switching detection, fullscreen enforcement, and screenshot detection\n- **Camera integration** for facial recognition and monitoring (WebRTC-based)\n- **Behavioral tracking** monitoring mouse movements, keyboard activity, window focus, and right-click/copy-paste prevention\n- **Event logging** storing all proctoring violations and suspicious activities in the database\n\n### Quiz Management\n- **Dynamic quiz creation** with support for multiple question types and configurable time limits\n- **Real-time quiz taking** with auto-save functionality and timer warnings\n- **Comprehensive result tracking** showing scores, correct/incorrect answers, and time spent\n- **Administrative oversight** with system-wide statistics and user management\n\n## External Dependencies\n\n### Email Services\n- **Flask-Mail** for SMTP email delivery with Gmail integration support\n- **Email templates** for verification emails and credential distribution\n- **Environment-based configuration** for SMTP settings and authentication\n\n### Frontend Libraries\n- **Bootstrap 5** with dark theme variant for responsive design\n- **Font Awesome 6** for consistent iconography throughout the interface\n- **Custom CSS** for quiz-specific styling and proctoring indicators\n\n### Database\n- **PostgreSQL** as the primary database with connection pooling and health checks\n- **SQLAlchemy** for ORM operations with declarative base and relationship management\n- **Database migrations** supported through Flask-SQLAlchemy\n\n### JavaScript Libraries\n- **WebRTC APIs** for camera and microphone access in proctoring features\n- **HTML5 Canvas** for image capture and face detection processing\n- **Local Storage API** for temporary quiz answer storage and auto-save functionality\n\n### Security & Monitoring\n- **Werkzeug security** for password hashing and session management\n- **Environment variable configuration** for sensitive settings like database URLs and email credentials\n- **Proxy fix middleware** for proper header handling in production deployments","size_bytes":4125},"routes.py":{"content":"import os\nfrom flask import render_template, request, redirect, url_for, flash, jsonify, session, send_file, make_response\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom werkzeug.utils import secure_filename\nfrom app import app, db, mail, socketio\nfrom models import User, Quiz, Question, QuestionOption, QuizAttempt, Answer, ProctoringEvent, LoginEvent, UserViolation, UploadRecord, Course, HostCourseAssignment, ParticipantEnrollment, DeviceLog, SecurityAlert, CollaborationSignal, AttemptSimilarity, AlertThreshold, QuizThresholdOverride, AlertTrigger, InteractionEvent, QuestionHeatmapData, CollaborationInsight, PlagiarismAnalysis, PlagiarismMatch, Role, Permission, UserRole, RolePermission, RoleAuditLog\n\n# üõ°Ô∏è FEATURE FLAGS - Defined immediately after imports to prevent NameError\nENABLE_LTI = os.environ.get('ENABLE_LTI', 'false').lower() == 'true'\nENABLE_ANALYTICS = os.environ.get('ENABLE_ANALYTICS', 'false').lower() == 'true'\nENABLE_REPORTS = os.environ.get('ENABLE_REPORTS', 'false').lower() == 'true'\nENABLE_PLAGIARISM = os.environ.get('ENABLE_PLAGIARISM', 'false').lower() == 'true'\nENABLE_COLLABORATION = os.environ.get('ENABLE_COLLABORATION', 'false').lower() == 'true'\nENABLE_RBAC = os.environ.get('ENABLE_RBAC', 'false').lower() == 'true'\n\n# üõ°Ô∏è SAFE PLACEHOLDERS - Initialize all optional symbols as stubs to prevent LSP diagnostics\nLTIProvider = LTIUser = LTIGradePassback = LTIToolConfiguration = None\nget_lti_provider = get_lti_grade_passback = lambda *args, **kwargs: None\nProctoringReportGenerator = generate_scheduled_report = export_report_to_pdf = None\nAnalyticsEngine = PredictiveAnalytics = QuestionPerformanceAnalyzer = None\nCheatingPatternDetector = InstitutionalDashboard = get_analytics_engine = None\ndetector = None\nplagiarism_detector = None\nRBACService = None\ninitialize_rbac_system = None\n# üîí SECURITY: Fail-closed RBAC decorators - deny access when RBAC disabled  \ndef _rbac_fallback_decorator(f):\n    def wrapper(*args, **kwargs):\n        if not current_user.is_authenticated or current_user.role != 'admin':\n            flash('Access denied. Admin privileges required.', 'error')\n            return redirect(url_for('login'))\n        return f(*args, **kwargs)\n    return wrapper\nrequire_permission = lambda perm: _rbac_fallback_decorator\nrequire_role = lambda role: _rbac_fallback_decorator\nadmin_required = _rbac_fallback_decorator\npermission_context_processor = lambda: {}\n\n# Import optional LTI integration with feature flag (after placeholders)\nif ENABLE_LTI:\n    try:\n        from lti_integration import (LTIProvider, LTIUser, LTIGradePassback, LTIToolConfiguration,\n                                    get_lti_provider, get_lti_grade_passback)\n    except ImportError:\n        ENABLE_LTI = False\n\n# Import optional proctoring reports with feature flag (after placeholders)\nif ENABLE_REPORTS:\n    try:\n        from automated_proctoring_reports import ProctoringReportGenerator, generate_scheduled_report, export_report_to_pdf\n    except ImportError:\n        ENABLE_REPORTS = False\n\n# Import optional analytics engine with feature flag (after placeholders)\nif ENABLE_ANALYTICS:\n    try:\n        from analytics_engine import (AnalyticsEngine, PredictiveAnalytics, QuestionPerformanceAnalyzer, \n                                      CheatingPatternDetector, InstitutionalDashboard, get_analytics_engine)\n    except ImportError:\n        ENABLE_ANALYTICS = False\nfrom forms import RegistrationForm, LoginForm, QuizForm, QuestionForm, ProfileForm\nfrom email_service import send_verification_email, send_credentials_email, send_login_notification, send_host_login_notification\nfrom flask_mail import Message\nfrom datetime import datetime, timedelta\nimport json\nimport logging\nimport os\nimport re\nimport csv\n# Import optional data processing libraries\ntry:\n    import pandas as pd\nexcept ImportError:\n    pd = None\n\ntry:\n    import PyPDF2\nexcept ImportError:\n    PyPDF2 = None\n\ntry:\n    import docx\nexcept ImportError:\n    docx = None\nfrom io import BytesIO\nfrom sqlalchemy import func, text\nfrom sqlalchemy.orm import joinedload, selectinload\nfrom utils import get_time_greeting, get_greeting_icon\n\n# Import collaboration detection with feature flag (after placeholders)\nif ENABLE_COLLABORATION:\n    try:\n        from collaboration_detection import detector\n    except ImportError:\n        ENABLE_COLLABORATION = False\n\n# Import plagiarism detection with feature flag (after placeholders)\nif ENABLE_PLAGIARISM:\n    try:\n        from plagiarism_detector import plagiarism_detector\n    except ImportError:\n        ENABLE_PLAGIARISM = False\n\n# Import RBAC system with feature flag (after placeholders)\nif ENABLE_RBAC:\n    try:\n        from rbac_service import RBACService, initialize_rbac_system\n        from rbac_decorators import require_permission, require_role, admin_required, permission_context_processor\n    except ImportError:\n        ENABLE_RBAC = False\n\n# Add email health check endpoint\n@app.route('/admin/email-health')\n@login_required\ndef admin_email_health():\n    \"\"\"Email system health check for monitoring\"\"\"\n    # üîí SECURITY: Require admin role for health check\n    if not current_user.is_authenticated or current_user.role != 'admin':\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('login'))\n    try:\n        from email_service import brevo_service, test_email_service\n        is_healthy = test_email_service()\n        return jsonify({\n            'status': 'healthy' if is_healthy else 'unhealthy',\n            'service': 'Brevo (300/day FREE)',\n            'api_configured': bool(brevo_service.api_key),\n            'sender_configured': bool(brevo_service.sender_email),\n            'ready_for_production': is_healthy\n        })\n    except Exception as e:\n        return jsonify({'status': 'error', 'error': str(e)}), 500\n\n# Excel/Spreadsheet generation imports\nfrom openpyxl import Workbook\nfrom openpyxl.styles import Font, PatternFill, Alignment\nfrom openpyxl.utils import get_column_letter\n\n# PDF generation imports  \nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib import colors\nfrom reportlab.lib.units import inch\n\n# Global context processor to inject greeting variables\n@app.context_processor\ndef inject_greeting():\n    \"\"\"Inject time-based greeting and icon into all templates\"\"\"\n    return {\n        'greeting': get_time_greeting(),\n        'greeting_icon': get_greeting_icon()\n    }\n\n@app.route('/')\ndef index():\n    \"\"\"Home page - Redirect to register/login\"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard'))\n    return redirect(url_for('register'))\n\n@app.route('/default-accounts')\ndef default_accounts():\n    \"\"\"Show default login accounts\"\"\"\n    return render_template('default_accounts.html')\n\n@app.route('/loading')\ndef loading():\n    \"\"\"Loading page with eye animation\"\"\"\n    return render_template('loading.html')\n\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    \"\"\"User registration\"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard'))\n    \n    form = RegistrationForm()\n    if form.validate_on_submit():\n        # Check if user already exists\n        if User.query.filter_by(email=form.email.data).first():\n            flash('Email already registered. Please use a different email.', 'error')\n            return render_template('register.html', form=form)\n        \n        if User.query.filter_by(username=form.username.data).first():\n            flash('Username already taken. Please choose a different username.', 'error')\n            return render_template('register.html', form=form)\n        \n        # Create new user\n        user = User(\n            username=form.username.data,\n            email=form.email.data,\n            role=form.role.data\n        )\n        user.set_password(form.password.data)\n        \n        db.session.add(user)\n        db.session.commit()\n        \n        # Generate verification token and commit it to database\n        user.generate_verification_token()\n        db.session.commit()  # Critical: Persist the verification token\n        \n        # Send verification email\n        if send_verification_email(user):\n            flash('Registration successful! Please check your email to verify your account.', 'success')\n            return render_template('verify_email.html', user=user, resent=False)\n        else:\n            flash('Registration successful, but we could not send the verification email. You can request a new one from the login page.', 'warning')\n            return redirect(url_for('login'))\n    \n    return render_template('register.html', form=form)\n\n@app.route('/verify/<token>')\ndef verify_email(token):\n    \"\"\"Verify email address\"\"\"\n    user = User.query.filter_by(verification_token=token).first()\n    \n    if not user:\n        flash('Invalid or expired verification link.', 'error')\n        return redirect(url_for('login'))\n    \n    if user.verify_email(token):\n        # Store the original password temporarily to send in email\n        # In production, you might want to generate a temporary password instead\n        temp_password = \"Please change this password after login\"\n        \n        db.session.commit()\n        \n        # Send credentials email\n        if send_credentials_email(user, temp_password):\n            flash('Email verified successfully! Your login credentials have been sent to your email.', 'success')\n        else:\n            flash('Email verified successfully! You can now log in with your credentials.', 'success')\n    else:\n        flash('Email verification failed. Please try again.', 'error')\n    \n    return redirect(url_for('login'))\n\n@app.route('/resend-verification/<email>')\ndef resend_verification(email):\n    \"\"\"Resend email verification\"\"\"\n    user = User.query.filter_by(email=email).first()\n    \n    if not user:\n        flash('User not found.', 'error')\n        return redirect(url_for('login'))\n    \n    if user.is_verified:\n        flash('Your email is already verified. You can log in now.', 'info')\n        return redirect(url_for('login'))\n    \n    # Generate new verification token\n    user.generate_verification_token()\n    db.session.commit()\n    \n    # Send verification email\n    if send_verification_email(user):\n        flash('Verification email sent successfully! Please check your inbox and spam folder.', 'success')\n        return render_template('verify_email.html', user=user, resent=True)\n    else:\n        flash('Failed to send verification email. Please try again later.', 'error')\n    \n    return redirect(url_for('login'))\n\n@app.route('/request-verification', methods=['GET', 'POST'])\ndef request_verification():\n    \"\"\"Request email verification page\"\"\"\n    if request.method == 'POST':\n        email = request.form.get('email')\n        if not email:\n            flash('Please enter your email address.', 'error')\n            return render_template('request_verification.html')\n        \n        user = User.query.filter_by(email=email).first()\n        if not user:\n            flash('No account found with that email address.', 'error')\n            return render_template('request_verification.html')\n        \n        if user.is_verified:\n            flash('Your email is already verified. You can log in now.', 'info')\n            return redirect(url_for('login'))\n        \n        # Generate new verification token\n        user.generate_verification_token()\n        db.session.commit()\n        \n        # Send verification email\n        if send_verification_email(user):\n            flash('Verification email sent successfully! Please check your inbox and spam folder.', 'success')\n            return render_template('verify_email.html', user=user, resent=True)\n        else:\n            flash('Failed to send verification email. Please try again later.', 'error')\n    \n    return render_template('request_verification.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    \"\"\"User login\"\"\"\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard'))\n    \n    form = LoginForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(email=form.email.data).first()\n        \n        if user and user.check_password(form.password.data):\n            if not user.is_verified:\n                flash('Please verify your email address before logging in.', 'warning')\n                # Add resend verification option\n                resend_link = url_for('resend_verification', email=user.email)\n                flash(f'Need a new verification email? <a href=\"{resend_link}\">Click here to resend</a>', 'info')\n                return render_template('login.html', form=form)\n            \n            # Update last login time\n            user.last_login = datetime.utcnow()\n            \n            # Enhanced login tracking with comprehensive device/IP information\n            ip_address = request.environ.get('HTTP_X_FORWARDED_FOR', request.environ.get('REMOTE_ADDR', 'Unknown'))\n            user_agent = request.headers.get('User-Agent', '')\n            \n            # Enhanced device fingerprinting and location tracking\n            device_info = {\n                'user_agent': user_agent,\n                'ip_address': ip_address,\n                'accept_language': request.headers.get('Accept-Language', ''),\n                'accept_encoding': request.headers.get('Accept-Encoding', ''),\n                'remote_addr': request.environ.get('REMOTE_ADDR'),\n                'x_forwarded_for': request.headers.get('X-Forwarded-For', ''),\n                'x_real_ip': request.headers.get('X-Real-IP', ''),\n                'host': request.headers.get('Host', ''),\n                'referer': request.headers.get('Referer', ''),\n                'connection': request.headers.get('Connection', '')\n            }\n            \n            # Check for suspicious login patterns\n            from datetime import timedelta\n            recent_logins = LoginEvent.query.filter_by(user_id=user.id).filter(\n                LoginEvent.login_time > datetime.utcnow() - timedelta(hours=1)\n            ).count()\n            \n            # Check for different IP addresses in short time (potential location jumping)\n            different_ips = db.session.query(LoginEvent.ip_address).distinct().filter(\n                LoginEvent.user_id == user.id,\n                LoginEvent.login_time > datetime.utcnow() - timedelta(hours=24)\n            ).count()\n            \n            # Check for different user agents (device switching)\n            different_devices = db.session.query(LoginEvent.user_agent).distinct().filter(\n                LoginEvent.user_id == user.id,\n                LoginEvent.login_time > datetime.utcnow() - timedelta(days=7)\n            ).count()\n            \n            is_suspicious = recent_logins > 5 or different_ips > 3 or different_devices > 5\n            \n            # Create login event record\n            login_event = LoginEvent(\n                user_id=user.id,\n                ip_address=ip_address,\n                user_agent=user_agent,\n                device_info=json.dumps(device_info),\n                is_suspicious=is_suspicious\n            )\n            \n            db.session.add(login_event)\n            db.session.commit()\n            \n            # Send email notifications\n            try:\n                # Send notification to user\n                send_login_notification(user, login_event)\n                \n                # If participant, notify all hosts\n                if user.role == 'participant':\n                    hosts = User.query.filter_by(role='host').all()\n                    for host in hosts:\n                        send_host_login_notification(host, user, login_event)\n                        \n            except Exception as e:\n                logging.error(f\"Failed to send login notifications: {e}\")\n            \n            # DEBUG: Log login details\n            print(f\"üîç LOGIN DEBUG - User: {user.email}, Role in DB: {user.role}\")\n            print(f\"üîç LOGIN DEBUG - is_admin(): {user.is_admin()}, is_host(): {user.is_host()}, is_participant(): {user.is_participant()}\")\n            \n            login_user(user)\n            flash(f'Welcome back, {user.username}!', 'success')\n            \n            # DEBUG: Check current_user after login_user\n            print(f\"üîç LOGIN DEBUG - current_user.email: {current_user.email}, current_user.role: {current_user.role}\")\n            print(f\"üîç LOGIN DEBUG - current_user methods: is_admin()={current_user.is_admin()}, is_host()={current_user.is_host()}, is_participant()={current_user.is_participant()}\")\n            \n            next_page = request.args.get('next')\n            if next_page:\n                return redirect(next_page)\n            return redirect(url_for('dashboard'))\n        else:\n            flash('Invalid email or password.', 'error')\n    \n    return render_template('login.html', form=form)\n\n@app.route('/logout')\n@login_required\ndef logout():\n    \"\"\"User logout\"\"\"\n    logout_user()\n    flash('You have been logged out successfully.', 'info')\n    return redirect(url_for('index'))\n\n@app.route('/dashboard')\n@login_required\ndef dashboard():\n    \"\"\"Main dashboard - redirects based on user role\"\"\"\n    if current_user.is_admin():\n        return redirect(url_for('admin_dashboard'))\n    elif current_user.is_host():\n        return redirect(url_for('host_dashboard'))\n    else:\n        return redirect(url_for('participant_dashboard'))\n\n@app.route('/host/dashboard')\n@login_required\ndef host_dashboard():\n    \"\"\"Enhanced Host dashboard with participant management\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    quizzes = Quiz.query.filter_by(creator_id=current_user.id).order_by(Quiz.display_order.asc(), Quiz.created_at.desc()).all()\n    \n    # Get recent quiz attempts for host's quizzes and add heatmap data flags\n    recent_attempts = []\n    heatmap_ready_count = 0\n    \n    for quiz in quizzes:\n        attempts = QuizAttempt.query.filter_by(quiz_id=quiz.id).order_by(QuizAttempt.started_at.desc()).limit(5).all()\n        quiz.attempts = attempts  # Add attempts to quiz object for template access\n        recent_attempts.extend(attempts)\n        \n        # Check if quiz has completed attempts with interaction data for accurate heatmap counting\n        completed_attempts = QuizAttempt.query.filter_by(\n            quiz_id=quiz.id, \n            status='completed'\n        ).first()\n        \n        if completed_attempts:\n            # Check if there's actual interaction data\n            interaction_exists = InteractionEvent.query.filter_by(\n                attempt_id=completed_attempts.id\n            ).first()\n            quiz.has_heatmap_data = interaction_exists is not None\n            if quiz.has_heatmap_data:\n                heatmap_ready_count += 1\n        else:\n            quiz.has_heatmap_data = False\n    \n    recent_attempts.sort(key=lambda x: x.started_at, reverse=True)\n    recent_attempts = recent_attempts[:10]  # Show only 10 most recent\n    \n    # Get participant statistics\n    participants = User.query.filter_by(role='participant').all()\n    recent_logins = LoginEvent.query.join(User).filter(User.role == 'participant').order_by(LoginEvent.login_time.desc()).limit(10).all()\n    \n    # Get violation statistics\n    quiz_ids = [quiz.id for quiz in quizzes]\n    if quiz_ids:\n        high_violations = db.session.query(QuizAttempt, func.count(ProctoringEvent.id).label('violation_count')).join(ProctoringEvent).filter(\n            QuizAttempt.quiz_id.in_(quiz_ids),\n            ProctoringEvent.severity == 'high'\n        ).group_by(QuizAttempt.id).having(func.count(ProctoringEvent.id) > 2).all()\n    else:\n        high_violations = []\n    \n    return render_template('host_dashboard.html', \n                         quizzes=quizzes, \n                         recent_attempts=recent_attempts,\n                         participants=participants,\n                         recent_logins=recent_logins,\n                         high_violations=high_violations,\n                         heatmap_ready_count=heatmap_ready_count,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/host/total-quizzes')\n@login_required\ndef host_total_quizzes():\n    \"\"\"Show all quizzes created by the host\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get all quizzes created by this host with eager loading\n    quizzes = Quiz.query.filter_by(creator_id=current_user.id).options(\n        joinedload(Quiz.questions),\n        joinedload(Quiz.attempts)\n    ).order_by(Quiz.created_at.desc()).all()\n    \n    # Calculate statistics\n    total_questions = sum(len(quiz.questions) for quiz in quizzes)\n    total_attempts = sum(len(quiz.attempts) for quiz in quizzes)\n    \n    return render_template('host_total_quizzes.html',\n                         quizzes=quizzes,\n                         total_questions=total_questions,\n                         total_attempts=total_attempts,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/host/active-quizzes')\n@login_required\ndef host_active_quizzes():\n    \"\"\"Show active quizzes created by the host\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get active quizzes created by this host with eager loading\n    active_quizzes = Quiz.query.filter_by(\n        creator_id=current_user.id, \n        is_active=True\n    ).options(\n        joinedload(Quiz.questions),\n        joinedload(Quiz.attempts)\n    ).order_by(Quiz.created_at.desc()).all()\n    \n    # Calculate statistics for active quizzes\n    total_active_attempts = sum(len(quiz.attempts) for quiz in active_quizzes)\n    in_progress_attempts = sum(len([a for a in quiz.attempts if a.status == 'in_progress']) for quiz in active_quizzes)\n    \n    return render_template('host_active_quizzes.html',\n                         active_quizzes=active_quizzes,\n                         total_active_attempts=total_active_attempts,\n                         in_progress_attempts=in_progress_attempts,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/host/recent-attempts')\n@login_required\ndef host_recent_attempts():\n    \"\"\"Show recent quiz attempts for host's quizzes\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get recent attempts for host's quizzes with eager loading\n    quiz_ids = [quiz.id for quiz in Quiz.query.filter_by(creator_id=current_user.id).all()]\n    \n    if quiz_ids:\n        recent_attempts = QuizAttempt.query.filter(\n            QuizAttempt.quiz_id.in_(quiz_ids)\n        ).options(\n            joinedload(QuizAttempt.quiz),\n            joinedload(QuizAttempt.participant),\n            joinedload(QuizAttempt.answers)\n        ).order_by(QuizAttempt.started_at.desc()).limit(50).all()\n    else:\n        recent_attempts = []\n    \n    # Calculate statistics\n    attempts_today = sum(1 for attempt in recent_attempts \n                        if attempt.started_at.date() == datetime.utcnow().date())\n    unique_participants = len(set(attempt.participant_id for attempt in recent_attempts))\n    \n    return render_template('host_recent_attempts.html',\n                         recent_attempts=recent_attempts,\n                         attempts_today=attempts_today,\n                         unique_participants=unique_participants,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/host/completed-attempts')\n@login_required\ndef host_completed_attempts():\n    \"\"\"Show completed quiz attempts for host's quizzes\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get completed attempts for host's quizzes with eager loading\n    quiz_ids = [quiz.id for quiz in Quiz.query.filter_by(creator_id=current_user.id).all()]\n    \n    if quiz_ids:\n        completed_attempts = QuizAttempt.query.filter(\n            QuizAttempt.quiz_id.in_(quiz_ids),\n            QuizAttempt.status == 'completed'\n        ).options(\n            joinedload(QuizAttempt.quiz),\n            joinedload(QuizAttempt.participant),\n            joinedload(QuizAttempt.answers)\n        ).order_by(QuizAttempt.completed_at.desc()).all()\n    else:\n        completed_attempts = []\n    \n    # Calculate statistics\n    if completed_attempts:\n        scores = [attempt.score for attempt in completed_attempts if attempt.score is not None]\n        avg_score = sum(scores) / len(scores) if scores else 0\n        highest_score = max(scores) if scores else 0\n        lowest_score = min(scores) if scores else 0\n        \n        # Performance breakdown\n        excellent_count = len([s for s in scores if s >= 80])\n        good_count = len([s for s in scores if 60 <= s < 80])\n        needs_improvement_count = len([s for s in scores if s < 60])\n    else:\n        avg_score = highest_score = lowest_score = 0\n        excellent_count = good_count = needs_improvement_count = 0\n    \n    performance_breakdown = {\n        'excellent': excellent_count,\n        'good': good_count,\n        'needs_improvement': needs_improvement_count\n    }\n    \n    return render_template('host_completed_attempts.html',\n                         completed_attempts=completed_attempts,\n                         avg_score=round(avg_score, 1),\n                         highest_score=highest_score,\n                         lowest_score=lowest_score,\n                         performance_breakdown=performance_breakdown,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/host/monitoring')\n@login_required  \ndef host_monitoring():\n    \"\"\"Real-time participant monitoring panel\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get active quiz attempts\n    active_attempts = QuizAttempt.query.filter_by(status='in_progress').join(Quiz).filter(\n        Quiz.creator_id == current_user.id if not current_user.is_admin() else True\n    ).all()\n    \n    # Get recent login events\n    recent_logins = LoginEvent.query.order_by(LoginEvent.login_time.desc()).limit(20).all()\n    \n    # OPTIMIZED: Get consolidated violations per person (one entry per person)\n    from sqlalchemy import func, case\n    \n    # CORRECTED: Single-query solution with proper SQL and highest severity selection\n    from sqlalchemy import desc\n    \n    # CORRECTED: Window functions computed BEFORE filtering to get accurate counts\n    violations_with_stats = db.session.query(\n        User.id.label('participant_id'),\n        User.username.label('participant_name'),\n        Quiz.id.label('quiz_id'),\n        Quiz.title.label('quiz_title'),\n        ProctoringEvent.event_type,\n        ProctoringEvent.severity,\n        ProctoringEvent.timestamp,\n        # Rank by severity (highest first), then by timestamp (latest first)\n        func.row_number().over(\n            partition_by=[User.id, Quiz.id],\n            order_by=[\n                case(\n                    (ProctoringEvent.severity == 'critical', 4),\n                    (ProctoringEvent.severity == 'high', 3),\n                    (ProctoringEvent.severity == 'medium', 2),\n                    (ProctoringEvent.severity == 'low', 1),\n                    else_=1  # Default to 'low' rank for unknown severities\n                ).desc(),\n                ProctoringEvent.timestamp.desc()\n            ]\n        ).label('severity_rank'),\n        # CRITICAL: Compute counts and max timestamp BEFORE filtering\n        func.count().over(partition_by=[User.id, Quiz.id]).label('violation_count'),\n        func.max(ProctoringEvent.timestamp).over(partition_by=[User.id, Quiz.id]).label('latest_violation_time')\n    ).select_from(User) \\\n     .join(QuizAttempt, QuizAttempt.participant_id == User.id) \\\n     .join(Quiz, QuizAttempt.quiz_id == Quiz.id) \\\n     .join(ProctoringEvent, ProctoringEvent.attempt_id == QuizAttempt.id) \\\n     .filter(\n         Quiz.creator_id == current_user.id if not current_user.is_admin() else True\n     ).subquery()\n    \n    # Get only the highest severity violation (rank 1) with accurate stats\n    consolidated_violations = db.session.query(\n        violations_with_stats.c.participant_id,\n        violations_with_stats.c.participant_name,\n        violations_with_stats.c.quiz_id,\n        violations_with_stats.c.quiz_title,\n        violations_with_stats.c.event_type.label('display_violation_type'),\n        violations_with_stats.c.severity.label('display_severity'),\n        violations_with_stats.c.timestamp.label('highest_severity_time'),\n        violations_with_stats.c.violation_count,\n        violations_with_stats.c.latest_violation_time\n    ).filter(violations_with_stats.c.severity_rank == 1) \\\n     .order_by(violations_with_stats.c.latest_violation_time.desc()) \\\n     .limit(30).all()\n    \n    # Format results for template\n    recent_violations = []\n    for result in consolidated_violations:\n        recent_violations.append({\n            'participant_id': result.participant_id,\n            'participant_name': result.participant_name,\n            'quiz_id': result.quiz_id,\n            'quiz_title': result.quiz_title,\n            'display_violation_type': result.display_violation_type,\n            'display_severity': result.display_severity,\n            'latest_violation_time': result.latest_violation_time,\n            'violation_count': result.violation_count,\n            'is_multiple': result.violation_count > 1\n        })\n    \n    # Get participant device info\n    participants_online = []\n    for attempt in active_attempts:\n        # Get latest login for this participant\n        latest_login = LoginEvent.query.filter_by(user_id=attempt.participant_id).order_by(\n            LoginEvent.login_time.desc()\n        ).first()\n        \n        # Get violation count for this attempt\n        violation_count = ProctoringEvent.query.filter_by(attempt_id=attempt.id).count()\n        \n        participants_online.append({\n            'attempt': attempt,\n            'latest_login': latest_login,\n            'violation_count': violation_count,\n            'time_elapsed': datetime.utcnow() - attempt.started_at,\n            'quiz_title': attempt.quiz.title\n        })\n    \n    return render_template('host_monitoring.html',\n                         active_attempts=active_attempts,\n                         participants_online=participants_online,\n                         recent_logins=recent_logins,\n                         recent_violations=recent_violations)\n\n@app.route('/api/monitoring/live-data')\n@login_required\ndef get_live_monitoring_data():\n    \"\"\"API endpoint for real-time monitoring data\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    # Get active attempts\n    active_attempts = QuizAttempt.query.filter_by(status='in_progress').join(Quiz).filter(\n        Quiz.creator_id == current_user.id if not current_user.is_admin() else True\n    ).all()\n    \n    participants_data = []\n    for attempt in active_attempts:\n        # OPTIMIZED: Use highest risk summary instead of individual violations\n        # Get violation summary for this attempt using new schema optimization\n        if hasattr(attempt, 'highest_risk_level') and attempt.highest_risk_level:\n            violation_count = 0\n            latest_violation = attempt.highest_risk_level\n            if attempt.violation_counts_json:\n                try:\n                    import json\n                    counts = json.loads(attempt.violation_counts_json)\n                    violation_count = sum(counts.values()) if counts else 0\n                except:\n                    violation_count = 0\n        else:\n            # Fallback: Get violation count directly from database (for older records)\n            violations = ProctoringEvent.query.filter_by(attempt_id=attempt.id).all()\n            violation_count = len(violations)\n            latest_violation = violations[0].event_type if violations else None\n        \n        # Calculate time remaining\n        time_elapsed = datetime.utcnow() - attempt.started_at\n        time_remaining = timedelta(minutes=attempt.quiz.time_limit) - time_elapsed\n        \n        participants_data.append({\n            'attempt_id': attempt.id,\n            'participant_name': attempt.participant.username,\n            'quiz_title': attempt.quiz.title,\n            'time_elapsed': str(time_elapsed).split('.')[0],\n            'time_remaining': str(time_remaining).split('.')[0] if time_remaining.total_seconds() > 0 else 'Overtime',\n            'violation_count': violation_count,\n            'latest_violation': latest_violation,\n            'questions_answered': len(attempt.answers),\n            'total_questions': len(attempt.quiz.questions),\n            'progress_percentage': round((len(attempt.answers) / len(attempt.quiz.questions)) * 100) if attempt.quiz.questions else 0\n        })\n    \n    return jsonify({\n        'participants': participants_data,\n        'total_active': len(participants_data),\n        'timestamp': datetime.utcnow().isoformat()\n    })\n\n@app.route('/participant/dashboard')\n@login_required\ndef participant_dashboard():\n    \"\"\"Participant dashboard\"\"\"\n    # Get available quizzes (you might want to implement invitation system)\n    available_quizzes = Quiz.query.filter_by(is_active=True).all()\n    \n    # Get participant's quiz attempts\n    my_attempts = QuizAttempt.query.filter_by(participant_id=current_user.id).order_by(QuizAttempt.started_at.desc()).all()\n    \n    return render_template('participant_dashboard.html', \n                         available_quizzes=available_quizzes, \n                         my_attempts=my_attempts,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/participant/completed')\n@login_required\ndef participant_completed():\n    \"\"\"Show completed quizzes for participant\"\"\"\n    if current_user.role != 'participant':\n        flash('Access denied. Participants only.', 'error')\n        return redirect(url_for('index'))\n    \n    # Get completed quiz attempts with eager loading\n    completed_attempts = QuizAttempt.query.filter_by(\n        participant_id=current_user.id, \n        status='completed'\n    ).options(\n        joinedload(QuizAttempt.quiz).joinedload(Quiz.questions),\n        joinedload(QuizAttempt.answers)\n    ).order_by(QuizAttempt.completed_at.desc()).all()\n    \n    # Calculate total questions answered\n    total_questions_answered = 0\n    for attempt in completed_attempts:\n        total_questions_answered += len(attempt.quiz.questions)\n    \n    return render_template('participant_completed.html', \n                         completed_attempts=completed_attempts,\n                         total_questions_answered=total_questions_answered,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/participant/in-progress')\n@login_required\ndef participant_in_progress():\n    \"\"\"Show in-progress quizzes for participant\"\"\"\n    if current_user.role != 'participant':\n        flash('Access denied. Participants only.', 'error')\n        return redirect(url_for('index'))\n    \n    # Get in-progress quiz attempts with eager loading\n    in_progress_attempts = QuizAttempt.query.filter_by(\n        participant_id=current_user.id, \n        status='in_progress'\n    ).options(\n        joinedload(QuizAttempt.quiz).joinedload(Quiz.questions),\n        joinedload(QuizAttempt.answers)\n    ).order_by(QuizAttempt.started_at.desc()).all()\n    \n    # Calculate time remaining for each attempt\n    from datetime import datetime, timedelta\n    for attempt in in_progress_attempts:\n        if attempt.quiz.time_limit and attempt.started_at:\n            time_elapsed = datetime.utcnow() - attempt.started_at\n            time_elapsed_minutes = time_elapsed.total_seconds() / 60\n            time_remaining = attempt.quiz.time_limit - time_elapsed_minutes\n            attempt.time_remaining = max(0, int(time_remaining))\n        else:\n            attempt.time_remaining = None\n    \n    return render_template('participant_in_progress.html', \n                         in_progress_attempts=in_progress_attempts,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/participant/average-score')\n@login_required\ndef participant_average_score():\n    \"\"\"Show score analysis for participant\"\"\"\n    if current_user.role != 'participant':\n        flash('Access denied. Participants only.', 'error')\n        return redirect(url_for('index'))\n    \n    # Get completed quiz attempts with scores and eager loading\n    scored_attempts = QuizAttempt.query.filter_by(\n        participant_id=current_user.id, \n        status='completed'\n    ).filter(QuizAttempt.score.is_not(None)).options(\n        joinedload(QuizAttempt.quiz),\n        joinedload(QuizAttempt.answers)\n    ).order_by(QuizAttempt.completed_at.desc()).all()\n    \n    # Calculate score statistics\n    if scored_attempts:\n        scores = [attempt.score for attempt in scored_attempts]\n        avg_score = sum(scores) / len(scores)\n        highest_score = max(scores)\n        lowest_score = min(scores)\n        \n        # Calculate performance breakdown\n        excellent_count = len([s for s in scores if s >= 80])\n        good_count = len([s for s in scores if 60 <= s < 80])\n        needs_improvement_count = len([s for s in scores if s < 60])\n    else:\n        avg_score = highest_score = lowest_score = 0\n        excellent_count = good_count = needs_improvement_count = 0\n    \n    performance_breakdown = {\n        'excellent': excellent_count,\n        'good': good_count,\n        'needs_improvement': needs_improvement_count\n    }\n    \n    return render_template('participant_average_score.html', \n                         scored_attempts=scored_attempts,\n                         avg_score=round(avg_score, 1),\n                         highest_score=highest_score,\n                         lowest_score=lowest_score,\n                         total_quizzes=len(scored_attempts),\n                         performance_breakdown=performance_breakdown,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/participant/violations')\n@login_required\ndef participant_violations():\n    \"\"\"Show violation history for participant\"\"\"\n    if current_user.role != 'participant':\n        flash('Access denied. Participants only.', 'error')\n        return redirect(url_for('index'))\n    \n    # OPTIMIZED: Use highest risk summary instead of aggregating individual violations\n    attempts_with_violations = QuizAttempt.query.filter(\n        QuizAttempt.participant_id == current_user.id,\n        QuizAttempt.highest_risk_severity > 1  # Only show attempts with violations (above 'low')\n    ).options(\n        joinedload(QuizAttempt.quiz)\n    ).order_by(QuizAttempt.started_at.desc()).all()\n    \n    # Count violations using the summary fields (much faster)\n    critical_count = sum(1 for attempt in attempts_with_violations if attempt.highest_risk_level == 'critical')\n    high_count = sum(1 for attempt in attempts_with_violations if attempt.highest_risk_level == 'high')\n    \n    # Create simplified violations_by_attempt structure using highest risk only\n    violations_by_attempt = {}\n    total_violations = 0\n    \n    for attempt in attempts_with_violations:\n        # Parse violation counts from JSON\n        try:\n            import json\n            counts = json.loads(attempt.violation_counts_json) if attempt.violation_counts_json else {}\n            attempt_total = sum(counts.values()) if counts else 0\n            total_violations += attempt_total\n        except:\n            attempt_total = 0\n        \n        # Show only the highest risk level violation for this attempt\n        violations_by_attempt[attempt.id] = {\n            'attempt': attempt,\n            'highest_risk_level': attempt.highest_risk_level,\n            'highest_risk_severity': attempt.highest_risk_severity,\n            'violation_count': attempt_total,\n            'violation_counts': counts if 'counts' in locals() else {}\n        }\n    \n    return render_template('participant_violations.html', \n                         violations_by_attempt=violations_by_attempt,\n                         total_violations=total_violations,\n                         critical_count=critical_count,\n                         high_count=high_count,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/quiz_listing')\n@login_required\ndef quiz_listing():\n    \"\"\"Quiz listing page with mobile interface\"\"\"\n    if current_user.role != 'participant':\n        flash('Access denied. Participants only.', 'error')\n        return redirect(url_for('index'))\n    \n    # Get available quizzes for this participant\n    available_quizzes = Quiz.query.filter_by(is_active=True).all()\n    \n    # Get participant's quiz attempts\n    my_attempts = QuizAttempt.query.filter_by(participant_id=current_user.id).order_by(QuizAttempt.started_at.desc()).all()\n    \n    return render_template('quiz_listing.html', \n                         available_quizzes=available_quizzes,\n                         my_attempts=my_attempts,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/admin/dashboard')\n@login_required\ndef admin_dashboard():\n    \"\"\"Admin dashboard\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get system statistics\n    total_users = User.query.count()\n    total_hosts = User.query.filter_by(role='host').count()\n    total_participants = User.query.filter_by(role='participant').count()\n    total_quizzes = Quiz.query.count()\n    total_attempts = QuizAttempt.query.count()\n    total_courses = Course.query.count()\n    total_violation_appeals = db.session.query(UserViolation).filter_by(is_flagged=True).count()\n    \n    # Recent registrations\n    recent_users = User.query.order_by(User.created_at.desc()).limit(10).all()\n    \n    stats = {\n        'total_users': total_users,\n        'total_hosts': total_hosts,\n        'total_participants': total_participants,\n        'total_quizzes': total_quizzes,\n        'total_attempts': total_attempts,\n        'total_courses': total_courses,\n        'total_violation_appeals': total_violation_appeals\n    }\n    \n    return render_template('admin_dashboard.html', \n                         stats=stats, \n                         recent_users=recent_users,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n@app.route('/admin/export-database')\n@login_required\ndef admin_export_database():\n    \"\"\"Export complete database to Excel with comprehensive error handling\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    try:\n        from openpyxl import Workbook\n        from openpyxl.styles import Font, PatternFill\n        from io import BytesIO\n        \n        wb = Workbook()\n        \n        # Users Sheet\n        ws_users = wb.active\n        ws_users.title = \"Users\"\n        users_headers = ['ID', 'Username', 'Email', 'Role', 'Is Verified', 'Created At']\n        \n        for col, header in enumerate(users_headers, 1):\n            cell = ws_users.cell(row=1, column=col, value=header)\n            cell.font = Font(bold=True)\n            cell.fill = PatternFill(start_color=\"4472C4\", end_color=\"4472C4\", fill_type=\"solid\")\n        \n        # Fetch users with error handling\n        try:\n            users = User.query.all()\n        except Exception as e:\n            logging.error(f\"Database error fetching users: {e}\")\n            flash('Error accessing user data for export.', 'error')\n            return redirect(url_for('admin_dashboard'))\n        \n        for row, user in enumerate(users, 2):\n            try:\n                ws_users.cell(row=row, column=1, value=user.id)\n                ws_users.cell(row=row, column=2, value=user.username or 'N/A')\n                ws_users.cell(row=row, column=3, value=user.email or 'N/A')\n                ws_users.cell(row=row, column=4, value=user.role or 'N/A')\n                ws_users.cell(row=row, column=5, value='Yes' if user.is_verified else 'No')\n                ws_users.cell(row=row, column=6, value=user.created_at.strftime('%Y-%m-%d %H:%M:%S') if user.created_at else 'N/A')\n            except Exception as e:\n                logging.warning(f\"Error exporting user {user.id}: {e}\")\n                continue\n        \n        # Save to BytesIO with error handling\n        try:\n            buffer = BytesIO()\n            wb.save(buffer)\n            buffer.seek(0)\n        except Exception as e:\n            logging.error(f\"Error creating Excel file: {e}\")\n            flash('Error generating export file.', 'error')\n            return redirect(url_for('admin_dashboard'))\n        \n        return send_file(\n            BytesIO(buffer.read()),\n            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            as_attachment=True,\n            download_name=f'database_export_{datetime.utcnow().strftime(\"%Y%m%d_%H%M%S\")}.xlsx'\n        )\n        \n    except Exception as e:\n        logging.error(f\"Unexpected error in database export: {e}\")\n        flash('Database export failed due to an unexpected error.', 'error')\n        return redirect(url_for('admin_dashboard'))\n\n# File Upload and Auto-Question Generation System\n\nALLOWED_EXTENSIONS = {'pdf', 'docx', 'csv', 'xlsx', 'txt'}\nUPLOAD_FOLDER = 'uploads'\nQUIZ_ANSWER_UPLOAD_FOLDER = 'uploads/quiz_answers'\n\n# Create upload directories if they don't exist\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\nos.makedirs(QUIZ_ANSWER_UPLOAD_FOLDER, exist_ok=True)\n\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/api/upload-quiz-file', methods=['POST'])\n@login_required\ndef upload_quiz_file():\n    \"\"\"Upload file and extract candidate questions with enhanced security\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n    \n    file = request.files['file']\n    \n    if file.filename == '':\n        return jsonify({'error': 'No file selected'}), 400\n    \n    if not allowed_file(file.filename):\n        return jsonify({'error': 'File type not supported. Use PDF, DOCX, CSV, XLSX, or TXT files.'}), 400\n    \n    # Check file size (max 10MB)\n    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB\n    file.seek(0, 2)  # Seek to end to get size\n    file_size = file.tell()\n    file.seek(0)  # Reset to beginning\n    \n    if file_size > MAX_FILE_SIZE:\n        return jsonify({'error': 'File too large. Maximum size is 10MB.'}), 400\n    \n    if file_size == 0:\n        return jsonify({'error': 'File is empty.'}), 400\n    \n    try:\n        # Secure filename and save\n        filename = secure_filename(file.filename or 'upload')\n        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')\n        filename = f\"{timestamp}_{filename}\"\n        file_path = os.path.join(UPLOAD_FOLDER, filename)\n        file.save(file_path)\n        \n        # Create upload record with proper validation\n        try:\n            upload_record = UploadRecord(\n                host_id=current_user.id,\n                filename=filename,\n                mime_type=file.content_type or 'application/octet-stream',\n                stored_path=file_path,\n                file_size=file_size,\n                parsed=False\n            )\n            db.session.add(upload_record)\n            db.session.commit()\n        except Exception as e:\n            logging.error(f\"Database error creating upload record: {e}\")\n            return jsonify({'error': 'Failed to save upload record'}), 500\n        \n        # Parse file and extract candidate questions\n        candidate_questions = parse_file_for_questions(file_path, file.content_type)\n        \n        # Store candidate questions as JSON\n        upload_record.candidate_questions_json = json.dumps(candidate_questions)\n        upload_record.parsed = True\n        db.session.commit()\n        \n        return jsonify({\n            'upload_record_id': upload_record.id,\n            'candidate_count': len(candidate_questions),\n            'filename': filename,\n            'message': f'Successfully extracted {len(candidate_questions)} candidate questions'\n        })\n        \n    except Exception as e:\n        logging.error(f\"File upload error: {e}\")\n        return jsonify({'error': f'Upload failed: {str(e)}'}), 500\n\n@app.route('/api/upload-quiz-create-draft', methods=['POST'])\n@login_required\ndef upload_quiz_create_draft():\n    \"\"\"Create draft quiz from uploaded file\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    data = request.json\n    upload_record_id = data.get('upload_record_id')\n    num_questions = data.get('N', 10)\n    quiz_title = data.get('title', 'Auto-Generated Quiz')\n    quiz_description = data.get('description', 'Quiz generated from uploaded file')\n    \n    upload_record = UploadRecord.query.get_or_404(upload_record_id)\n    \n    if upload_record.host_id != current_user.id:\n        return jsonify({'error': 'Access denied'}), 403\n    \n    try:\n        # Load candidate questions\n        candidate_questions = json.loads(upload_record.candidate_questions_json)\n        \n        # Select top N questions\n        selected_questions = select_top_questions(candidate_questions, num_questions)\n        \n        # Create draft quiz\n        quiz = Quiz(\n            title=quiz_title,\n            description=quiz_description,\n            creator_id=current_user.id,\n            auto_generate_from_upload=True,\n            draft_from_upload_id=upload_record.id,\n            is_active=False  # Draft mode\n        )\n        db.session.add(quiz)\n        db.session.flush()  # Get quiz ID\n        \n        # Create questions and options\n        for i, q_data in enumerate(selected_questions):\n            question = Question(\n                quiz_id=quiz.id,\n                question_text=q_data['question'],\n                question_type=q_data.get('type', 'multiple_choice'),\n                points=q_data.get('points', 1),\n                order=i + 1\n            )\n            db.session.add(question)\n            db.session.flush()  # Get question ID\n            \n            # Add options for multiple choice questions\n            if question.question_type in ['multiple_choice', 'true_false']:\n                for j, option_text in enumerate(q_data.get('options', [])):\n                    option = QuestionOption(\n                        question_id=question.id,\n                        option_text=option_text,\n                        is_correct=j == q_data.get('correct_option_index', 0),\n                        order=j + 1\n                    )\n                    db.session.add(option)\n        \n        upload_record.parsed_to_quiz_id = quiz.id\n        db.session.commit()\n        \n        return jsonify({\n            'draft_quiz_id': quiz.id,\n            'message': f'Created draft quiz with {len(selected_questions)} questions'\n        })\n        \n    except Exception as e:\n        logging.error(f\"Draft creation error: {e}\")\n        db.session.rollback()\n        return jsonify({'error': f'Failed to create draft: {str(e)}'}), 500\n\ndef parse_file_for_questions(file_path, mime_type):\n    \"\"\"Parse uploaded file to extract candidate questions\"\"\"\n    candidate_questions = []\n    \n    try:\n        if 'pdf' in mime_type:\n            candidate_questions = parse_pdf_questions(file_path)\n        elif 'docx' in mime_type or 'document' in mime_type:\n            candidate_questions = parse_docx_questions(file_path)\n        elif 'csv' in mime_type:\n            candidate_questions = parse_csv_questions(file_path)\n        elif 'spreadsheet' in mime_type or 'excel' in mime_type:\n            candidate_questions = parse_excel_questions(file_path)\n        elif 'text' in mime_type:\n            candidate_questions = parse_text_questions(file_path)\n        \n    except Exception as e:\n        logging.error(f\"File parsing error: {e}\")\n        \n    return candidate_questions\n\ndef parse_pdf_questions(file_path):\n    \"\"\"Extract questions from PDF file with enhanced error handling\"\"\"\n    questions = []\n    \n    try:\n        # Validate file exists and is readable\n        if not os.path.exists(file_path):\n            logging.error(f\"PDF file not found: {file_path}\")\n            return questions\n            \n        if os.path.getsize(file_path) == 0:\n            logging.error(f\"PDF file is empty: {file_path}\")\n            return questions\n        \n        with open(file_path, 'rb') as file:\n            try:\n                pdf_reader = PyPDF2.PdfReader(file)\n                \n                if len(pdf_reader.pages) == 0:\n                    logging.warning(f\"PDF has no pages: {file_path}\")\n                    return questions\n                \n                text = \"\"\n                for page_num, page in enumerate(pdf_reader.pages):\n                    try:\n                        page_text = page.extract_text()\n                        if page_text:\n                            text += page_text + \"\\n\"\n                    except Exception as e:\n                        logging.warning(f\"Error extracting text from page {page_num}: {e}\")\n                        continue\n                        \n                if len(text.strip()) < 10:\n                    logging.warning(f\"PDF contains very little text: {file_path}\")\n                    return questions\n                \n                # Parse text for questions with error handling\n                questions = extract_questions_from_text(text)\n                \n            except PyPDF2.errors.PdfReadError as e:\n                logging.error(f\"PDF read error: {e}\")\n            except Exception as e:\n                logging.error(f\"Unexpected PDF parsing error: {e}\")\n        \n    except Exception as e:\n        logging.error(f\"File access error for PDF {file_path}: {e}\")\n    \n    return questions\n\ndef parse_docx_questions(file_path):\n    \"\"\"Extract questions from DOCX file with enhanced error handling\"\"\"\n    questions = []\n    \n    try:\n        # Validate file exists and is readable\n        if not os.path.exists(file_path):\n            logging.error(f\"DOCX file not found: {file_path}\")\n            return questions\n            \n        if os.path.getsize(file_path) == 0:\n            logging.error(f\"DOCX file is empty: {file_path}\")\n            return questions\n        \n        try:\n            doc = docx.Document(file_path)\n            text = \"\"\n            \n            if len(doc.paragraphs) == 0:\n                logging.warning(f\"DOCX has no paragraphs: {file_path}\")\n                return questions\n            \n            for paragraph in doc.paragraphs:\n                if paragraph.text.strip():\n                    text += paragraph.text + \"\\n\"\n            \n            # Also extract text from tables if present\n            for table in doc.tables:\n                for row in table.rows:\n                    for cell in row.cells:\n                        if cell.text.strip():\n                            text += cell.text + \"\\n\"\n                            \n            if len(text.strip()) < 10:\n                logging.warning(f\"DOCX contains very little text: {file_path}\")\n                return questions\n            \n            # Parse text for questions with error handling\n            questions = extract_questions_from_text(text)\n            \n        except docx.opc.exceptions.PackageNotFoundError as e:\n            logging.error(f\"Invalid DOCX format: {e}\")\n        except Exception as e:\n            logging.error(f\"Unexpected DOCX parsing error: {e}\")\n        \n    except Exception as e:\n        logging.error(f\"File access error for DOCX {file_path}: {e}\")\n    \n    return questions\n\ndef parse_csv_questions(file_path):\n    \"\"\"Extract questions from CSV file with robust error handling\"\"\"\n    questions = []\n    \n    try:\n        # Try different encodings and delimiters\n        for encoding in ['utf-8', 'latin-1', 'cp1252']:\n            try:\n                df = pd.read_csv(file_path, encoding=encoding)\n                break\n            except UnicodeDecodeError:\n                continue\n        else:\n            # If all encodings fail, return empty\n            logging.error(f\"Could not decode CSV file: {file_path}\")\n            return questions\n        \n        if df.empty:\n            return questions\n            \n        # Expected columns: question, option_a, option_b, option_c, option_d, correct_answer\n        for idx, row in df.iterrows():\n            if 'question' in df.columns and pd.notna(row.get('question')):\n                question_data = {\n                    'question': str(row.get('question', '')),\n                    'type': 'multiple_choice',\n                    'options': [],\n                    'correct_option_index': 0,\n                    'confidence': 0.9  # High confidence for structured data\n                }\n                \n                # Extract options\n                option_cols = [col for col in df.columns if col.startswith('option')]\n                for col in option_cols:\n                    if pd.notna(row[col]):\n                        question_data['options'].append(str(row[col]))\n                \n                # Determine correct answer\n                if 'correct_answer' in df.columns:\n                    correct_text = str(row['correct_answer']).strip()\n                    for i, option in enumerate(question_data['options']):\n                        if option.strip().lower() == correct_text.lower():\n                            question_data['correct_option_index'] = i\n                            break\n                \n                if question_data['question'] and len(question_data['options']) >= 2:\n                    questions.append(question_data)\n        \n    except Exception as e:\n        logging.error(f\"CSV parsing error: {e}\")\n    \n    return questions\n\ndef parse_excel_questions(file_path):\n    \"\"\"Extract questions from Excel file\"\"\"\n    questions = []\n    \n    try:\n        df = pd.read_excel(file_path)\n        \n        # Similar to CSV parsing\n        for _, row in df.iterrows():\n            if 'question' in df.columns:\n                question_data = {\n                    'question': str(row.get('question', '')),\n                    'type': 'multiple_choice',\n                    'options': [],\n                    'correct_option_index': 0,\n                    'confidence': 0.9\n                }\n                \n                # Extract options\n                option_cols = [col for col in df.columns if 'option' in col.lower()]\n                for col in option_cols:\n                    if pd.notna(row[col]):\n                        question_data['options'].append(str(row[col]))\n                \n                # Determine correct answer\n                if 'correct_answer' in df.columns:\n                    correct_text = str(row['correct_answer']).strip()\n                    for i, option in enumerate(question_data['options']):\n                        if option.strip().lower() == correct_text.lower():\n                            question_data['correct_option_index'] = i\n                            break\n                \n                if question_data['question'] and len(question_data['options']) >= 2:\n                    questions.append(question_data)\n        \n    except Exception as e:\n        logging.error(f\"Excel parsing error: {e}\")\n    \n    return questions\n\ndef parse_text_questions(file_path):\n    \"\"\"Extract questions from plain text file\"\"\"\n    questions = []\n    \n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            text = file.read()\n        \n        questions = extract_questions_from_text(text)\n        \n    except Exception as e:\n        logging.error(f\"Text parsing error: {e}\")\n    \n    return questions\n\ndef extract_questions_from_text(text):\n    \"\"\"Extract questions from text using improved regex patterns\"\"\"\n    questions = []\n    \n    if not text or len(text.strip()) < 20:\n        return questions\n    \n    try:\n        # Split text into lines for better processing\n        lines = text.strip().split('\\n')\n        current_question = None\n        current_options = []\n        correct_index = 0\n        \n        i = 0\n        while i < len(lines):\n            line = lines[i].strip()\n            \n            # Skip empty lines\n            if not line:\n                i += 1\n                continue\n            \n            # Check for numbered question format (1. Question text)\n            question_match = re.match(r'^(\\d+)\\.?\\s*(.+)', line)\n            if question_match:\n                # Save previous question if exists\n                if current_question and len(current_options) >= 2:\n                    questions.append({\n                        'question': current_question,\n                        'type': 'multiple_choice',\n                        'options': current_options,\n                        'correct_option_index': correct_index,\n                        'confidence': 0.9\n                    })\n                \n                # Start new question\n                current_question = question_match.group(2).strip()\n                current_options = []\n                correct_index = 0\n                \n            # Check for option format (A) Option text, *A) Option text, or A) *Option text)\n            elif re.match(r'^[\\*]?[A-Da-d]\\)\\s*', line):\n                # Handle asterisk before label: \"*A) Option\"  \n                leading_star = line.startswith('*')\n                tmp = line[1:].lstrip() if leading_star else line\n                \n                # Extract the option body (everything after \"A) \")\n                option_match = re.match(r'^[A-Da-d][\\)\\.]\\s*(.+)', tmp)\n                if option_match:\n                    body = option_match.group(1)\n                    \n                    # Handle asterisk after label: \"A) *Option\"\n                    post_star = body.lstrip().startswith('*')\n                    if post_star:\n                        body = body.lstrip()[1:].lstrip()\n                    \n                    is_correct = leading_star or post_star\n                    clean_option = body.strip()\n                    \n                    if is_correct:\n                        correct_index = len(current_options)\n                    \n                    current_options.append(clean_option)\n            \n            # Check for alternative question formats\n            elif line.startswith('Q:') or line.startswith('Question:'):\n                if current_question and len(current_options) >= 2:\n                    questions.append({\n                        'question': current_question,\n                        'type': 'multiple_choice',\n                        'options': current_options,\n                        'correct_option_index': correct_index,\n                        'confidence': 0.9\n                    })\n                \n                current_question = line.split(':', 1)[1].strip()\n                current_options = []\n                correct_index = 0\n            \n            i += 1\n        \n        # Add the last question if exists\n        if current_question and len(current_options) >= 2:\n            questions.append({\n                'question': current_question,\n                'type': 'multiple_choice',\n                'options': current_options,\n                'correct_option_index': correct_index,\n                'confidence': 0.9\n            })\n        \n        # If no questions found with structured approach, try regex fallback\n        if not questions:\n            # Clean and normalize text for regex patterns\n            text_normalized = re.sub(r'\\s+', ' ', text.strip())\n            \n            # Enhanced patterns for different question formats\n            patterns = [\n                # Pattern 1: Numbered questions with options (1. Question A) option B) option)\n                r'(\\d+\\.?\\s*)(.*?)\\s*((?:[A-Da-d][\\)\\.].*?)(?=\\d+\\.|$))',\n                # Pattern 2: Questions with options on new lines\n                r'(Question\\s*\\d*:?\\s*)(.*?)\\s*((?:[A-Da-d][\\)\\.].*?)(?=Question|\\d+\\.|$))',\n            ]\n            \n            # Try each pattern to extract questions\n            for pattern in patterns:\n                matches = re.finditer(pattern, text_normalized, re.MULTILINE | re.DOTALL)\n                \n                for match in matches:\n                    try:\n                        if len(match.groups()) >= 2:\n                            question_text = match.group(-2).strip()\n                            options_text = match.group(-1).strip()\n                            \n                            if len(question_text) > 10:\n                                question_data = {\n                                    'question': question_text,\n                                    'type': 'multiple_choice',\n                                    'options': [],\n                                    'correct_option_index': 0,\n                                    'confidence': 0.7\n                                }\n                                \n                                # Extract individual options\n                                option_parts = re.findall(r'[A-Da-d][\\)\\.]([^A-Da-d\\)\\.]*)(?=[A-Da-d][\\)\\.]|$)', options_text)\n                                question_data['options'] = [opt.strip() for opt in option_parts if opt.strip()]\n                                \n                                if len(question_data['options']) >= 2:\n                                    questions.append(question_data)\n                                    \n                    except Exception as e:\n                        continue\n                        \n        return questions[:20]  # Limit to 20 questions max\n        \n    except Exception as e:\n        logging.error(f\"Text extraction error: {e}\")\n        return []\n\ndef select_top_questions(candidate_questions, num_questions):\n    \"\"\"Select top N questions based on confidence and completeness\"\"\"\n    \n    # Sort by confidence (highest first) and completeness\n    def question_score(q):\n        confidence = q.get('confidence', 0.5)\n        option_count = len(q.get('options', []))\n        has_answer = q.get('correct_option_index', -1) >= 0\n        \n        return confidence + (option_count / 10) + (0.2 if has_answer else 0)\n    \n    sorted_questions = sorted(candidate_questions, key=question_score, reverse=True)\n    \n    return sorted_questions[:num_questions]\n\n# Enhanced Security Measures and Advanced Features\n\n@app.route('/api/quiz/<int:quiz_id>/publish', methods=['POST'])\n@login_required\ndef publish_quiz(quiz_id):\n    \"\"\"Publish a draft quiz after host review\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    data = request.json\n    lock_answers = data.get('lock_answers', True)\n    \n    # Activate the quiz\n    quiz.is_active = True\n    \n    # Lock answers if requested\n    if lock_answers:\n        for question in quiz.questions:\n            for option in question.options:\n                # Mark host-reviewed answers as final\n                pass  # Options are already set correctly\n    \n    db.session.commit()\n    \n    return jsonify({'success': True, 'message': 'Quiz published successfully'})\n\n@app.route('/api/quiz/<int:quiz_id>/delete', methods=['DELETE'])\n@login_required\ndef delete_quiz(quiz_id):\n    \"\"\"Delete quiz (soft delete by default)\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    hard_delete = request.args.get('hard', 'false').lower() == 'true'\n    \n    if hard_delete and current_user.is_admin():\n        # Hard delete - remove completely\n        # First remove related upload files\n        if quiz.draft_from_upload_id:\n            upload_record = UploadRecord.query.get(quiz.draft_from_upload_id)\n            if upload_record and upload_record.stored_path:\n                try:\n                    os.remove(upload_record.stored_path)\n                except:\n                    pass\n                db.session.delete(upload_record)\n        \n        db.session.delete(quiz)\n        message = 'Quiz permanently deleted'\n    else:\n        # Soft delete\n        quiz.is_deleted = True\n        message = 'Quiz moved to trash'\n    \n    db.session.commit()\n    \n    return jsonify({'success': True, 'message': message})\n\n@app.route('/api/quiz/<int:quiz_id>/restore', methods=['POST'])\n@login_required\ndef restore_quiz(quiz_id):\n    \"\"\"Restore a soft-deleted quiz\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    quiz.is_deleted = False\n    db.session.commit()\n    \n    return jsonify({'success': True, 'message': 'Quiz restored successfully'})\n\n@app.route('/host/participants-advanced')\n@login_required\ndef host_participants_advanced():\n    \"\"\"Enhanced participant management and login activity\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get participants who have taken host's quizzes\n    participants = db.session.query(User).join(QuizAttempt).join(Quiz).filter(\n        Quiz.creator_id == current_user.id if not current_user.is_admin() else True,\n        User.role == 'participant'\n    ).distinct().all()\n    \n    # Get detailed info for each participant\n    participant_data = []\n    for participant in participants:\n        # Get latest device log\n        latest_device_log = DeviceLog.query.filter_by(user_id=participant.id).order_by(\n            DeviceLog.logged_in_at.desc()\n        ).first()\n        \n        # Get quiz attempts\n        attempts = QuizAttempt.query.join(Quiz).filter(\n            QuizAttempt.participant_id == participant.id,\n            Quiz.creator_id == current_user.id if not current_user.is_admin() else True\n        ).all()\n        \n        # Get violation count\n        violation_count = 0\n        for attempt in attempts:\n            violation_count += ProctoringEvent.query.filter_by(attempt_id=attempt.id).count()\n        \n        participant_data.append({\n            'user': participant,\n            'latest_device': latest_device_log,\n            'attempts': attempts,\n            'violation_count': violation_count,\n            'status': 'online' if latest_device_log and \n                     (datetime.utcnow() - latest_device_log.logged_in_at).seconds < 300 else 'offline'\n        })\n    \n    return render_template('host_participants.html', participant_data=participant_data)\n\n@app.route('/api/participant/<int:participant_id>/security-report')\n@login_required\ndef participant_security_report(participant_id):\n    \"\"\"Generate detailed security report for a participant\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    participant = User.query.get_or_404(participant_id)\n    \n    # Get all attempts by this participant for current host's quizzes\n    attempts = QuizAttempt.query.join(Quiz).filter(\n        QuizAttempt.participant_id == participant_id,\n        Quiz.creator_id == current_user.id if not current_user.is_admin() else True\n    ).all()\n    \n    # Compile security data\n    security_data = {\n        'participant': {\n            'username': participant.username,\n            'email': participant.email,\n            'total_attempts': len(attempts)\n        },\n        'violations': [],\n        'device_logs': [],\n        'flagged_attempts': [],\n        'suspicious_patterns': []\n    }\n    \n    # Get violations\n    for attempt in attempts:\n        violations = ProctoringEvent.query.filter_by(attempt_id=attempt.id).all()\n        for violation in violations:\n            security_data['violations'].append({\n                'quiz_title': attempt.quiz.title,\n                'event_type': violation.event_type,\n                'severity': violation.severity,\n                'timestamp': violation.timestamp.isoformat(),\n                'details': violation.details\n            })\n    \n    # Get device logs\n    device_logs = DeviceLog.query.filter_by(user_id=participant_id).order_by(\n        DeviceLog.logged_in_at.desc()\n    ).limit(20).all()\n    \n    for log in device_logs:\n        security_data['device_logs'].append({\n            'ip_address': log.ip_address,\n            'device_type': log.device_type,\n            'browser_info': log.browser_info,\n            'timestamp': log.logged_in_at.isoformat(),\n            'is_suspicious': log.is_suspicious\n        })\n    \n    # Detect suspicious patterns\n    ip_addresses = set(log.ip_address for log in device_logs)\n    if len(ip_addresses) > 3:\n        security_data['suspicious_patterns'].append('Multiple IP addresses detected')\n    \n    user_agents = set(log.user_agent for log in device_logs if log.user_agent)\n    if len(user_agents) > 2:\n        security_data['suspicious_patterns'].append('Multiple devices/browsers detected')\n    \n    # Flagged attempts\n    flagged_attempts = [a for a in attempts if a.violation_count > 2]\n    for attempt in flagged_attempts:\n        security_data['flagged_attempts'].append({\n            'quiz_title': attempt.quiz.title,\n            'started_at': attempt.started_at.isoformat(),\n            'violation_count': attempt.violation_count,\n            'status': attempt.status\n        })\n    \n    return jsonify(security_data)\n\n@app.route('/api/monitoring/send-warning/<int:attempt_id>', methods=['POST'])\n@login_required\ndef send_warning_to_participant(attempt_id):\n    \"\"\"Send real-time warning to participant\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    if attempt.quiz.creator_id != current_user.id and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    data = request.json\n    warning_message = data.get('message', 'Please follow the quiz guidelines and avoid suspicious activities.')\n    \n    # Create security alert\n    alert = SecurityAlert(\n        user_id=attempt.participant_id,\n        quiz_id=attempt.quiz_id,\n        attempt_id=attempt_id,\n        alert_type='host_warning',\n        severity='medium',\n        description=warning_message,\n        auto_action_taken='warning_sent'\n    )\n    db.session.add(alert)\n    db.session.commit()\n    \n    # In a real WebSocket implementation, this would send the message via WebSocket\n    # For now, we'll store it as a security alert that can be displayed to the participant\n    \n    return jsonify({'success': True, 'message': 'Warning sent successfully'})\n\n@app.route('/api/monitoring/auto-terminate/<int:attempt_id>', methods=['POST'])\n@login_required\ndef auto_terminate_quiz(attempt_id):\n    \"\"\"Automatically terminate quiz due to violations\"\"\"\n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    # Check if auto-termination is enabled for this quiz\n    if not attempt.quiz.auto_terminate_on_violation:\n        return jsonify({'error': 'Auto-termination not enabled for this quiz'}), 400\n    \n    data = request.json\n    reason = data.get('reason', 'Multiple proctoring violations detected')\n    \n    # Terminate the quiz\n    attempt.status = 'terminated'\n    attempt.completed_at = datetime.utcnow()\n    attempt.termination_reason = reason\n    attempt.is_flagged = True\n    \n    # Create security alert\n    alert = SecurityAlert(\n        user_id=attempt.participant_id,\n        quiz_id=attempt.quiz_id,\n        attempt_id=attempt_id,\n        alert_type='auto_termination',\n        severity='high',\n        description=f'Quiz automatically terminated: {reason}',\n        auto_action_taken='quiz_terminated'\n    )\n    db.session.add(alert)\n    db.session.commit()\n    \n    return jsonify({'success': True, 'message': 'Quiz terminated due to violations'})\n\n@app.route('/api/device-log', methods=['POST'])\n@login_required\ndef log_device_info():\n    \"\"\"Log participant device information for security tracking\"\"\"\n    data = request.json\n    \n    # Detect suspicious behavior\n    is_suspicious = False\n    \n    # Check for suspicious user agents\n    suspicious_keywords = ['headless', 'phantom', 'selenium', 'webdriver', 'automation']\n    user_agent = data.get('userAgent', '').lower()\n    if any(keyword in user_agent for keyword in suspicious_keywords):\n        is_suspicious = True\n    \n    # Check for unusual screen resolutions\n    screen_resolution = data.get('screenResolution', '')\n    if screen_resolution:\n        try:\n            width, height = map(int, screen_resolution.split('x'))\n            if width < 800 or height < 600:  # Unusually small screens\n                is_suspicious = True\n        except:\n            pass\n    \n    # Get IP address\n    ip_address = request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr)\n    \n    device_log = DeviceLog(\n        user_id=current_user.id,\n        quiz_id=data.get('quizId'),\n        ip_address=ip_address,\n        user_agent=data.get('userAgent'),\n        device_type=data.get('deviceType'),\n        browser_info=data.get('browserInfo'),\n        screen_resolution=screen_resolution,\n        timezone=data.get('timezone'),\n        is_suspicious=is_suspicious\n    )\n    \n    db.session.add(device_log)\n    db.session.commit()\n    \n    return jsonify({'success': True, 'logged': True, 'suspicious': is_suspicious})\n\n# Database Export for Admin\n@app.route('/admin/export-database-sqlite')\n@login_required\ndef export_database_sqlite():\n    \"\"\"Export database as SQLite file for admin\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    try:\n        import sqlite3\n        import tempfile\n        \n        # Create temporary SQLite database\n        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')\n        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=f'_quizzes_{timestamp}.db')\n        sqlite_path = temp_file.name\n        temp_file.close()\n        \n        # Connect to SQLite\n        sqlite_conn = sqlite3.connect(sqlite_path)\n        sqlite_cursor = sqlite_conn.cursor()\n        \n        # Export users\n        users = User.query.all()\n        sqlite_cursor.execute('''\n            CREATE TABLE users (\n                id INTEGER PRIMARY KEY,\n                username TEXT,\n                email TEXT,\n                role TEXT,\n                is_verified BOOLEAN,\n                created_at TEXT\n            )\n        ''')\n        \n        for user in users:\n            sqlite_cursor.execute('''\n                INSERT INTO users VALUES (?, ?, ?, ?, ?, ?)\n            ''', (user.id, user.username, user.email, user.role, user.is_verified, \n                  user.created_at.isoformat() if user.created_at else None))\n        \n        # Export quizzes\n        quizzes = Quiz.query.filter_by(is_deleted=False).all()\n        sqlite_cursor.execute('''\n            CREATE TABLE quizzes (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                creator_username TEXT,\n                time_limit INTEGER,\n                proctoring_enabled BOOLEAN,\n                created_at TEXT\n            )\n        ''')\n        \n        for quiz in quizzes:\n            sqlite_cursor.execute('''\n                INSERT INTO quizzes VALUES (?, ?, ?, ?, ?, ?)\n            ''', (quiz.id, quiz.title, quiz.creator.username, quiz.time_limit, \n                  quiz.proctoring_enabled, quiz.created_at.isoformat()))\n        \n        # Export quiz attempts\n        attempts = QuizAttempt.query.all()\n        sqlite_cursor.execute('''\n            CREATE TABLE quiz_attempts (\n                id INTEGER PRIMARY KEY,\n                participant_username TEXT,\n                quiz_title TEXT,\n                score REAL,\n                status TEXT,\n                started_at TEXT,\n                completed_at TEXT,\n                violation_count INTEGER\n            )\n        ''')\n        \n        for attempt in attempts:\n            sqlite_cursor.execute('''\n                INSERT INTO quiz_attempts VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (attempt.id, attempt.participant.username, attempt.quiz.title,\n                  attempt.score, attempt.status, attempt.started_at.isoformat(),\n                  attempt.completed_at.isoformat() if attempt.completed_at else None,\n                  attempt.violation_count))\n        \n        sqlite_conn.commit()\n        sqlite_conn.close()\n        \n        # Return file for download\n        return send_file(\n            sqlite_path,\n            mimetype='application/x-sqlite3',\n            as_attachment=True,\n            download_name=f'quizzes_{timestamp}.db'\n        )\n        \n    except Exception as e:\n        logging.error(f\"Database export error: {e}\")\n        flash('Database export failed.', 'error')\n        return redirect(url_for('admin_dashboard'))\n\n@app.route('/admin/users')\n@login_required\ndef admin_users():\n    \"\"\"Manage all users\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    users = User.query.order_by(User.created_at.desc()).all()\n    courses = Course.query.filter_by(is_active=True).order_by(Course.code).all()\n    return render_template('admin_users.html', users=users, courses=courses)\n\n@app.route('/admin/user/<int:user_id>/toggle-status', methods=['POST'])\n@login_required\ndef admin_toggle_user_status(user_id):\n    \"\"\"Toggle user active/inactive status\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user = User.query.get_or_404(user_id)\n    \n    # Don't allow disabling yourself\n    if user.id == current_user.id:\n        flash('You cannot disable your own account.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    user.is_active = not user.is_active\n    db.session.commit()\n    \n    status = 'activated' if user.is_active else 'deactivated'\n    flash(f'User {user.username} has been {status}.', 'success')\n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/user/<int:user_id>/change-role', methods=['POST'])\n@login_required\ndef admin_change_user_role(user_id):\n    \"\"\"Change user role\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user = User.query.get_or_404(user_id)\n    new_role = request.form.get('role')\n    \n    if new_role not in ['admin', 'host', 'participant']:\n        flash('Invalid role specified.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Don't allow changing your own role\n    if user.id == current_user.id:\n        flash('You cannot change your own role.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    old_role = user.role\n    user.role = new_role\n    db.session.commit()\n    \n    flash(f'User {user.username} role changed from {old_role} to {new_role}.', 'success')\n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/user/<int:user_id>/delete', methods=['POST'])\n@login_required\ndef admin_delete_user(user_id):\n    \"\"\"Delete a user (admin only)\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user = User.query.get_or_404(user_id)\n    \n    # Don't allow deleting yourself\n    if user.id == current_user.id:\n        flash('You cannot delete your own account.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    try:\n        # Delete related data in proper order\n        # 1. Delete answers and proctoring events for this user's attempts\n        user_attempts = QuizAttempt.query.filter_by(participant_id=user.id).all()\n        for attempt in user_attempts:\n            Answer.query.filter_by(attempt_id=attempt.id).delete()\n            ProctoringEvent.query.filter_by(attempt_id=attempt.id).delete()\n        \n        # 2. Delete quiz attempts\n        QuizAttempt.query.filter_by(participant_id=user.id).delete()\n        \n        # 3. Handle quizzes created by this user\n        user_quizzes = Quiz.query.filter_by(creator_id=user.id).all()\n        for quiz in user_quizzes:\n            # Delete all attempts for these quizzes first\n            quiz_attempts = QuizAttempt.query.filter_by(quiz_id=quiz.id).all()\n            for attempt in quiz_attempts:\n                Answer.query.filter_by(attempt_id=attempt.id).delete()\n                ProctoringEvent.query.filter_by(attempt_id=attempt.id).delete()\n            QuizAttempt.query.filter_by(quiz_id=quiz.id).delete()\n            \n            # Delete questions and options\n            for question in quiz.questions:\n                QuestionOption.query.filter_by(question_id=question.id).delete()\n            Question.query.filter_by(quiz_id=quiz.id).delete()\n            \n            # Delete the quiz\n            db.session.delete(quiz)\n        \n        # 4. Delete course enrollments and assignments\n        ParticipantEnrollment.query.filter_by(participant_id=user.id).delete()\n        HostCourseAssignment.query.filter_by(host_id=user.id).delete()\n        \n        # 5. Finally delete the user\n        username = user.username\n        db.session.delete(user)\n        db.session.commit()\n        \n        flash(f'User {username} has been permanently deleted.', 'success')\n    except Exception as e:\n        db.session.rollback()\n        flash(f'Error deleting user: {str(e)}', 'error')\n    \n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/user/<int:user_id>/reset-password', methods=['POST'])\n@login_required\ndef admin_reset_password(user_id):\n    \"\"\"Reset user password\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user = User.query.get_or_404(user_id)\n    new_password = request.form.get('new_password')\n    \n    if not new_password or len(new_password) < 6:\n        flash('Password must be at least 6 characters long.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    user.set_password(new_password)\n    db.session.commit()\n    \n    flash(f'Password reset for user {user.username}.', 'success')\n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/bulk-delete-users', methods=['POST'])\n@login_required\ndef admin_bulk_delete_users():\n    \"\"\"Bulk delete multiple users\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user_ids = request.form.getlist('user_ids')\n    \n    if not user_ids:\n        flash('No users selected for deletion.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Convert to integers and validate\n    try:\n        user_ids = [int(uid) for uid in user_ids]\n    except ValueError:\n        flash('Invalid user IDs provided.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Prevent deleting current user\n    if current_user.id in user_ids:\n        flash('You cannot delete your own account.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    deleted_count = 0\n    errors = []\n    \n    # Process users in very small batches to prevent worker timeouts\n    batch_size = 3  # Process only 3 users at a time for stability\n    for i in range(0, len(user_ids), batch_size):\n        batch_ids = user_ids[i:i + batch_size]\n        \n        try:\n            for user_id in batch_ids:\n                try:\n                    user = User.query.get(user_id)\n                    if not user:\n                        errors.append(f'User with ID {user_id} not found.')\n                        continue\n                    \n                    username = user.username\n                    \n                    # Delete related data with explicit session flushing and optimized operations\n                    # 1. Delete user's quiz attempts and related data first\n                    user_attempt_ids = db.session.query(QuizAttempt.id).filter_by(participant_id=user.id).all()\n                    if user_attempt_ids:\n                        attempt_ids = [aid[0] for aid in user_attempt_ids]\n                        # Delete in smaller chunks to avoid timeout\n                        chunk_size = 50\n                        for i in range(0, len(attempt_ids), chunk_size):\n                            chunk = attempt_ids[i:i + chunk_size]\n                            Answer.query.filter(Answer.attempt_id.in_(chunk)).delete(synchronize_session=False)\n                            ProctoringEvent.query.filter(ProctoringEvent.attempt_id.in_(chunk)).delete(synchronize_session=False)\n                        \n                    QuizAttempt.query.filter_by(participant_id=user.id).delete(synchronize_session=False)\n                    db.session.flush()  # Explicit flush to ensure data consistency\n                    \n                    # 2. Delete user's login events and violations (simplified)\n                    LoginEvent.query.filter_by(user_id=user.id).delete(synchronize_session=False)\n                    UserViolation.query.filter_by(user_id=user.id).delete(synchronize_session=False)\n                    db.session.flush()\n                    \n                    # 3. Delete course enrollments and assignments\n                    ParticipantEnrollment.query.filter_by(participant_id=user.id).delete(synchronize_session=False)\n                    HostCourseAssignment.query.filter_by(host_id=user.id).delete(synchronize_session=False)\n                    db.session.flush()\n                    \n                    # 4. Delete user-created quizzes (only for hosts, simplified)\n                    if user.role == 'host':\n                        # Get quiz IDs first\n                        user_quiz_ids = db.session.query(Quiz.id).filter_by(creator_id=user.id).all()\n                        if user_quiz_ids:\n                            quiz_ids = [qid[0] for qid in user_quiz_ids]\n                            \n                            # Delete quiz attempts for these quizzes\n                            quiz_attempt_ids = db.session.query(QuizAttempt.id).filter(QuizAttempt.quiz_id.in_(quiz_ids)).all()\n                            if quiz_attempt_ids:\n                                quiz_attempt_ids = [qaid[0] for qaid in quiz_attempt_ids]\n                                Answer.query.filter(Answer.attempt_id.in_(quiz_attempt_ids)).delete(synchronize_session=False)\n                                ProctoringEvent.query.filter(ProctoringEvent.attempt_id.in_(quiz_attempt_ids)).delete(synchronize_session=False)\n                            \n                            QuizAttempt.query.filter(QuizAttempt.quiz_id.in_(quiz_ids)).delete(synchronize_session=False)\n                            \n                            # Delete questions and options  \n                            question_ids = db.session.query(Question.id).filter(Question.quiz_id.in_(quiz_ids)).all()\n                            if question_ids:\n                                question_ids = [qid[0] for qid in question_ids]\n                                QuestionOption.query.filter(QuestionOption.question_id.in_(question_ids)).delete(synchronize_session=False)\n                            \n                            Question.query.filter(Question.quiz_id.in_(quiz_ids)).delete(synchronize_session=False)\n                            Quiz.query.filter(Quiz.id.in_(quiz_ids)).delete(synchronize_session=False)\n                            db.session.flush()\n                    \n                    # 5. Finally delete the user\n                    db.session.delete(user)\n                    deleted_count += 1\n                    \n                except Exception as user_error:\n                    errors.append(f'Error deleting user {username if \"username\" in locals() else user_id}: {str(user_error)}')\n                    continue\n            \n            # Commit each batch with explicit transaction handling\n            db.session.commit()\n            \n            # Add small delay between batches to prevent overwhelming the database\n            import time\n            time.sleep(0.1)\n            \n        except Exception as e:\n            db.session.rollback()\n            errors.append(f'Error in batch starting at user {batch_ids[0]}: {str(e)}')\n            continue\n    \n    if deleted_count > 0:\n        flash(f'Successfully deleted {deleted_count} user(s).', 'success')\n    \n    if errors:\n        for error in errors:\n            flash(error, 'error')\n    \n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/quiz-attempts')\n@login_required\ndef admin_quiz_attempts():\n    \"\"\"Admin page to view all quiz attempts\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    page = request.args.get('page', 1, type=int)\n    quiz_id = request.args.get('quiz_id', type=int)\n    status = request.args.get('status', 'all')\n    \n    query = QuizAttempt.query.options(\n        joinedload(QuizAttempt.participant),\n        joinedload(QuizAttempt.quiz)\n    )\n    \n    if quiz_id:\n        query = query.filter(QuizAttempt.quiz_id == quiz_id)\n    \n    if status != 'all':\n        query = query.filter(QuizAttempt.status == status)\n    \n    attempts = query.order_by(\n        QuizAttempt.started_at.desc()\n    ).paginate(\n        page=page, per_page=20, error_out=False\n    )\n    \n    # Get available quizzes for filtering\n    quizzes = Quiz.query.order_by(Quiz.title).all()\n    \n    return render_template('admin_quiz_attempts.html',\n                         attempts=attempts,\n                         quizzes=quizzes,\n                         current_quiz_id=quiz_id,\n                         current_status=status)\n\n@app.route('/admin/hosts')\n@login_required\ndef admin_hosts():\n    \"\"\"Admin page to view all host accounts\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    page = request.args.get('page', 1, type=int)\n    status = request.args.get('status', 'all')\n    search = request.args.get('search', '').strip()\n    \n    query = User.query.filter_by(role='host')\n    \n    if status == 'active':\n        query = query.filter_by(is_active=True)\n    elif status == 'inactive':\n        query = query.filter_by(is_active=False)\n    \n    if search:\n        query = query.filter(\n            (User.username.ilike(f'%{search}%')) |\n            (User.email.ilike(f'%{search}%'))\n        )\n    \n    hosts = query.order_by(User.created_at.desc()).paginate(\n        page=page, per_page=20, error_out=False\n    )\n    \n    # Get host statistics\n    host_stats = {}\n    for host in hosts.items:\n        quiz_count = Quiz.query.filter_by(creator_id=host.id).count()\n        recent_login = LoginEvent.query.filter_by(user_id=host.id).order_by(LoginEvent.login_time.desc()).first()\n        host_stats[host.id] = {\n            'quiz_count': quiz_count,\n            'last_login': recent_login.login_time if recent_login else None\n        }\n    \n    return render_template('admin_hosts.html',\n                         hosts=hosts,\n                         host_stats=host_stats,\n                         current_status=status,\n                         search_query=search)\n\n# Alert Threshold Management Routes\n@app.route('/admin/alert-thresholds')\n@login_required\ndef admin_alert_thresholds():\n    \"\"\"Admin page to manage alert thresholds\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    page = request.args.get('page', 1, type=int)\n    search = request.args.get('search', '').strip()\n    event_type = request.args.get('event_type', 'all')\n    \n    query = AlertThreshold.query.filter_by(is_active=True)\n    \n    if search:\n        query = query.filter(\n            (AlertThreshold.name.ilike(f'%{search}%')) |\n            (AlertThreshold.event_type.ilike(f'%{search}%'))\n        )\n    \n    if event_type != 'all':\n        query = query.filter(AlertThreshold.event_type == event_type)\n    \n    thresholds = query.order_by(AlertThreshold.created_at.desc()).paginate(\n        page=page, per_page=15, error_out=False\n    )\n    \n    # Get distinct event types for filter dropdown\n    event_types = db.session.query(AlertThreshold.event_type).distinct().all()\n    event_types = [et[0] for et in event_types]\n    \n    return render_template('admin_alert_thresholds.html',\n                         thresholds=thresholds,\n                         event_types=event_types,\n                         current_event_type=event_type,\n                         search_query=search)\n\n@app.route('/admin/alert-threshold/create', methods=['GET', 'POST'])\n@login_required\ndef admin_create_alert_threshold():\n    \"\"\"Create new alert threshold\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    if request.method == 'POST':\n        name = request.form.get('name')\n        event_type = request.form.get('event_type')\n        low_threshold = request.form.get('low_threshold', type=int)\n        medium_threshold = request.form.get('medium_threshold', type=int)\n        high_threshold = request.form.get('high_threshold', type=int)\n        time_window = request.form.get('time_window', type=int)\n        \n        # Action settings\n        send_alert = request.form.get('send_alert') == 'on'\n        notify_proctor = request.form.get('notify_proctor') == 'on'\n        auto_flag_attempt = request.form.get('auto_flag_attempt') == 'on'\n        auto_terminate = request.form.get('auto_terminate') == 'on'\n        \n        # Validation\n        if not name or not event_type:\n            flash('Name and event type are required.', 'error')\n            return redirect(url_for('admin_create_alert_threshold'))\n        \n        if low_threshold < 1 or medium_threshold < 1 or high_threshold < 1:\n            flash('Thresholds must be at least 1.', 'error')\n            return redirect(url_for('admin_create_alert_threshold'))\n        \n        if time_window < 1:\n            flash('Time window must be at least 1 minute.', 'error')\n            return redirect(url_for('admin_create_alert_threshold'))\n        \n        # Check if threshold already exists for this event type\n        existing = AlertThreshold.query.filter_by(\n            event_type=event_type, \n            is_global=True, \n            is_active=True\n        ).first()\n        \n        if existing:\n            flash(f'A global threshold for {event_type} already exists. Please edit the existing one.', 'error')\n            return redirect(url_for('admin_alert_thresholds'))\n        \n        try:\n            threshold = AlertThreshold(\n                name=name,\n                event_type=event_type,\n                low_threshold=low_threshold,\n                medium_threshold=medium_threshold,\n                high_threshold=high_threshold,\n                time_window=time_window,\n                send_alert=send_alert,\n                notify_proctor=notify_proctor,\n                auto_flag_attempt=auto_flag_attempt,\n                auto_terminate=auto_terminate,\n                is_global=True,\n                created_by=current_user.id\n            )\n            \n            db.session.add(threshold)\n            db.session.commit()\n            \n            flash(f'Alert threshold \"{name}\" created successfully.', 'success')\n            return redirect(url_for('admin_alert_thresholds'))\n            \n        except Exception as e:\n            db.session.rollback()\n            flash(f'Error creating threshold: {str(e)}', 'error')\n            return redirect(url_for('admin_create_alert_threshold'))\n    \n    # Define available event types\n    event_types = [\n        'tab_switch', 'window_blur', 'multiple_faces', 'face_not_detected',\n        'mouse_leave', 'keyboard_shortcut', 'copy_paste', 'right_click',\n        'screen_share', 'suspicious_movement', 'audio_detected', 'browser_resize'\n    ]\n    \n    return render_template('admin_create_alert_threshold.html', event_types=event_types)\n\n@app.route('/admin/alert-threshold/<int:threshold_id>/edit', methods=['GET', 'POST'])\n@login_required\ndef admin_edit_alert_threshold(threshold_id):\n    \"\"\"Edit alert threshold\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    threshold = AlertThreshold.query.get_or_404(threshold_id)\n    \n    if request.method == 'POST':\n        threshold.name = request.form.get('name')\n        threshold.low_threshold = request.form.get('low_threshold', type=int)\n        threshold.medium_threshold = request.form.get('medium_threshold', type=int)\n        threshold.high_threshold = request.form.get('high_threshold', type=int)\n        threshold.time_window = request.form.get('time_window', type=int)\n        \n        # Action settings\n        threshold.send_alert = request.form.get('send_alert') == 'on'\n        threshold.notify_proctor = request.form.get('notify_proctor') == 'on'\n        threshold.auto_flag_attempt = request.form.get('auto_flag_attempt') == 'on'\n        threshold.auto_terminate = request.form.get('auto_terminate') == 'on'\n        \n        # Validation\n        if not threshold.name:\n            flash('Name is required.', 'error')\n            return redirect(url_for('admin_edit_alert_threshold', threshold_id=threshold_id))\n        \n        if threshold.low_threshold < 1 or threshold.medium_threshold < 1 or threshold.high_threshold < 1:\n            flash('Thresholds must be at least 1.', 'error')\n            return redirect(url_for('admin_edit_alert_threshold', threshold_id=threshold_id))\n        \n        if threshold.time_window < 1:\n            flash('Time window must be at least 1 minute.', 'error')\n            return redirect(url_for('admin_edit_alert_threshold', threshold_id=threshold_id))\n        \n        try:\n            threshold.updated_at = datetime.utcnow()\n            db.session.commit()\n            \n            flash(f'Alert threshold \"{threshold.name}\" updated successfully.', 'success')\n            return redirect(url_for('admin_alert_thresholds'))\n            \n        except Exception as e:\n            db.session.rollback()\n            flash(f'Error updating threshold: {str(e)}', 'error')\n    \n    return render_template('admin_edit_alert_threshold.html', threshold=threshold)\n\n@app.route('/admin/alert-threshold/<int:threshold_id>/delete', methods=['POST'])\n@login_required\ndef admin_delete_alert_threshold(threshold_id):\n    \"\"\"Delete alert threshold\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    threshold = AlertThreshold.query.get_or_404(threshold_id)\n    \n    try:\n        # Soft delete by setting is_active to False\n        threshold.is_active = False\n        threshold.updated_at = datetime.utcnow()\n        db.session.commit()\n        \n        flash(f'Alert threshold \"{threshold.name}\" deleted successfully.', 'success')\n        \n    except Exception as e:\n        db.session.rollback()\n        flash(f'Error deleting threshold: {str(e)}', 'error')\n    \n    return redirect(url_for('admin_alert_thresholds'))\n\n@app.route('/admin/create-user', methods=['POST'])\n@login_required\ndef admin_create_user():\n    \"\"\"Create new user account\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    username = request.form.get('username')\n    email = request.form.get('email')\n    password = request.form.get('password')\n    role = request.form.get('role')\n    \n    # Validation\n    if not all([username, email, password, role]):\n        flash('All fields are required.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    if User.query.filter_by(email=email).first():\n        flash('Email already exists.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    if User.query.filter_by(username=username).first():\n        flash('Username already exists.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    if role not in ['admin', 'host', 'participant']:\n        flash('Invalid role.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Create user\n    user = User()\n    user.username = username\n    user.email = email\n    user.role = role\n    user.set_password(password)\n    user.is_verified = True  # Admin-created users are pre-verified\n    \n    db.session.add(user)\n    db.session.commit()\n    \n    flash(f'User {username} created successfully with role {role}.', 'success')\n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/bulk-create-users', methods=['POST'])\n@login_required\ndef admin_bulk_create_users():\n    \"\"\"Create multiple users at once\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    users_data = request.form.get('users_data', '').strip()\n    default_role = request.form.get('default_role', 'participant')\n    default_course = request.form.get('default_course', '').strip()\n    auto_create_courses = request.form.get('auto_create_courses') == 'on'\n    \n    if not users_data:\n        flash('Please provide user data.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Parse user data (format: username,email,password,role,courses per line)\n    lines = [line.strip() for line in users_data.split('\\n') if line.strip()]\n    created_count = 0\n    errors = []\n    \n    # Process users in small batches to prevent worker timeouts\n    batch_size = 5  # Process 5 users at a time to prevent timeouts\n    total_lines = len(lines)\n    \n    for batch_start in range(0, total_lines, batch_size):\n        batch_end = min(batch_start + batch_size, total_lines)\n        batch_lines = lines[batch_start:batch_end]\n        \n        try:\n            # Process current batch\n            for batch_index, line in enumerate(batch_lines):\n                i = batch_start + batch_index + 1  # Original line number\n                try:\n                    parts = [part.strip() for part in line.split(',')]\n                    if len(parts) < 2:\n                        errors.append(f\"Line {i}: Invalid format. Expected: username,email,password,role,courses\")\n                        continue\n                    \n                    username = parts[0]\n                    email = parts[1]\n                    password = parts[2] if len(parts) >= 3 and parts[2] else f\"BigBoss{__import__('random').randrange(1000, 9999)}\"\n                    role = parts[3] if len(parts) >= 4 and parts[3] else default_role\n                    courses_str = parts[4] if len(parts) >= 5 else ''\n                    \n                    # Validation\n                    if not username or not email:\n                        errors.append(f\"Line {i}: Username and email are required\")\n                        continue\n                    \n                    if User.query.filter_by(email=email).first():\n                        errors.append(f\"Line {i}: Email {email} already exists\")\n                        continue\n                    \n                    if User.query.filter_by(username=username).first():\n                        errors.append(f\"Line {i}: Username {username} already exists\")\n                        continue\n                    \n                    if role not in ['admin', 'host', 'participant']:\n                        errors.append(f\"Line {i}: Invalid role {role}\")\n                        continue\n                    \n                    # Create user\n                    user = User()\n                    user.username = username\n                    user.email = email\n                    user.role = role\n                    user.set_password(password)\n                    user.is_verified = True\n                    \n                    db.session.add(user)\n                    db.session.flush()  # Get user ID before processing courses\n                    \n                    # Process course assignments efficiently\n                    course_codes = []\n                    if courses_str.strip():\n                        # Use courses from CSV line\n                        course_codes = [code.strip().upper() for code in courses_str.split(';') if code.strip()]\n                    elif default_course:\n                        # Use default course  \n                        course_codes = [default_course.upper()]\n                    \n                    # Assign user to courses\n                    for course_code in course_codes:\n                        try:\n                            course = Course.query.filter_by(code=course_code).first()\n                            \n                            # Auto-create course if it doesn't exist and auto-create is enabled\n                            if not course and auto_create_courses:\n                                course = Course()\n                                course.name = course_code  # Use code as name\n                                course.code = course_code\n                                course.description = f\"Auto-created course for {course_code}\"\n                                course.max_participants = 100\n                                course.is_active = True\n                                db.session.add(course)\n                                db.session.flush()  # Get course ID\n                            \n                            if course:\n                                if role == 'participant':\n                                    # Check if already enrolled\n                                    existing_enrollment = ParticipantEnrollment.query.filter_by(\n                                        participant_id=user.id, course_id=course.id\n                                    ).first()\n                                    if not existing_enrollment:\n                                        enrollment = ParticipantEnrollment()\n                                        enrollment.participant_id = user.id\n                                        enrollment.course_id = course.id\n                                        enrollment.enrolled_by = current_user.id\n                                        db.session.add(enrollment)\n                                \n                                elif role == 'host':\n                                    # Check if already assigned\n                                    existing_assignment = HostCourseAssignment.query.filter_by(\n                                        host_id=user.id, course_id=course.id\n                                    ).first()\n                                    if not existing_assignment:\n                                        assignment = HostCourseAssignment()\n                                        assignment.host_id = user.id\n                                        assignment.course_id = course.id\n                                        assignment.assigned_by = current_user.id\n                                        db.session.add(assignment)\n                            else:\n                                errors.append(f\"Line {i}: Course '{course_code}' not found\")\n                        \n                        except Exception as course_error:\n                            errors.append(f\"Line {i}: Error assigning course '{course_code}': {str(course_error)}\")\n                    \n                    created_count += 1\n                    \n                except Exception as e:\n                    errors.append(f\"Line {i}: Error processing - {str(e)}\")\n            \n            # Commit each batch to prevent timeouts\n            try:\n                db.session.commit()\n                \n                # Add small delay between batches to prevent overwhelming the database\n                if batch_end < total_lines:  # Not the last batch\n                    import time\n                    time.sleep(0.1)\n                    \n            except Exception as batch_error:\n                db.session.rollback()\n                errors.append(f\"Batch {batch_start//batch_size + 1}: Database error - {str(batch_error)}\")\n                \n        except Exception as batch_exception:\n            db.session.rollback()\n            errors.append(f\"Batch {batch_start//batch_size + 1}: Processing error - {str(batch_exception)}\")\n    \n    # Final status messages\n    if created_count > 0:\n        flash(f'Successfully created {created_count} users.', 'success')\n    if errors:\n        flash(f'Errors encountered: {\"; \".join(errors[:5])}{\"...\" if len(errors) > 5 else \"\"}', 'warning')\n    \n    return redirect(url_for('admin_users'))\n\n\n@app.route('/admin/upload-users-excel', methods=['POST'])\n@login_required\ndef admin_upload_users_excel():\n    \"\"\"Upload users from Excel file\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    if 'excel_file' not in request.files:\n        flash('No file selected.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    file = request.files['excel_file']\n    if file.filename == '':\n        flash('No file selected.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    if not file.filename.lower().endswith(('.xlsx', '.xls')):\n        flash('Please upload an Excel file (.xlsx or .xls).', 'error')\n        return redirect(url_for('admin_users'))\n    \n    try:\n        # Read Excel file\n        import pandas as pd\n        df = pd.read_excel(file)\n        \n        # Expected columns: username, email, password (optional), role (optional)\n        required_columns = ['username', 'email']\n        if not all(col in df.columns for col in required_columns):\n            flash(f'Excel file must contain columns: {\", \".join(required_columns)}. Optional: password, role', 'error')\n            return redirect(url_for('admin_users'))\n        \n        created_count = 0\n        errors = []\n        \n        for index, row in df.iterrows():\n            try:\n                username = str(row['username']).strip()\n                email = str(row['email']).strip()\n                password = str(row.get('password', f'BigBoss{__import__(\"random\").randrange(1000, 9999)}')).strip()\n                role = str(row.get('role', 'participant')).strip().lower()\n                \n                # Validation\n                if not username or not email or username == 'nan' or email == 'nan':\n                    errors.append(f\"Row {index + 2}: Username and email are required\")\n                    continue\n                \n                if User.query.filter_by(email=email).first():\n                    errors.append(f\"Row {index + 2}: Email {email} already exists\")\n                    continue\n                \n                if User.query.filter_by(username=username).first():\n                    errors.append(f\"Row {index + 2}: Username {username} already exists\")\n                    continue\n                \n                if role not in ['admin', 'host', 'participant']:\n                    role = 'participant'  # Default to participant if invalid\n                \n                # Create user\n                user = User()\n                user.username = username\n                user.email = email\n                user.role = role\n                user.set_password(password)\n                user.is_verified = True\n                \n                db.session.add(user)\n                created_count += 1\n                \n            except Exception as e:\n                errors.append(f\"Row {index + 2}: Error - {str(e)}\")\n        \n        db.session.commit()\n        \n        if created_count > 0:\n            flash(f'Successfully created {created_count} users from Excel file.', 'success')\n        if errors:\n            flash(f'Errors: {\"; \".join(errors[:3])}{\"...\" if len(errors) > 3 else \"\"}', 'warning')\n            \n    except Exception as e:\n        flash(f'Error reading Excel file: {str(e)}', 'error')\n    \n    return redirect(url_for('admin_users'))\n\n@app.route('/host/participants')\n@login_required\ndef host_participants():\n    \"\"\"Course-based participant management for hosts\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get courses assigned to this host (or all courses if admin)\n    if current_user.is_admin():\n        assigned_courses = Course.query.filter_by(is_active=True).all()\n    else:\n        # Get courses where this user is assigned as host\n        host_assignments = HostCourseAssignment.query.filter_by(host_id=current_user.id).all()\n        assigned_courses = [assignment.course for assignment in host_assignments if assignment.course.is_active]\n    \n    # Get participants enrolled in these courses\n    course_participants = {}\n    all_attempts = []\n    \n    for course in assigned_courses:\n        # Get participants enrolled in this course\n        enrollments = ParticipantEnrollment.query.filter_by(course_id=course.id).all()\n        participants = [enrollment.participant for enrollment in enrollments]\n        \n        # Get quizzes for this course created by the current host (or all if admin)\n        if current_user.is_admin():\n            course_quizzes = Quiz.query.filter_by(course_id=course.id, is_active=True).all()\n        else:\n            course_quizzes = Quiz.query.filter_by(course_id=course.id, creator_id=current_user.id, is_active=True).all()\n        \n        # Get attempts for these quizzes\n        quiz_ids = [quiz.id for quiz in course_quizzes]\n        if quiz_ids:\n            course_attempts = QuizAttempt.query.filter(QuizAttempt.quiz_id.in_(quiz_ids)).order_by(QuizAttempt.started_at.desc()).all()\n            all_attempts.extend(course_attempts)\n        else:\n            course_attempts = []\n        \n        # Calculate participant statistics for this course\n        participant_stats = {}\n        for participant in participants:\n            participant_attempts = [attempt for attempt in course_attempts if attempt.participant_id == participant.id]\n            completed_attempts = [attempt for attempt in participant_attempts if attempt.status == 'completed']\n            avg_score = sum([attempt.score for attempt in completed_attempts if attempt.score]) / len(completed_attempts) if completed_attempts else 0\n            \n            # Get violation count\n            violation_count = 0\n            for attempt in participant_attempts:\n                violation_count += ProctoringEvent.query.filter_by(attempt_id=attempt.id).count()\n            \n            # Get recent login\n            recent_login = LoginEvent.query.filter_by(user_id=participant.id).order_by(LoginEvent.login_time.desc()).first()\n            \n            participant_stats[participant.id] = {\n                'total_attempts': len(participant_attempts),\n                'completed_attempts': len(completed_attempts),\n                'avg_score': avg_score,\n                'violation_count': violation_count,\n                'recent_login': recent_login,\n                'is_flagged': False  # Will be tracked via UserViolation model\n            }\n        \n        course_participants[course] = {\n            'participants': participants,\n            'quizzes': course_quizzes,\n            'attempts': course_attempts,\n            'stats': participant_stats\n        }\n    \n    return render_template('host_participants.html', \n                         course_participants=course_participants,\n                         assigned_courses=assigned_courses,\n                         attempts=all_attempts)\n\n@app.route('/host/participant/<int:participant_id>/manage', methods=['GET', 'POST'])\n@login_required\ndef manage_participant(participant_id):\n    \"\"\"Manage individual participant - credentials, performance, flags\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    participant = User.query.get_or_404(participant_id)\n    if participant.role != 'participant':\n        flash('Invalid participant.', 'error')\n        return redirect(url_for('host_participants'))\n    \n    if request.method == 'POST':\n        action = request.form.get('action')\n        \n        if action == 'update_credentials':\n            # Update participant credentials\n            new_username = request.form.get('username')\n            new_email = request.form.get('email')\n            new_password = request.form.get('password')\n            \n            if new_username:\n                participant.username = new_username\n            if new_email:\n                participant.email = new_email\n            if new_password:\n                participant.set_password(new_password)\n            \n            db.session.commit()\n            flash('Participant credentials updated successfully.', 'success')\n            \n        elif action == 'flag_user':\n            # Flag user for violations\n            violation_record = UserViolation.query.filter_by(user_id=participant_id).first()\n            if not violation_record:\n                violation_record = UserViolation(user_id=participant_id)\n                db.session.add(violation_record)\n            \n            violation_record.is_flagged = True\n            violation_record.flagged_at = datetime.utcnow()\n            violation_record.flagged_by = current_user.id\n            violation_record.notes = request.form.get('notes', '')\n            \n            db.session.commit()\n            flash('Participant flagged for violations.', 'warning')\n            \n        elif action == 'unflag_user':\n            # Remove flag\n            violation_record = UserViolation.query.filter_by(user_id=participant_id).first()\n            if violation_record:\n                violation_record.is_flagged = False\n                violation_record.notes = request.form.get('notes', '')\n                db.session.commit()\n            flash('Participant flag removed.', 'success')\n            \n        return redirect(url_for('manage_participant', participant_id=participant_id))\n    \n    # Get participant data for display\n    attempts = QuizAttempt.query.filter_by(participant_id=participant_id).order_by(QuizAttempt.started_at.desc()).all()\n    login_events = LoginEvent.query.filter_by(user_id=participant_id).order_by(LoginEvent.login_time.desc()).limit(10).all()\n    \n    # Get violation data\n    violation_record = UserViolation.query.filter_by(user_id=participant_id).first()\n    total_violations = 0\n    for attempt in attempts:\n        total_violations += ProctoringEvent.query.filter_by(attempt_id=attempt.id).count()\n    \n    return render_template('manage_participant.html', \n                         participant=participant,\n                         attempts=attempts,\n                         login_events=login_events,\n                         violation_record=violation_record,\n                         total_violations=total_violations)\n\n@app.route('/host/participant/<int:participant_id>/violations')\n@login_required\ndef view_participant_violations(participant_id):\n    \"\"\"View detailed violation history for a participant\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    participant = User.query.get_or_404(participant_id)\n    attempts = QuizAttempt.query.filter_by(participant_id=participant_id).all()\n    \n    # Get all violations for this participant\n    violations = []\n    for attempt in attempts:\n        attempt_violations = ProctoringEvent.query.filter_by(attempt_id=attempt.id).order_by(ProctoringEvent.timestamp.desc()).all()\n        for violation in attempt_violations:\n            violations.append({\n                'violation': violation,\n                'attempt': attempt,\n                'quiz': attempt.quiz\n            })\n    \n    violations.sort(key=lambda x: x['violation'].timestamp, reverse=True)\n    \n    return render_template('participant_violations.html', \n                         participant=participant,\n                         violations=violations)\n\n@app.route('/host/login-activity')\n@login_required\ndef host_login_activity():\n    \"\"\"View login activity of all participants\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get recent login events for participants with proper eager loading\n    login_events = LoginEvent.query.options(\n        joinedload(LoginEvent.user)\n    ).join(User).filter(\n        User.role == 'participant'\n    ).order_by(LoginEvent.login_time.desc()).limit(50).all()\n    \n    return render_template('host_login_activity.html', login_events=login_events)\n\n\n@app.route('/host/live-monitoring')\n@login_required\ndef host_live_monitoring():\n    \"\"\"Live violation monitoring dashboard for hosts\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get all active quizzes by this host\n    active_quizzes = Quiz.query.filter_by(creator_id=current_user.id).all()\n    \n    # Get recent violations across all their quizzes\n    recent_violations = db.session.query(\n        ProctoringEvent, QuizAttempt, User, Quiz\n    ).join(\n        QuizAttempt, ProctoringEvent.attempt_id == QuizAttempt.id\n    ).join(\n        User, QuizAttempt.participant_id == User.id\n    ).join(\n        Quiz, QuizAttempt.quiz_id == Quiz.id\n    ).filter(\n        Quiz.creator_id == current_user.id\n    ).order_by(\n        ProctoringEvent.timestamp.desc()\n    ).limit(100).all()\n    \n    return render_template('live_monitoring.html', \n                         active_quizzes=active_quizzes,\n                         recent_violations=recent_violations)\n\n@app.route('/admin/manage-flags')\n@login_required\ndef admin_manage_flags():\n    \"\"\"Admin interface to manage user flags and retake permissions\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get all flagged users - specify which foreign key to use for join\n    flagged_users = db.session.query(UserViolation, User).join(\n        User, UserViolation.user_id == User.id\n    ).filter(\n        UserViolation.is_flagged == True\n    ).order_by(UserViolation.flagged_at.desc()).all()\n    \n    # Get recent violations\n    recent_violations = db.session.query(ProctoringEvent, QuizAttempt, User, Quiz).join(\n        QuizAttempt, ProctoringEvent.attempt_id == QuizAttempt.id\n    ).join(\n        User, QuizAttempt.participant_id == User.id\n    ).join(\n        Quiz, QuizAttempt.quiz_id == Quiz.id\n    ).filter(\n        ProctoringEvent.severity.in_(['high', 'critical'])\n    ).order_by(ProctoringEvent.timestamp.desc()).limit(20).all()\n    \n    return render_template('admin_manage_flags.html', \n                         flagged_users=flagged_users,\n                         recent_violations=recent_violations)\n\n@app.route('/admin/unflag-user/<int:user_id>', methods=['POST'])\n@login_required\ndef admin_unflag_user(user_id):\n    \"\"\"Admin action to unflag a user and grant retake permissions\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    violation_record = UserViolation.query.filter_by(user_id=user_id).first()\n    if not violation_record:\n        flash('User violation record not found.', 'error')\n        return redirect(url_for('admin_manage_flags'))\n    \n    user = User.query.get_or_404(user_id)\n    \n    # Remove flag\n    violation_record.is_flagged = False\n    violation_record.unflagged_at = datetime.utcnow()\n    violation_record.unflagged_by = current_user.id\n    violation_record.notes = request.form.get('notes', '')\n    \n    db.session.commit()\n    \n    flash(f'User {user.username} has been unflagged and granted retake permissions.', 'success')\n    return redirect(url_for('admin_manage_flags'))\n\n@app.route('/admin/flag-user/<int:user_id>', methods=['POST'])\n@login_required\ndef admin_flag_user(user_id):\n    \"\"\"Admin action to manually flag a user\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user = User.query.get_or_404(user_id)\n    \n    violation_record = UserViolation.query.filter_by(user_id=user_id).first()\n    if not violation_record:\n        violation_record = UserViolation(user_id=user_id)\n        db.session.add(violation_record)\n    \n    violation_record.is_flagged = True\n    violation_record.flagged_at = datetime.utcnow()\n    violation_record.flagged_by = current_user.id\n    violation_record.notes = request.form.get('notes', 'Manually flagged by administrator')\n    violation_record.violation_count = (violation_record.violation_count or 0) + 1\n    \n    db.session.commit()\n    \n    flash(f'User {user.username} has been flagged for violations.', 'warning')\n    return redirect(url_for('admin_manage_flags'))\n\n@app.route('/api/violations/<int:attempt_id>')\n@login_required\ndef get_violations(attempt_id):\n    \"\"\"Get violations for a quiz attempt\"\"\"\n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    # Check permissions\n    if not (current_user.is_admin() or \n            (current_user.is_host() and attempt.quiz.creator_id == current_user.id)):\n        return jsonify({'error': 'Access denied'}), 403\n    \n    violations = [{\n        'event_type': event.event_type,\n        'description': event.description,\n        'severity': event.severity,\n        'timestamp': event.timestamp.isoformat() if event.timestamp else None\n    } for event in attempt.proctoring_events]\n    \n    return jsonify({'violations': violations})\n\n@app.route('/api/proctoring/event', methods=['POST'])\n@login_required\ndef log_proctoring_event():\n    \"\"\"Log proctoring violation events\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data:\n            return jsonify({'error': 'No data provided'}), 400\n        \n        # Get current quiz attempt\n        attempt_id = data.get('attemptId')\n        if not attempt_id:\n            return jsonify({'error': 'Attempt ID required'}), 400\n        \n        attempt = QuizAttempt.query.get_or_404(attempt_id)\n        \n        # Verify user owns this attempt\n        if attempt.participant_id != current_user.id:\n            return jsonify({'error': 'Access denied'}), 403\n        \n        # Create proctoring event\n        event = ProctoringEvent(\n            attempt_id=attempt_id,\n            event_type=data.get('type', 'unknown'),\n            details=data.get('description', 'Unknown violation'),\n            severity=data.get('severity', 'medium'),\n            timestamp=datetime.utcnow()\n        )\n        \n        db.session.add(event)\n        \n        # Update highest risk summary for this attempt (performance optimization)\n        attempt.update_highest_risk(data.get('severity', 'medium'))\n        \n        # Enhanced violation tracking and termination logic\n        violation_count = ProctoringEvent.query.filter_by(attempt_id=attempt_id).count() + 1\n        high_severity_count = ProctoringEvent.query.filter_by(\n            attempt_id=attempt_id, \n            severity='high'\n        ).count()\n        \n        if data.get('severity') == 'high':\n            high_severity_count += 1\n        \n        # Immediate termination conditions\n        immediate_termination_types = ['quiz_terminated', 'console_access', 'multiple_instances', 'devtools_opened']\n        should_terminate = (\n            data.get('type') in immediate_termination_types or\n            violation_count >= 3 or\n            high_severity_count >= 2\n        )\n        \n        if should_terminate:\n            # Terminate the quiz attempt\n            attempt.status = 'terminated'\n            attempt.completed_at = datetime.utcnow()\n            \n            # Auto-flag the user for violations\n            violation_record = UserViolation.query.filter_by(user_id=current_user.id).first()\n            if not violation_record:\n                violation_record = UserViolation(user_id=current_user.id)\n                db.session.add(violation_record)\n            \n            violation_record.is_flagged = True\n            violation_record.flagged_at = datetime.utcnow()\n            violation_record.flagged_by = None  # System flagged\n            violation_record.notes = f\"Auto-flagged due to quiz termination: {data.get('type')} - {data.get('description')}\"\n            violation_record.violation_count = (violation_record.violation_count or 0) + 1\n            \n            # Save current answers before termination\n            db.session.commit()\n            \n            return jsonify({\n                'status': 'terminated',\n                'message': f'Quiz terminated due to security violation: {data.get(\"description\")}'\n            })\n        \n        db.session.commit()\n        \n        response_data = {'status': 'logged'}\n        \n        # Add warning if approaching limits\n        if violation_count >= 2:\n            response_data['warning'] = f'{3 - violation_count} violations remaining before termination'\n        \n        return jsonify(response_data)\n        \n    except Exception as e:\n        print(f\"Error logging proctoring event: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n\n@app.route('/api/proctoring/verify-identity', methods=['POST'])\n@login_required\ndef verify_identity():\n    \"\"\"API endpoint for face verification during quiz start\"\"\"\n    try:\n        data = request.json\n        image_data = data.get('image')\n        attempt_id = data.get('attemptId')\n        \n        if not image_data or not attempt_id:\n            return jsonify({'verified': False, 'error': 'Missing required data'})\n        \n        # Get the attempt to verify it belongs to current user\n        attempt = QuizAttempt.query.get(attempt_id)\n        if not attempt or attempt.participant_id != current_user.id:\n            return jsonify({'verified': False, 'error': 'Invalid attempt'})\n        \n        # Simple face verification logic - in production, you would use actual face recognition\n        # For now, we'll do basic image validation and always approve if image is provided\n        try:\n            # Basic validation - check if it's a valid base64 image\n            if image_data.startswith('data:image/'):\n                # Extract base64 part\n                base64_data = image_data.split(',')[1]\n                import base64\n                image_bytes = base64.b64decode(base64_data)\n                \n                # Basic check - image should be at least 1KB\n                if len(image_bytes) > 1024:\n                    # For demo purposes, always return verified=True\n                    # In production, implement actual face recognition here\n                    return jsonify({'verified': True, 'message': 'Identity verified successfully'})\n                else:\n                    return jsonify({'verified': False, 'error': 'Image too small or invalid'})\n            else:\n                return jsonify({'verified': False, 'error': 'Invalid image format'})\n                \n        except Exception as e:\n            return jsonify({'verified': False, 'error': f'Image processing failed: {str(e)}'})\n            \n    except Exception as e:\n        return jsonify({'verified': False, 'error': f'Verification failed: {str(e)}'})\n\n\n@app.route('/api/proctoring/notify-violation', methods=['POST'])\n@login_required\ndef notify_violation():\n    \"\"\"API endpoint for real-time violation notifications to hosts and admins\"\"\"\n    try:\n        data = request.json\n        \n        if not data:\n            return jsonify({'success': False, 'error': 'No data provided'})\n        \n        # Extract notification details\n        message = data.get('message', 'Unknown violation')\n        severity = data.get('severity', 'medium')\n        attempt_id = data.get('attemptId')\n        student_info = data.get('student', {})\n        \n        if not attempt_id:\n            return jsonify({'success': False, 'error': 'Attempt ID required'})\n        \n        # Get the quiz attempt and related quiz/host info\n        attempt = QuizAttempt.query.get(attempt_id)\n        if not attempt:\n            return jsonify({'success': False, 'error': 'Invalid attempt ID'})\n        \n        quiz = attempt.quiz\n        host = quiz.creator\n        \n        # Create violation notification record (for tracking)\n        violation_notification = ProctoringEvent(\n            attempt_id=attempt_id,\n            event_type='notification_sent',\n            details=f\"Real-time notification: {message}\",\n            severity=severity,\n            timestamp=datetime.utcnow()\n        )\n        db.session.add(violation_notification)\n        \n        # Send email notification to host if high severity\n        if severity == 'high':\n            try:\n                subject = f\"üö® URGENT: Quiz Violation Alert - {student_info.get('name', 'Student')}\"\n                body = f\"\"\"\n                URGENT VIOLATION ALERT\n                \n                Student: {student_info.get('name', 'Unknown')} ({student_info.get('email', 'N/A')})\n                Quiz: {quiz.title}\n                Violation: {message}\n                Severity: {severity.upper()}\n                Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n                \n                Please check the live monitoring dashboard immediately.\n                \n                Quiz URL: {request.url_root}host/live-monitoring\n                \"\"\"\n                \n                msg = Message(\n                    subject=subject,\n                    recipients=[host.email],\n                    body=body\n                )\n                \n                mail.send(msg)\n                \n            except Exception as email_error:\n                logging.error(f\"Failed to send violation email: {email_error}\")\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True, \n            'message': 'Violation notification processed successfully',\n            'notification_sent': True\n        })\n        \n    except Exception as e:\n        logging.error(f\"Error processing violation notification: {e}\")\n        return jsonify({'success': False, 'error': 'Internal server error'})\n\n# Helper function for heatmap data processing\ndef update_heatmap_data(quiz_id, question_id):\n    \"\"\"Update aggregated heatmap data for a question\"\"\"\n    try:\n        if not question_id:\n            return\n            \n        # Get or create heatmap data record\n        heatmap_data = QuestionHeatmapData.query.filter_by(\n            quiz_id=quiz_id, \n            question_id=question_id\n        ).first()\n        \n        if not heatmap_data:\n            heatmap_data = QuestionHeatmapData(\n                quiz_id=quiz_id,\n                question_id=question_id\n            )\n            db.session.add(heatmap_data)\n        \n        # Calculate aggregated metrics from interaction events\n        attempts = QuizAttempt.query.filter_by(quiz_id=quiz_id).all()\n        attempt_ids = [attempt.id for attempt in attempts]\n        \n        if attempt_ids:\n            # Get interaction events for this question\n            events = InteractionEvent.query.filter(\n                InteractionEvent.attempt_id.in_(attempt_ids),\n                InteractionEvent.question_id == question_id\n            ).all()\n            \n            # Calculate metrics\n            participants = set([event.attempt_id for event in events])\n            heatmap_data.total_participants = len(participants)\n            \n            # Calculate average time spent (from focus events)\n            focus_events = [e for e in events if e.event_type == 'focus' and e.duration]\n            if focus_events:\n                heatmap_data.average_time_spent = sum([e.duration for e in focus_events]) / len(focus_events)\n            \n            # Count interactions\n            heatmap_data.total_clicks = len([e for e in events if e.event_type == 'click'])\n            heatmap_data.total_hovers = len([e for e in events if e.event_type == 'hover'])\n            \n            # Calculate hotspots (coordinates where most interactions happen)\n            click_coords = [(e.x_coordinate, e.y_coordinate) for e in events \n                           if e.event_type == 'click' and e.x_coordinate and e.y_coordinate]\n            hover_coords = [(e.x_coordinate, e.y_coordinate) for e in events \n                           if e.event_type == 'hover' and e.x_coordinate and e.y_coordinate]\n            \n            heatmap_data.click_hotspots = json.dumps(click_coords[:100])  # Store top 100 coords\n            heatmap_data.hover_hotspots = json.dumps(hover_coords[:100])\n            \n            # Calculate engagement score based on interaction frequency\n            if heatmap_data.total_participants > 0:\n                total_interactions = heatmap_data.total_clicks + heatmap_data.total_hovers\n                heatmap_data.engagement_score = total_interactions / heatmap_data.total_participants\n            \n            heatmap_data.last_updated = datetime.utcnow()\n        \n        db.session.commit()\n        \n    except Exception as e:\n        logging.error(f\"Error updating heatmap data: {e}\")\n        db.session.rollback()\n\n# Real-time Collaboration Heatmap API Endpoints\n\n@app.route('/api/heatmap/interaction', methods=['POST'])\n@login_required\ndef log_interaction_event():\n    \"\"\"Log participant interaction events for heatmap generation\"\"\"\n    try:\n        data = request.json\n        \n        if not data:\n            return jsonify({'success': False, 'error': 'No data provided'})\n        \n        # Validate required fields\n        attempt_id = data.get('attemptId')\n        event_type = data.get('eventType')\n        \n        if not attempt_id or not event_type:\n            return jsonify({'success': False, 'error': 'attemptId and eventType are required'})\n        \n        # Verify attempt belongs to current user\n        attempt = QuizAttempt.query.get(attempt_id)\n        if not attempt or attempt.participant_id != current_user.id:\n            return jsonify({'success': False, 'error': 'Invalid attempt or access denied'})\n        \n        # Create interaction event\n        interaction = InteractionEvent(\n            attempt_id=attempt_id,\n            question_id=data.get('questionId'),\n            event_type=event_type,\n            element_selector=data.get('elementSelector'),\n            x_coordinate=data.get('x'),\n            y_coordinate=data.get('y'),\n            viewport_width=data.get('viewportWidth'),\n            viewport_height=data.get('viewportHeight'),\n            duration=data.get('duration'),\n            event_metadata=json.dumps(data.get('metadata', {})),\n            timestamp=datetime.utcnow()\n        )\n        \n        db.session.add(interaction)\n        db.session.commit()\n        \n        # Trigger real-time heatmap data update and analysis (async)\n        try:\n            update_heatmap_data(attempt.quiz_id, data.get('questionId'))\n            \n            # Trigger insights analysis periodically (every 10 interactions)\n            interaction_count = InteractionEvent.query.filter_by(attempt_id=attempt_id).count()\n            if interaction_count % 10 == 0:  # Analyze every 10 interactions\n                from heatmap_analysis import trigger_analysis_for_quiz\n                trigger_analysis_for_quiz(attempt.quiz_id)\n                \n        except Exception as e:\n            logging.warning(f\"Failed to update heatmap data or trigger analysis: {e}\")\n        \n        return jsonify({'success': True, 'logged': True})\n        \n    except Exception as e:\n        logging.error(f\"Error logging interaction event: {e}\")\n        return jsonify({'success': False, 'error': 'Internal server error'})\n\n@app.route('/api/heatmap/interaction/batch', methods=['POST'])\n@login_required\ndef log_interaction_events_batch():\n    \"\"\"Log multiple participant interaction events for heatmap generation\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data or 'interactions' not in data:\n            return jsonify({'success': False, 'error': 'Interactions data required'})\n        \n        interactions_data = data['interactions']\n        attempt_id = data.get('attemptId')\n        \n        if not attempt_id:\n            return jsonify({'success': False, 'error': 'Attempt ID required'})\n        \n        # Verify the attempt belongs to current user\n        attempt = QuizAttempt.query.filter_by(\n            id=attempt_id,\n            participant_id=current_user.id,\n            status='in_progress'\n        ).first()\n        \n        if not attempt:\n            return jsonify({'success': False, 'error': 'Invalid or inactive quiz attempt'})\n        \n        successful_logs = 0\n        failed_logs = 0\n        \n        # Process each interaction in the batch\n        for interaction_data in interactions_data:\n            try:\n                # Extract event details\n                event_type = interaction_data.get('type', 'unknown')\n                question_id = interaction_data.get('questionId')\n                x_coord = interaction_data.get('x')\n                y_coord = interaction_data.get('y')\n                timestamp_ms = interaction_data.get('timestamp', time.time() * 1000)\n                \n                # Create interaction event\n                interaction = InteractionEvent(\n                    attempt_id=attempt_id,\n                    event_type=event_type,\n                    question_id=question_id,\n                    x_coordinate=x_coord,\n                    y_coordinate=y_coord,\n                    timestamp=datetime.fromtimestamp(timestamp_ms / 1000),\n                    event_details=json.dumps({\n                        'target': interaction_data.get('target'),\n                        'scrollTop': interaction_data.get('scrollTop'),\n                        'scrollLeft': interaction_data.get('scrollLeft'),\n                        'visibility': interaction_data.get('visibility'),\n                        'timeSpent': interaction_data.get('timeSpent'),\n                        'answerValue': interaction_data.get('answerValue'),\n                        'answerType': interaction_data.get('answerType'),\n                        'textLength': interaction_data.get('textLength')\n                    })\n                )\n                \n                db.session.add(interaction)\n                successful_logs += 1\n                \n            except Exception as e:\n                logging.warning(f\"Failed to process individual interaction: {e}\")\n                failed_logs += 1\n                continue\n        \n        # Commit all successful interactions\n        if successful_logs > 0:\n            db.session.commit()\n            \n            # Trigger heatmap data update and analysis for significant batches\n            if successful_logs >= 5:  # Only for meaningful batches\n                try:\n                    update_heatmap_data(attempt.quiz_id, None)\n                    \n                    # Trigger insights analysis for larger batches\n                    if successful_logs >= 10:\n                        from heatmap_analysis import trigger_analysis_for_quiz\n                        trigger_analysis_for_quiz(attempt.quiz_id)\n                        \n                except Exception as e:\n                    logging.warning(f\"Failed to update heatmap data or trigger analysis: {e}\")\n        \n        return jsonify({\n            'success': True, \n            'processed': len(interactions_data),\n            'successful': successful_logs,\n            'failed': failed_logs\n        })\n        \n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error processing interaction batch: {e}\")\n        return jsonify({'success': False, 'error': 'Failed to process interaction batch'})\n\n@app.route('/api/heatmap/data/<int:quiz_id>')\n@login_required\ndef get_heatmap_data(quiz_id):\n    \"\"\"Get aggregated heatmap data for a quiz\"\"\"\n    try:\n        # Verify user has access to this quiz\n        quiz = Quiz.query.get_or_404(quiz_id)\n        \n        # Check if user is the host or admin\n        if not (current_user.is_admin() or quiz.creator_id == current_user.id):\n            return jsonify({'error': 'Access denied'}), 403\n        \n        # Get heatmap data for all questions in the quiz\n        heatmap_data = QuestionHeatmapData.query.filter_by(quiz_id=quiz_id).all()\n        \n        # Format response\n        questions_data = []\n        for data in heatmap_data:\n            question_info = {\n                'questionId': data.question_id,\n                'totalParticipants': data.total_participants,\n                'averageTimeSpent': data.average_time_spent,\n                'totalClicks': data.total_clicks,\n                'totalHovers': data.total_hovers,\n                'correctAnswerRate': data.correct_answer_rate,\n                'difficultyScore': data.difficulty_score,\n                'engagementScore': data.engagement_score,\n                'clickHotspots': json.loads(data.click_hotspots) if data.click_hotspots else [],\n                'hoverHotspots': json.loads(data.hover_hotspots) if data.hover_hotspots else [],\n                'scrollPatterns': json.loads(data.scroll_patterns) if data.scroll_patterns else {},\n                'lastUpdated': data.last_updated.isoformat()\n            }\n            questions_data.append(question_info)\n        \n        return jsonify({\n            'success': True,\n            'quizId': quiz_id,\n            'questionsData': questions_data,\n            'totalQuestions': len(questions_data),\n            'lastUpdated': max([data.last_updated for data in heatmap_data]).isoformat() if heatmap_data else None\n        })\n        \n    except Exception as e:\n        logging.error(f\"Error getting heatmap data: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n@app.route('/api/heatmap/insights/<int:quiz_id>')\n@login_required\ndef get_collaboration_insights(quiz_id):\n    \"\"\"Get collaboration insights for a quiz\"\"\"\n    try:\n        # Verify user has access to this quiz\n        quiz = Quiz.query.get_or_404(quiz_id)\n        \n        # Check if user is the host or admin\n        if not (current_user.is_admin() or quiz.creator_id == current_user.id):\n            return jsonify({'error': 'Access denied'}), 403\n        \n        # Get active insights for the quiz\n        insights = CollaborationInsight.query.filter_by(\n            quiz_id=quiz_id,\n            is_active=True\n        ).order_by(CollaborationInsight.created_at.desc()).all()\n        \n        # Format response\n        insights_data = []\n        for insight in insights:\n            insight_info = {\n                'id': insight.id,\n                'type': insight.insight_type,\n                'title': insight.title,\n                'description': insight.description,\n                'severity': insight.severity,\n                'affectedQuestions': json.loads(insight.affected_questions) if insight.affected_questions else [],\n                'metricValues': json.loads(insight.metric_values) if insight.metric_values else {},\n                'suggestedActions': json.loads(insight.suggested_actions) if insight.suggested_actions else [],\n                'isAcknowledged': insight.is_acknowledged,\n                'createdAt': insight.created_at.isoformat(),\n                'updatedAt': insight.updated_at.isoformat()\n            }\n            insights_data.append(insight_info)\n        \n        return jsonify({\n            'success': True,\n            'quizId': quiz_id,\n            'insights': insights_data,\n            'totalInsights': len(insights_data),\n            'criticalCount': len([i for i in insights if i.severity == 'critical']),\n            'highCount': len([i for i in insights if i.severity == 'high'])\n        })\n        \n    except Exception as e:\n        logging.error(f\"Error getting collaboration insights: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n@app.route('/api/heatmap/insights/<int:insight_id>/acknowledge', methods=['POST'])\n@login_required\ndef acknowledge_insight(insight_id):\n    \"\"\"Acknowledge a collaboration insight\"\"\"\n    try:\n        insight = CollaborationInsight.query.get_or_404(insight_id)\n        \n        # Verify user has access to this quiz\n        if not (current_user.is_admin() or insight.quiz.creator_id == current_user.id):\n            return jsonify({'error': 'Access denied'}), 403\n        \n        # Acknowledge the insight\n        insight.is_acknowledged = True\n        insight.acknowledged_by = current_user.id\n        insight.acknowledged_at = datetime.utcnow()\n        \n        db.session.commit()\n        \n        return jsonify({'success': True, 'acknowledged': True})\n        \n    except Exception as e:\n        logging.error(f\"Error acknowledging insight: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n\nimport os\nimport csv\nimport io\nimport logging\nimport tempfile\nimport mimetypes\nfrom werkzeug.utils import secure_filename\n\n@app.route('/quiz/create', methods=['GET', 'POST'])\n@login_required\ndef create_quiz():\n    \"\"\"Create a new quiz with optional file upload\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    form = QuizForm()\n    if form.validate_on_submit():\n        # Create the quiz\n        quiz = Quiz(\n            title=form.title.data,\n            description=form.description.data,\n            time_limit=form.time_limit.data,\n            proctoring_enabled=form.proctoring_enabled.data,\n            creator_id=current_user.id\n        )\n        \n        # Handle quick text paste if used (with fallback detection)\n        quick_text = request.form.get('quick_questions_text', '').strip()\n        if request.form.get('use_quick_questions') == 'true' or (quick_text and len(quick_text) > 20):\n            if quick_text:\n                try:\n                    # Use the same text parsing logic\n                    candidate_questions = extract_questions_from_text(quick_text)\n                    \n                    if not candidate_questions:\n                        flash('No questions found in the pasted text. Please check the format and try again.', 'warning')\n                        return render_template('create_quiz.html', form=form)\n                    \n                    db.session.add(quiz)\n                    db.session.commit()\n                    \n                    # Create questions from parsed data\n                    created_count = 0\n                    for q_data in candidate_questions:\n                        try:\n                            create_question_from_comprehensive_data(quiz, q_data)\n                            created_count += 1\n                        except Exception as e:\n                            logging.warning(f\"Failed to create question: {e}\")\n                            continue\n                    \n                    if created_count > 0:\n                        flash(f'Quiz created successfully from pasted text! {created_count} questions added.', 'success')\n                        return redirect(url_for('edit_quiz', quiz_id=quiz.id))\n                    else:\n                        flash('No valid questions could be created from the pasted text.', 'error')\n                        return render_template('create_quiz.html', form=form)\n                        \n                except Exception as e:\n                    flash(f'Error processing pasted text: {str(e)}', 'error')\n                    return render_template('create_quiz.html', form=form)\n        \n        # Handle file upload if selected\n        elif form.create_from_file.data and form.quiz_file.data:\n            file = form.quiz_file.data\n            if file and file.filename:\n                filename = secure_filename(file.filename)\n                \n                # Save file temporarily for parsing\n                temp_file_path = None\n                try:\n                    with tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(filename)[1]) as temp_file:\n                        file.save(temp_file.name)\n                        temp_file_path = temp_file.name\n                    \n                    # Get MIME type\n                    mime_type, _ = mimetypes.guess_type(filename)\n                    if not mime_type:\n                        # Fallback based on file extension\n                        ext = os.path.splitext(filename)[1].lower()\n                        mime_type_map = {\n                            '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n                            '.xls': 'application/vnd.ms-excel',  \n                            '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            '.pdf': 'application/pdf',\n                            '.csv': 'text/csv',\n                            '.txt': 'text/plain'\n                        }\n                        mime_type = mime_type_map.get(ext, 'text/plain')\n                    \n                    # Use comprehensive file parsing\n                    candidate_questions = parse_file_for_questions(temp_file_path, mime_type)\n                    \n                    if not candidate_questions:\n                        flash('No questions found in the uploaded file. Please check the format and try again.', 'warning')\n                        return render_template('create_quiz.html', form=form)\n                    \n                    db.session.add(quiz)\n                    db.session.commit()\n                    \n                    # Create questions from parsed data with better error handling\n                    created_count = 0\n                    for q_data in candidate_questions:\n                        try:\n                            create_question_from_comprehensive_data(quiz, q_data)\n                            created_count += 1\n                        except Exception as e:\n                            logging.warning(f\"Failed to create question: {e}\")\n                            continue\n                    \n                    if created_count > 0:\n                        flash(f'Quiz created successfully from file \"{filename}\"! {created_count} questions added.', 'success')\n                        return redirect(url_for('edit_quiz', quiz_id=quiz.id))\n                    else:\n                        flash('No valid questions could be created from the uploaded file.', 'error')\n                        return render_template('create_quiz.html', form=form)\n                        \n                except Exception as e:\n                    flash(f'Error parsing file: {str(e)}', 'error')\n                    return render_template('create_quiz.html', form=form)\n                    \n                finally:\n                    # Always clean up temporary file\n                    if temp_file_path and os.path.exists(temp_file_path):\n                        try:\n                            os.unlink(temp_file_path)\n                        except Exception as e:\n                            logging.warning(f\"Failed to clean up temp file {temp_file_path}: {e}\")\n        \n        db.session.add(quiz)\n        db.session.commit()\n        \n        flash('Quiz created successfully! Now add questions to your quiz.', 'success')\n        return redirect(url_for('edit_quiz', quiz_id=quiz.id))\n    \n    return render_template('create_quiz.html', form=form)\n\ndef parse_quiz_file(file):\n    \"\"\"Parse uploaded quiz file and return questions data\"\"\"\n    questions_data = []\n    content = file.read().decode('utf-8')\n    file.seek(0)  # Reset file pointer\n    \n    if file.filename.endswith('.csv'):\n        csv_reader = csv.reader(io.StringIO(content))\n        for row in csv_reader:\n            if len(row) >= 6:  # Question, Option1, Option2, Option3, Option4, CorrectAnswer\n                question_data = {\n                    'question_text': row[0].strip(),\n                    'options': [row[i].strip() for i in range(1, 5)],\n                    'correct_answer': int(row[5]) - 1 if row[5].isdigit() else 0,\n                    'points': int(row[6]) if len(row) > 6 and row[6].isdigit() else 1\n                }\n                questions_data.append(question_data)\n    else:  # TXT format\n        lines = content.split('\\n')\n        current_question = None\n        options = []\n        correct_answer = 0\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                if current_question and options:\n                    questions_data.append({\n                        'question_text': current_question,\n                        'options': options,\n                        'correct_answer': correct_answer,\n                        'points': 1\n                    })\n                    current_question = None\n                    options = []\n                    correct_answer = 0\n                continue\n                \n            if line.startswith('Q:') or line.startswith('Question:'):\n                current_question = line.split(':', 1)[1].strip()\n            elif line.startswith(('A)', 'B)', 'C)', 'D)')) or line.startswith(('1.', '2.', '3.', '4.')):\n                option_text = line[2:].strip() if line[1] in ').' else line[3:].strip()\n                if line.startswith('*') or '(correct)' in line.lower():\n                    correct_answer = len(options)\n                    option_text = option_text.replace('*', '').replace('(correct)', '').strip()\n                options.append(option_text)\n        \n        # Add last question if exists\n        if current_question and options:\n            questions_data.append({\n                'question_text': current_question,\n                'options': options,\n                'correct_answer': correct_answer,\n                'points': 1\n            })\n    \n    return questions_data\n\ndef create_question_from_comprehensive_data(quiz, question_data):\n    \"\"\"Create a question and its options from comprehensive parsed data\"\"\"\n    # Handle different data formats from comprehensive parser\n    question_text = question_data.get('question', question_data.get('question_text', ''))\n    question_type = question_data.get('type', 'multiple_choice')\n    \n    if not question_text:\n        raise ValueError(\"Question text is required\")\n    \n    question = Question(\n        quiz_id=quiz.id,\n        question_text=question_text,\n        question_type=question_type,\n        points=question_data.get('points', 1),\n        order=len(quiz.questions)\n    )\n    \n    db.session.add(question)\n    db.session.commit()\n    \n    # Create options for multiple choice questions\n    if question_type == 'multiple_choice':\n        options = question_data.get('options', [])\n        correct_index = question_data.get('correct_option_index', 0)\n        \n        if len(options) < 2:\n            raise ValueError(\"Multiple choice questions need at least 2 options\")\n        \n        for i, option_text in enumerate(options):\n            if option_text:  # Only add non-empty options\n                option = QuestionOption(\n                    question_id=question.id,\n                    option_text=option_text,\n                    is_correct=(i == correct_index),\n                    order=i\n                )\n                db.session.add(option)\n    \n    db.session.commit()\n    return question\n\ndef create_question_from_data(quiz, question_data):\n    \"\"\"Create a question and its options from parsed data (legacy format)\"\"\"\n    question = Question(\n        quiz_id=quiz.id,\n        question_text=question_data['question_text'],\n        question_type='multiple_choice',\n        points=question_data.get('points', 1),\n        order=len(quiz.questions)\n    )\n    \n    db.session.add(question)\n    db.session.commit()\n    \n    # Create options\n    for i, option_text in enumerate(question_data['options']):\n        option = QuestionOption(\n            question_id=question.id,\n            option_text=option_text,\n            is_correct=(i == question_data['correct_answer']),\n            order=i\n        )\n        db.session.add(option)\n    \n    db.session.commit()\n\n@app.route('/quiz/<int:quiz_id>/edit', methods=['GET', 'POST'])\n@login_required\ndef edit_quiz(quiz_id):\n    \"\"\"Edit quiz and manage questions\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        flash('Access denied. You can only edit your own quizzes.', 'error')\n        return redirect(url_for('host_dashboard'))\n    \n    form = QuizForm(obj=quiz)\n    question_form = QuestionForm()\n    \n    if form.validate_on_submit() and 'update_quiz' in request.form:\n        quiz.title = form.title.data\n        quiz.description = form.description.data\n        quiz.time_limit = form.time_limit.data\n        quiz.proctoring_enabled = form.proctoring_enabled.data\n        quiz.updated_at = datetime.utcnow()\n        \n        db.session.commit()\n        flash('Quiz updated successfully!', 'success')\n        return redirect(url_for('edit_quiz', quiz_id=quiz.id))\n    \n    return render_template('edit_quiz.html', quiz=quiz, form=form, question_form=question_form)\n\n@app.route('/question/<int:question_id>/edit', methods=['POST'])\n@login_required\ndef edit_question(question_id):\n    \"\"\"Edit a specific question\"\"\"\n    question = Question.query.get_or_404(question_id)\n    quiz = question.quiz\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('host_dashboard'))\n    \n    question.question_text = request.form.get('question_text')\n    question.question_type = request.form.get('question_type')\n    question.points = int(request.form.get('points', 1))\n    \n    # Update options for multiple choice questions\n    if question.question_type == 'multiple_choice':\n        # Remove old options\n        QuestionOption.query.filter_by(question_id=question.id).delete()\n        \n        # Add new options\n        for i in range(1, 5):  # Support up to 4 options\n            option_text = request.form.get(f'option_{i}')\n            if option_text:\n                is_correct = request.form.get('correct_option') == str(i)\n                option = QuestionOption(\n                    question_id=question.id,\n                    option_text=option_text,\n                    is_correct=is_correct\n                )\n                db.session.add(option)\n    \n    db.session.commit()\n    flash('Question updated successfully!', 'success')\n    return redirect(url_for('edit_quiz', quiz_id=quiz.id))\n\n@app.route('/question/<int:question_id>/delete', methods=['POST'])\n@login_required\ndef delete_question(question_id):\n    \"\"\"Delete a question\"\"\"\n    question = Question.query.get_or_404(question_id)\n    quiz = question.quiz\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('host_dashboard'))\n    \n    # Delete associated options first\n    QuestionOption.query.filter_by(question_id=question.id).delete()\n    # Delete the question\n    db.session.delete(question)\n    db.session.commit()\n    \n    flash('Question deleted successfully!', 'success')\n    return redirect(url_for('edit_quiz', quiz_id=quiz.id))\n\n@app.route('/quiz/<int:quiz_id>/add_question', methods=['POST'])\n@login_required\ndef add_question(quiz_id):\n    \"\"\"Add a question to quiz\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('host_dashboard'))\n    \n    question_text = request.form.get('question_text')\n    question_type = request.form.get('question_type', 'multiple_choice')\n    points = int(request.form.get('points', 1))\n    \n    if not question_text:\n        flash('Question text is required.', 'error')\n        return redirect(url_for('edit_quiz', quiz_id=quiz_id))\n    \n    question = Question(\n        quiz_id=quiz_id,\n        question_text=question_text,\n        question_type=question_type,\n        points=points,\n        order=len(quiz.questions)\n    )\n    \n    db.session.add(question)\n    db.session.commit()\n    \n    # Add options for multiple choice questions\n    if question_type == 'multiple_choice':\n        for i in range(4):  # Default 4 options\n            option_text = request.form.get(f'option_{i}')\n            is_correct = request.form.get(f'correct_{i}') == 'on'\n            \n            if option_text:\n                option = QuestionOption(\n                    question_id=question.id,\n                    option_text=option_text,\n                    is_correct=is_correct,\n                    order=i\n                )\n                db.session.add(option)\n    \n    elif question_type == 'true_false':\n        # Add True/False options\n        true_option = QuestionOption(\n            question_id=question.id,\n            option_text='True',\n            is_correct=request.form.get('correct_answer') == 'true',\n            order=0\n        )\n        false_option = QuestionOption(\n            question_id=question.id,\n            option_text='False',\n            is_correct=request.form.get('correct_answer') == 'false',\n            order=1\n        )\n        db.session.add(true_option)\n        db.session.add(false_option)\n    \n    db.session.commit()\n    flash('Question added successfully!', 'success')\n    return redirect(url_for('edit_quiz', quiz_id=quiz_id))\n\n@app.route('/quiz/<int:quiz_id>')\n@login_required\ndef view_quiz(quiz_id):\n    \"\"\"View quiz details\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    return render_template('quiz_list.html', quiz=quiz)\n\n@app.route('/quiz/<int:quiz_id>/take')\n@login_required\ndef take_quiz(quiz_id):\n    \"\"\"Take a quiz with enhanced security checks\"\"\"\n    if not current_user.is_participant():\n        flash('Access denied. Participant privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Check if user is flagged for violations - ADMIN ONLY RETAKE PERMISSIONS\n    violation_record = UserViolation.query.filter_by(user_id=current_user.id).first()\n    if violation_record and violation_record.is_flagged:\n        flash('‚ùå Access denied. Your account has been flagged for security violations. Contact an administrator for retake permissions.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if not quiz.is_active:\n        flash('This quiz is not currently active.', 'error')\n        return redirect(url_for('participant_dashboard'))\n    \n    # DEVICE DETECTION FOR MOBILE-SPECIFIC PROCTORING\n    user_agent = request.headers.get('User-Agent', '').lower()\n    mobile_keywords = ['mobile', 'android', 'iphone', 'ipod', 'blackberry', 'windows phone']\n    tablet_keywords = ['tablet', 'ipad']\n    \n    is_mobile = any(keyword in user_agent for keyword in mobile_keywords)\n    is_tablet = any(keyword in user_agent for keyword in tablet_keywords)\n    device_type = 'mobile' if is_mobile else ('tablet' if is_tablet else 'desktop')\n    \n    # Log device access for security monitoring\n    try:\n        event = ProctoringEvent(\n            attempt_id=None,\n            event_type=f'{device_type}_device_access',\n            details=f'Device access from {device_type}: {user_agent}',\n            severity='info',\n            timestamp=datetime.utcnow()\n        )\n        db.session.add(event)\n        db.session.commit()\n    except Exception as e:\n        logging.error(f\"Failed to log device access: {e}\")\n\n    # Check if user already has an active attempt\n    existing_attempt = QuizAttempt.query.filter_by(\n        participant_id=current_user.id,\n        quiz_id=quiz_id,\n        status='in_progress'\n    ).first()\n    \n    if existing_attempt:\n        return redirect(url_for('continue_quiz', attempt_id=existing_attempt.id))\n    \n    # Create new attempt\n    attempt = QuizAttempt(\n        participant_id=current_user.id,\n        quiz_id=quiz_id\n    )\n    \n    db.session.add(attempt)\n    db.session.commit()\n    \n    # Pass device type to the template\n    return redirect(url_for('continue_quiz', attempt_id=attempt.id))\n\n@app.route('/attempt/<int:attempt_id>')\n@login_required\ndef continue_quiz(attempt_id):\n    \"\"\"Continue taking a quiz\"\"\"\n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    if attempt.participant_id != current_user.id:\n        flash('Access denied.', 'error')\n        return redirect(url_for('participant_dashboard'))\n    \n    if attempt.status != 'in_progress':\n        flash('This quiz attempt has already been completed.', 'error')\n        return redirect(url_for('quiz_results', attempt_id=attempt_id))\n    \n    quiz = attempt.quiz\n    questions = quiz.questions\n    \n    # Get existing answers\n    existing_answers = {answer.question_id: answer for answer in attempt.answers}\n    \n    # Detect device type for mobile-specific proctoring\n    user_agent = request.headers.get('User-Agent', '').lower()\n    mobile_keywords = ['mobile', 'android', 'iphone', 'ipod', 'blackberry', 'windows phone']\n    tablet_keywords = ['tablet', 'ipad']\n    \n    is_mobile = any(keyword in user_agent for keyword in mobile_keywords)\n    is_tablet = any(keyword in user_agent for keyword in tablet_keywords)\n    device_type = 'mobile' if is_mobile else ('tablet' if is_tablet else 'desktop')\n    \n    return render_template('take_quiz.html', \n                         attempt=attempt, \n                         quiz=quiz, \n                         questions=questions,\n                         existing_answers=existing_answers,\n                         device_type=device_type)\n\n@app.route('/attempt/<int:attempt_id>/submit', methods=['POST'])\n@login_required\ndef submit_quiz(attempt_id):\n    \"\"\"Submit quiz answers\"\"\"\n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    if attempt.participant_id != current_user.id:\n        flash('Access denied.', 'error')\n        return redirect(url_for('participant_dashboard'))\n    \n    if attempt.status != 'in_progress':\n        flash('This quiz has already been submitted.', 'error')\n        return redirect(url_for('quiz_results', attempt_id=attempt_id))\n    \n    quiz = attempt.quiz\n    \n    # Process answers\n    for question in quiz.questions:\n        answer_key = f'question_{question.id}'\n        \n        # Check if answer already exists\n        existing_answer = Answer.query.filter_by(\n            attempt_id=attempt_id,\n            question_id=question.id\n        ).first()\n        \n        if existing_answer:\n            # Update existing answer\n            answer = existing_answer\n        else:\n            # Create new answer\n            answer = Answer(\n                attempt_id=attempt_id,\n                question_id=question.id\n            )\n        \n        if question.question_type == 'multiple_choice' or question.question_type == 'true_false':\n            selected_option_id = request.form.get(answer_key)\n            if selected_option_id:\n                answer.selected_option_id = int(selected_option_id)\n                selected_option = QuestionOption.query.get(selected_option_id)\n                answer.is_correct = selected_option.is_correct if selected_option else False\n            else:\n                answer.is_correct = False\n        \n        elif question.question_type == 'text':\n            answer.text_answer = request.form.get(answer_key, '')\n            # For text answers, manual grading would be needed\n            answer.is_correct = None\n            \n        elif question.question_type == 'code_submission':\n            answer.code_submission = request.form.get(answer_key, '')\n            # Execute code if provided (basic validation)\n            if answer.code_submission:\n                try:\n                    # Basic code execution simulation (for demonstration)\n                    # In production, use a secure sandboxed environment\n                    answer.execution_output = \"Code submitted successfully\"\n                    answer.is_correct = None  # Manual grading required\n                except Exception as e:\n                    answer.execution_error = str(e)\n                    answer.is_correct = False\n        \n        elif question.question_type == 'file_upload':\n            # Handle file upload for this answer\n            file_key = f'file_{question.id}'\n            if file_key in request.files:\n                file = request.files[file_key]\n                if file and file.filename:\n                    # Validate file type and size\n                    allowed_types = question.allowed_file_types.split(',') if question.allowed_file_types else ['pdf', 'docx', 'jpg', 'png', 'txt']\n                    file_ext = file.filename.rsplit('.', 1)[1].lower() if '.' in file.filename else ''\n                    \n                    if file_ext in [t.strip() for t in allowed_types]:\n                        # Check file size\n                        file.seek(0, 2)\n                        file_size = file.tell()\n                        file.seek(0)\n                        \n                        max_size = (question.max_file_size_mb or 10) * 1024 * 1024\n                        if file_size <= max_size:\n                            # Save file\n                            filename = secure_filename(file.filename)\n                            timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')\n                            filename = f\"{attempt.id}_{question.id}_{timestamp}_{filename}\"\n                            file_path = os.path.join(QUIZ_ANSWER_UPLOAD_FOLDER, filename)\n                            file.save(file_path)\n                            \n                            answer.uploaded_file_path = file_path\n                            answer.uploaded_file_name = file.filename\n                            answer.uploaded_file_size = file_size\n                            answer.is_correct = None  # Manual grading required\n                        else:\n                            answer.is_correct = False\n                            answer.text_answer = f\"File too large. Maximum size: {question.max_file_size_mb}MB\"\n                    else:\n                        answer.is_correct = False\n                        answer.text_answer = f\"Invalid file type. Allowed: {question.allowed_file_types}\"\n            else:\n                answer.is_correct = False\n                answer.text_answer = \"No file uploaded\"\n        \n        elif question.question_type == 'drawing':\n            # Handle drawing/canvas data\n            drawing_data = request.form.get(f'drawing_{question.id}', '')\n            if drawing_data:\n                answer.drawing_data = drawing_data\n                answer.is_correct = None  # Manual grading required\n            else:\n                answer.is_correct = False\n                answer.text_answer = \"No drawing provided\"\n        \n        db.session.add(answer)\n        \n        # Trigger collaboration detection for new/updated answers\n        if detector and (not existing_answer or existing_answer.selected_option_id != answer.selected_option_id):\n            try:\n                # Set quiz_id for the answer (if not already set)\n                answer.quiz_id = quiz.id\n                db.session.flush()  # Ensure answer has an ID\n                \n                # Run collaboration detection\n                signals = detector.process_new_answer(answer)\n                if signals:\n                    app.logger.info(f\"Detected {len(signals)} collaboration signals for quiz {quiz.id}\")\n            except Exception as e:\n                app.logger.error(f\"Error in collaboration detection: {e}\")\n        \n        # AI-Powered Plagiarism Detection for text answers\n        if plagiarism_detector and question.question_type == 'text' and answer.text_answer:\n            try:\n                db.session.flush()  # Ensure answer has an ID\n                \n                # Get all other text answers for this question for comparison\n                other_answers = Answer.query.filter(\n                    Answer.question_id == question.id,\n                    Answer.id != answer.id,\n                    Answer.text_answer.isnot(None),\n                    Answer.text_answer != ''\n                ).all()\n                \n                # Prepare comparison texts\n                comparison_texts = [(ans.id, ans.text_answer) for ans in other_answers]\n                \n                # Run plagiarism analysis\n                if comparison_texts:  # Only analyze if there are other answers to compare against\n                    analysis = plagiarism_detector.analyze_text_for_plagiarism(\n                        target_text=answer.text_answer,\n                        comparison_texts=comparison_texts,\n                        answer_id=answer.id,\n                        quiz_attempt_id=attempt.id,\n                        question_id=question.id\n                    )\n                    \n                    # Save analysis to database\n                    db.session.add(analysis)\n                    \n                    # Log if high-risk plagiarism detected\n                    if analysis.risk_level in ['high', 'critical']:\n                        app.logger.warning(f\"High-risk plagiarism detected for answer {answer.id}: {analysis.risk_level} ({analysis.overall_similarity_score:.3f})\")\n                    \n            except Exception as e:\n                app.logger.error(f\"Error in plagiarism detection: {e}\")\n    \n    # Mark attempt as completed\n    attempt.completed_at = datetime.utcnow()\n    attempt.status = 'completed'\n    attempt.calculate_score()\n    \n    db.session.commit()\n    \n    flash('Quiz submitted successfully!', 'success')\n    return redirect(url_for('quiz_results', attempt_id=attempt_id))\n\n@app.route('/results/<int:attempt_id>')\n@login_required\ndef quiz_results(attempt_id):\n    \"\"\"View quiz results\"\"\"\n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    if attempt.participant_id != current_user.id and attempt.quiz.creator_id != current_user.id and not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    quiz = attempt.quiz\n    questions = quiz.questions\n    answers = {answer.question_id: answer for answer in attempt.answers}\n    \n    return render_template('quiz_results.html', \n                         attempt=attempt, \n                         quiz=quiz, \n                         questions=questions,\n                         answers=answers)\n\n@app.route('/download/participant-report/<int:attempt_id>')\n@login_required\ndef download_participant_report(attempt_id):\n    \"\"\"Download participant report as PDF with comprehensive error handling\"\"\"\n    try:\n        attempt = QuizAttempt.query.get_or_404(attempt_id)\n        \n        if attempt.participant_id != current_user.id:\n            flash('Access denied.', 'error')\n            return redirect(url_for('participant_dashboard'))\n    except Exception as e:\n        logging.error(f\"Error fetching quiz attempt {attempt_id}: {e}\")\n        flash('Quiz attempt not found.', 'error')\n        return redirect(url_for('participant_dashboard'))\n    \n    from reportlab.lib.pagesizes import letter, A4\n    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle\n    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\n    from reportlab.lib import colors\n    from reportlab.lib.units import inch\n    from io import BytesIO\n    \n    # Create PDF\n    buffer = BytesIO()\n    doc = SimpleDocTemplate(buffer, pagesize=A4)\n    styles = getSampleStyleSheet()\n    \n    # Custom styles\n    title_style = ParagraphStyle(\n        'CustomTitle',\n        parent=styles['Heading1'],\n        fontSize=24,\n        textColor=colors.darkblue,\n        spaceAfter=30,\n        alignment=1  # Center alignment\n    )\n    \n    story = []\n    \n    # Title\n    story.append(Paragraph(\"Quiz Results Report\", title_style))\n    story.append(Spacer(1, 20))\n    \n    # Quiz Information\n    quiz_info = [\n        ['Quiz Title:', attempt.quiz.title],\n        ['Participant:', attempt.participant.username],\n        ['Score:', f\"{attempt.score:.1f}%\" if attempt.score else 'N/A'],\n        ['Started:', attempt.started_at.strftime('%Y-%m-%d %H:%M:%S')],\n        ['Completed:', attempt.completed_at.strftime('%Y-%m-%d %H:%M:%S') if attempt.completed_at else 'Not completed'],\n        ['Status:', attempt.status.title()]\n    ]\n    \n    quiz_table = Table(quiz_info, colWidths=[2*inch, 4*inch])\n    quiz_table.setStyle(TableStyle([\n        ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),\n        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),\n        ('FONTSIZE', (0, 0), (-1, -1), 10),\n        ('BOTTOMPADDING', (0, 0), (-1, -1), 12),\n        ('BACKGROUND', (1, 0), (1, -1), colors.beige),\n        ('GRID', (0, 0), (-1, -1), 1, colors.black)\n    ]))\n    \n    story.append(quiz_table)\n    story.append(Spacer(1, 30))\n    \n    # Questions and Answers\n    story.append(Paragraph(\"Detailed Results\", styles['Heading2']))\n    story.append(Spacer(1, 20))\n    \n    answers = {answer.question_id: answer for answer in attempt.answers}\n    \n    for i, question in enumerate(attempt.quiz.questions, 1):\n        # Question\n        story.append(Paragraph(f\"Question {i}: {question.question_text}\", styles['Heading3']))\n        story.append(Spacer(1, 10))\n        \n        answer = answers.get(question.id)\n        \n        if question.question_type in ['multiple_choice', 'true_false']:\n            # Show options\n            options_data = [['Option', 'Your Answer', 'Correct Answer']]\n            for option in question.options:\n                is_selected = '‚úì' if answer and answer.selected_option_id == option.id else ''\n                is_correct = '‚úì' if option.is_correct else ''\n                options_data.append([option.option_text, is_selected, is_correct])\n            \n            options_table = Table(options_data, colWidths=[3*inch, 1*inch, 1*inch])\n            options_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                ('FONTSIZE', (0, 0), (-1, -1), 9),\n                ('BOTTOMPADDING', (0, 0), (-1, -1), 12),\n                ('GRID', (0, 0), (-1, -1), 1, colors.black)\n            ]))\n            \n            story.append(options_table)\n            \n            # Result\n            if answer:\n                if answer.is_correct:\n                    result_text = f\"<para><b>Result:</b> <font color='green'>Correct</font> (+{question.points} points)</para>\"\n                else:\n                    result_text = f\"<para><b>Result:</b> <font color='red'>Incorrect</font> (0 points)</para>\"\n            else:\n                result_text = \"<para><b>Result:</b> Not answered (0 points)</para>\"\n            \n            story.append(Spacer(1, 10))\n            story.append(Paragraph(result_text, styles['Normal']))\n            \n        elif question.question_type == 'text':\n            if answer and answer.text_answer:\n                story.append(Paragraph(f\"<b>Your Answer:</b> {answer.text_answer}\", styles['Normal']))\n                if answer.is_correct == None:\n                    story.append(Paragraph(\"<i>This answer requires manual grading.</i>\", styles['Normal']))\n            else:\n                story.append(Paragraph(\"<b>Your Answer:</b> No answer provided\", styles['Normal']))\n        \n        story.append(Spacer(1, 20))\n    \n    # Build PDF\n    doc.build(story)\n    buffer.seek(0)\n    \n    # Return as download\n    return send_file(\n        BytesIO(buffer.read()),\n        mimetype='application/pdf',\n        as_attachment=True,\n        download_name=f'quiz_report_{attempt.quiz.title}_{attempt.participant.username}.pdf'\n    )\n\n@app.route('/download/host-report/<int:attempt_id>')\n@login_required\ndef download_host_report(attempt_id):\n    \"\"\"Download detailed host report as Excel\"\"\"\n    attempt = QuizAttempt.query.get_or_404(attempt_id)\n    \n    if attempt.quiz.creator_id != current_user.id and not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('host_dashboard'))\n    \n    from openpyxl import Workbook\n    from openpyxl.styles import Font, Fill, PatternFill, Alignment\n    from openpyxl.utils import get_column_letter\n    from io import BytesIO\n    \n    # Create workbook\n    wb = Workbook()\n    \n    # Quiz Summary Sheet\n    ws1 = wb.active\n    ws1.title = \"Quiz Summary\"\n    \n    # Headers\n    ws1['A1'] = \"Quiz Results Summary\"\n    ws1['A1'].font = Font(size=16, bold=True)\n    ws1['A1'].fill = PatternFill(start_color=\"4472C4\", end_color=\"4472C4\", fill_type=\"solid\")\n    \n    # Quiz info\n    quiz_data = [\n        [\"Quiz Title\", attempt.quiz.title],\n        [\"Participant\", attempt.participant.username],\n        [\"Email\", attempt.participant.email],\n        [\"Score\", f\"{attempt.score:.1f}%\" if attempt.score else 'N/A'],\n        [\"Points Earned\", f\"{attempt.score * attempt.total_points / 100:.0f}\" if attempt.score and attempt.total_points else 'N/A'],\n        [\"Total Points\", attempt.total_points or 0],\n        [\"Started\", attempt.started_at.strftime('%Y-%m-%d %H:%M:%S')],\n        [\"Completed\", attempt.completed_at.strftime('%Y-%m-%d %H:%M:%S') if attempt.completed_at else 'Not completed'],\n        [\"Status\", attempt.status.title()],\n        [\"Time Taken\", str(attempt.completed_at - attempt.started_at) if attempt.completed_at else 'N/A']\n    ]\n    \n    for row, (label, value) in enumerate(quiz_data, 3):\n        ws1[f'A{row}'] = label\n        ws1[f'B{row}'] = value\n        ws1[f'A{row}'].font = Font(bold=True)\n    \n    # Detailed Answers Sheet\n    ws2 = wb.create_sheet(\"Detailed Answers\")\n    headers = [\"Question #\", \"Question Text\", \"Question Type\", \"Points\", \"Your Answer\", \"Correct Answer\", \"Result\", \"Points Earned\"]\n    \n    for col, header in enumerate(headers, 1):\n        ws2.cell(row=1, column=col, value=header)\n        ws2.cell(row=1, column=col).font = Font(bold=True)\n        ws2.cell(row=1, column=col).fill = PatternFill(start_color=\"D9E2F3\", end_color=\"D9E2F3\", fill_type=\"solid\")\n    \n    answers = {answer.question_id: answer for answer in attempt.answers}\n    \n    for row, question in enumerate(attempt.quiz.questions, 2):\n        answer = answers.get(question.id)\n        \n        ws2.cell(row=row, column=1, value=row-1)\n        ws2.cell(row=row, column=2, value=question.question_text)\n        ws2.cell(row=row, column=3, value=question.question_type.title())\n        ws2.cell(row=row, column=4, value=question.points)\n        \n        if question.question_type in ['multiple_choice', 'true_false']:\n            if answer and answer.selected_option_id:\n                selected_option = next((opt for opt in question.options if opt.id == answer.selected_option_id), None)\n                ws2.cell(row=row, column=5, value=selected_option.option_text if selected_option else 'Unknown')\n            else:\n                ws2.cell(row=row, column=5, value='Not answered')\n            \n            correct_option = next((opt for opt in question.options if opt.is_correct), None)\n            ws2.cell(row=row, column=6, value=correct_option.option_text if correct_option else 'No correct answer set')\n            \n            if answer:\n                if answer.is_correct:\n                    ws2.cell(row=row, column=7, value='Correct')\n                    ws2.cell(row=row, column=8, value=question.points)\n                    ws2.cell(row=row, column=7).fill = PatternFill(start_color=\"C6EFCE\", end_color=\"C6EFCE\", fill_type=\"solid\")\n                else:\n                    ws2.cell(row=row, column=7, value='Incorrect')\n                    ws2.cell(row=row, column=8, value=0)\n                    ws2.cell(row=row, column=7).fill = PatternFill(start_color=\"FFC7CE\", end_color=\"FFC7CE\", fill_type=\"solid\")\n            else:\n                ws2.cell(row=row, column=7, value='Not answered')\n                ws2.cell(row=row, column=8, value=0)\n        \n        elif question.question_type == 'text':\n            ws2.cell(row=row, column=5, value=answer.text_answer if answer and answer.text_answer else 'Not answered')\n            ws2.cell(row=row, column=6, value='Manual grading required')\n            ws2.cell(row=row, column=7, value='Needs review' if answer and answer.text_answer else 'Not answered')\n            ws2.cell(row=row, column=8, value='TBD')\n    \n    # Auto-adjust column widths\n    for ws in [ws1, ws2]:\n        for column in ws.columns:\n            max_length = 0\n            column_letter = get_column_letter(column[0].column)\n            for cell in column:\n                try:\n                    if len(str(cell.value)) > max_length:\n                        max_length = len(str(cell.value))\n                except:\n                    pass\n            adjusted_width = min(max_length + 2, 50)\n            ws.column_dimensions[column_letter].width = adjusted_width\n    \n    # Save to BytesIO\n    buffer = BytesIO()\n    wb.save(buffer)\n    buffer.seek(0)\n    \n    return send_file(\n        BytesIO(buffer.read()),\n        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        as_attachment=True,\n        download_name=f'detailed_report_{attempt.quiz.title}_{attempt.participant.username}.xlsx'\n    )\n\n@app.route('/profile', methods=['GET', 'POST'])\n@login_required\ndef profile():\n    \"\"\"User profile management\"\"\"\n    form = ProfileForm(obj=current_user)\n    \n    if form.validate_on_submit():\n        # Check if username is taken by another user\n        if form.username.data != current_user.username:\n            existing_user = User.query.filter_by(username=form.username.data).first()\n            if existing_user:\n                flash('Username already taken.', 'error')\n                return render_template('profile.html', form=form)\n        \n        # Check if email is taken by another user\n        if form.email.data != current_user.email:\n            existing_user = User.query.filter_by(email=form.email.data).first()\n            if existing_user:\n                flash('Email already registered.', 'error')\n                return render_template('profile.html', form=form)\n        \n        # Handle profile picture upload\n        if 'profile_picture' in request.files:\n            file = request.files['profile_picture']\n            if file and file.filename:\n                import os\n                from werkzeug.utils import secure_filename\n                \n                # Create uploads directory if it doesn't exist\n                upload_dir = os.path.join('static', 'uploads', 'profiles')\n                os.makedirs(upload_dir, exist_ok=True)\n                \n                # Save file with user id prefix\n                filename = f\"user_{current_user.id}_{secure_filename(file.filename)}\"\n                filepath = os.path.join(upload_dir, filename)\n                file.save(filepath)\n                \n                # Update user profile picture path\n                current_user.profile_picture = f\"uploads/profiles/{filename}\"\n\n        # Update profile\n        current_user.username = form.username.data\n        \n        # Handle email change without verification requirement\n        if form.email.data != current_user.email:\n            current_user.email = form.email.data\n            current_user.is_verified = True  # Auto-verify for profile updates\n            flash('Email updated successfully!', 'success')\n        \n        # Update password if provided\n        if form.current_password.data and form.new_password.data:\n            if current_user.check_password(form.current_password.data):\n                current_user.set_password(form.new_password.data)\n                flash('Password updated successfully!', 'success')\n            else:\n                flash('Current password is incorrect.', 'error')\n                return render_template('profile.html', form=form)\n        \n        db.session.commit()\n        flash('Profile updated successfully!', 'success')\n        return redirect(url_for('profile'))\n    \n    return render_template('profile.html', \n                         form=form,\n                         greeting=get_time_greeting(),\n                         greeting_icon=get_greeting_icon())\n\n\n@app.route('/api/quiz/<int:quiz_id>/questions')\n@login_required\ndef get_quiz_questions(quiz_id):\n    \"\"\"Get quiz questions for AJAX loading\"\"\"\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    if quiz.creator_id != current_user.id and not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    questions = []\n    for question in quiz.questions:\n        question_data = {\n            'id': question.id,\n            'text': question.question_text,\n            'type': question.question_type,\n            'points': question.points,\n            'options': []\n        }\n        \n        for option in question.options:\n            question_data['options'].append({\n                'id': option.id,\n                'text': option.option_text,\n                'is_correct': option.is_correct\n            })\n        \n        questions.append(question_data)\n    \n    return jsonify({'questions': questions})\n\n\n\n@app.route('/admin/violations')\n@login_required\ndef admin_violations():\n    \"\"\"Enhanced violations view with consolidated entries per user per quiz\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get filter parameters\n    severity_filter = request.args.get('severity', 'all')\n    date_filter = request.args.get('date_range', '7')\n    user_filter = request.args.get('user_id', '')\n    \n    # Build aggregated query to consolidate violations by user, quiz, and type\n    from sqlalchemy import func, case\n    \n    base_query = db.session.query(\n        User.id.label('user_id'),\n        User.username.label('username'),\n        User.email.label('email'),\n        Quiz.id.label('quiz_id'),\n        Quiz.title.label('quiz_title'),\n        Quiz.creator_id.label('creator_id'),\n        func.max(User.username).label('creator_username'),  # Will be corrected below\n        ProctoringEvent.event_type.label('violation_type'),\n        func.count(ProctoringEvent.id).label('count'),\n        func.max(ProctoringEvent.timestamp).label('latest_at'),\n        func.max(ProctoringEvent.description).label('description'),\n        func.max(case(\n            (ProctoringEvent.severity == 'low', 1),\n            (ProctoringEvent.severity == 'medium', 2), \n            (ProctoringEvent.severity == 'high', 3),\n            (ProctoringEvent.severity == 'critical', 4),\n            else_=0\n        )).label('severity_rank'),\n        func.max(QuizAttempt.status).label('attempt_status')\n    ).join(QuizAttempt, ProctoringEvent.attempt_id == QuizAttempt.id) \\\n     .join(User, QuizAttempt.participant_id == User.id) \\\n     .join(Quiz, QuizAttempt.quiz_id == Quiz.id)\n    \n    # Apply filters\n    if severity_filter != 'all':\n        base_query = base_query.filter(ProctoringEvent.severity == severity_filter)\n    \n    if date_filter != 'all':\n        days_ago = datetime.utcnow() - timedelta(days=int(date_filter))\n        base_query = base_query.filter(ProctoringEvent.timestamp >= days_ago)\n    \n    if user_filter:\n        base_query = base_query.filter(User.id == user_filter)\n    \n    # Group by user, quiz, and violation type\n    aggregated_violations = base_query.group_by(\n        User.id, User.username, User.email,\n        Quiz.id, Quiz.title, Quiz.creator_id,\n        ProctoringEvent.event_type\n    ).order_by(func.max(ProctoringEvent.timestamp).desc()).limit(500).all()\n    \n    # Get creator usernames for the results\n    creator_usernames = {}\n    if aggregated_violations:\n        creator_ids = {v.creator_id for v in aggregated_violations}\n        creators = User.query.filter(User.id.in_(creator_ids)).all()\n        creator_usernames = {creator.id: creator.username for creator in creators}\n    \n    # Convert severity rank back to text and add creator username\n    violations = []\n    for v in aggregated_violations:\n        severity_map = {1: 'low', 2: 'medium', 3: 'high', 4: 'critical'}\n        violations.append({\n            'user_id': v.user_id,\n            'username': v.username,\n            'email': v.email,\n            'quiz_id': v.quiz_id,\n            'quiz_title': v.quiz_title,\n            'creator_username': creator_usernames.get(v.creator_id, 'Unknown'),\n            'violation_type': v.violation_type,\n            'count': v.count,\n            'latest_at': v.latest_at,\n            'description': v.description,\n            'severity': severity_map.get(v.severity_rank, 'low'),\n            'attempt_status': v.attempt_status\n        })\n    \n    # Get violation statistics\n    total_violations = ProctoringEvent.query.count()\n    high_severity = ProctoringEvent.query.filter_by(severity='high').count()\n    recent_violations = ProctoringEvent.query.filter(\n        ProctoringEvent.timestamp >= datetime.utcnow() - timedelta(hours=24)\n    ).count()\n    \n    stats = {\n        'total_violations': total_violations,\n        'high_severity': high_severity,\n        'recent_violations': recent_violations\n    }\n    \n    # Get all users for filter dropdown\n    users = User.query.filter_by(role='participant').all()\n    \n    return render_template('admin_violations.html', \n                         violations=violations, \n                         stats=stats,\n                         users=users,\n                         current_filters={\n                             'severity': severity_filter,\n                             'date_range': date_filter,\n                             'user_id': user_filter\n                         })\n\n@app.route('/admin/violations/<int:user_id>/<int:quiz_id>/<violation_type>')\n@login_required\ndef admin_violation_details(user_id, quiz_id, violation_type):\n    \"\"\"Show detailed violation timeline for a specific user-quiz-type combination\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get the user and quiz for display\n    user = User.query.get_or_404(user_id)\n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    # Get all detailed violations for this combination\n    violations = ProctoringEvent.query.join(QuizAttempt) \\\n        .filter(\n            QuizAttempt.participant_id == user_id,\n            QuizAttempt.quiz_id == quiz_id,\n            ProctoringEvent.event_type == violation_type\n        ).order_by(ProctoringEvent.timestamp.desc()).all()\n    \n    return render_template('admin_violation_details.html',\n                         user=user,\n                         quiz=quiz,\n                         violation_type=violation_type,\n                         violations=violations)\n\n@app.route('/admin/user/<int:user_id>/edit-credentials', methods=['POST'])\n@login_required\ndef admin_edit_credentials(user_id):\n    \"\"\"Edit user credentials\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    user = User.query.get_or_404(user_id)\n    \n    # Don't allow editing your own account\n    if user.id == current_user.id:\n        flash('You cannot edit your own credentials.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    username = request.form.get('username')\n    email = request.form.get('email')\n    password = request.form.get('password')\n    \n    # Validation\n    if not username or not email:\n        flash('Username and email are required.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Check for duplicates\n    if username != user.username and User.query.filter_by(username=username).first():\n        flash('Username already exists.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    if email != user.email and User.query.filter_by(email=email).first():\n        flash('Email already exists.', 'error')\n        return redirect(url_for('admin_users'))\n    \n    # Update credentials\n    user.username = username\n    user.email = email\n    \n    if password and len(password) >= 6:\n        user.set_password(password)\n    \n    db.session.commit()\n    flash(f'Credentials updated for user {username}.', 'success')\n    return redirect(url_for('admin_users'))\n\n@app.route('/admin/quiz-management')\n@login_required\ndef admin_quiz_management():\n    \"\"\"Admin quiz management system\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    quizzes = Quiz.query.order_by(Quiz.display_order.asc(), Quiz.created_at.desc()).all()\n    return render_template('admin_quiz_management.html', quizzes=quizzes)\n\n# AI-Powered Plagiarism Detection Admin Routes\n@app.route('/admin/plagiarism-detection')\n@login_required \ndef admin_plagiarism_detection():\n    \"\"\"Admin dashboard for plagiarism detection monitoring and management\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get filter parameters\n    risk_filter = request.args.get('risk', 'all')\n    review_filter = request.args.get('reviewed', 'all')\n    quiz_filter = request.args.get('quiz_id', type=int)\n    \n    # Build query\n    query = db.session.query(PlagiarismAnalysis).join(Answer).join(QuizAttempt).join(Quiz).join(User)\n    \n    # Apply filters\n    if risk_filter != 'all':\n        query = query.filter(PlagiarismAnalysis.risk_level == risk_filter)\n    \n    if review_filter == 'reviewed':\n        query = query.filter(PlagiarismAnalysis.is_reviewed == True)\n    elif review_filter == 'pending':\n        query = query.filter(PlagiarismAnalysis.requires_review == True, PlagiarismAnalysis.is_reviewed == False)\n    \n    if quiz_filter:\n        query = query.filter(Quiz.id == quiz_filter)\n    \n    # Get paginated results\n    page = request.args.get('page', 1, type=int)\n    analyses = query.order_by(PlagiarismAnalysis.analyzed_at.desc()).paginate(\n        page=page, per_page=20, error_out=False\n    )\n    \n    # Get summary statistics\n    total_analyses = PlagiarismAnalysis.query.count()\n    flagged_count = PlagiarismAnalysis.query.filter_by(is_flagged=True).count()\n    pending_review = PlagiarismAnalysis.query.filter_by(requires_review=True, is_reviewed=False).count()\n    \n    # Risk level breakdown\n    risk_stats = db.session.query(\n        PlagiarismAnalysis.risk_level,\n        func.count(PlagiarismAnalysis.id).label('count')\n    ).group_by(PlagiarismAnalysis.risk_level).all()\n    \n    # Get available quizzes for filter\n    quizzes = Quiz.query.order_by(Quiz.title).all()\n    \n    return render_template('admin_plagiarism_detection.html',\n                         analyses=analyses,\n                         total_analyses=total_analyses,\n                         flagged_count=flagged_count,\n                         pending_review=pending_review,\n                         risk_stats=dict(risk_stats),\n                         quizzes=quizzes,\n                         current_filters={\n                             'risk': risk_filter,\n                             'reviewed': review_filter,\n                             'quiz_id': quiz_filter\n                         })\n\n@app.route('/admin/plagiarism-analysis/<int:analysis_id>')\n@login_required\ndef admin_plagiarism_analysis_detail(analysis_id):\n    \"\"\"Detailed view of a specific plagiarism analysis\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    analysis = PlagiarismAnalysis.query.get_or_404(analysis_id)\n    \n    # Get related data\n    answer = analysis.answer\n    quiz_attempt = analysis.quiz_attempt\n    question = analysis.question\n    participant = quiz_attempt.participant\n    quiz = quiz_attempt.quiz\n    \n    # Get plagiarism matches for this analysis\n    matches = PlagiarismMatch.query.filter_by(analysis_id=analysis_id).all()\n    \n    return render_template('admin_plagiarism_analysis_detail.html',\n                         analysis=analysis,\n                         answer=answer,\n                         quiz_attempt=quiz_attempt,\n                         question=question,\n                         participant=participant,\n                         quiz=quiz,\n                         matches=matches)\n\n@app.route('/admin/plagiarism-analysis/<int:analysis_id>/review', methods=['POST'])\n@login_required\ndef admin_review_plagiarism(analysis_id):\n    \"\"\"Review and make decision on plagiarism analysis\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # CSRF Protection - Check token\n    csrf_token = request.form.get('csrf_token')\n    expected_token = session.get('csrf_token')\n    if not csrf_token or csrf_token != expected_token:\n        flash('Security error: Invalid CSRF token. Please try again.', 'error')\n        return redirect(url_for('admin_plagiarism_detection'))\n    \n    analysis = PlagiarismAnalysis.query.get_or_404(analysis_id)\n    \n    decision = request.form.get('decision')  # 'innocent', 'suspicious', 'plagiarized'\n    notes = request.form.get('notes', '')\n    \n    if decision not in ['innocent', 'suspicious', 'plagiarized']:\n        flash('Invalid decision option.', 'error')\n        return redirect(url_for('admin_plagiarism_analysis_detail', analysis_id=analysis_id))\n    \n    # Update analysis\n    analysis.is_reviewed = True\n    analysis.reviewed_by = current_user.id\n    analysis.reviewed_at = datetime.utcnow()\n    analysis.review_decision = decision\n    analysis.review_notes = notes\n    \n    # Update flagged status based on decision\n    if decision == 'plagiarized':\n        analysis.is_flagged = True\n    elif decision == 'innocent':\n        analysis.is_flagged = False\n    \n    db.session.commit()\n    \n    flash(f'Plagiarism analysis marked as {decision}.', 'success')\n    return redirect(url_for('admin_plagiarism_detection'))\n\n@app.route('/admin/plagiarism-reports/download')\n@login_required\ndef download_plagiarism_report():\n    \"\"\"Download comprehensive plagiarism detection report\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Admin privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    try:\n        # Create workbook\n        wb = Workbook()\n        ws = wb.active\n        ws.title = \"Plagiarism Detection Report\"\n        \n        # Define headers\n        headers = [\n            'Analysis ID', 'Quiz Title', 'Participant', 'Question Text', \n            'Risk Level', 'Similarity Score', 'Cosine Similarity', \n            'Jaccard Similarity', 'Levenshtein Similarity', 'Semantic Similarity',\n            'Flagged', 'Requires Review', 'Reviewed', 'Review Decision',\n            'Analyzed At', 'Reviewed At', 'Reviewer'\n        ]\n        \n        # Add headers with styling\n        for col, header in enumerate(headers, 1):\n            cell = ws.cell(row=1, column=col, value=header)\n            cell.font = Font(bold=True)\n            cell.fill = PatternFill(start_color=\"366092\", end_color=\"366092\", fill_type=\"solid\")\n        \n        # Get all analyses with related data\n        analyses = db.session.query(PlagiarismAnalysis).join(Answer).join(QuizAttempt).join(Quiz).join(User).join(Question).all()\n        \n        # Add data rows\n        for row, analysis in enumerate(analyses, 2):\n            data = [\n                analysis.id,\n                analysis.quiz_attempt.quiz.title,\n                analysis.quiz_attempt.participant.username,\n                analysis.question.question_text[:100] + \"...\" if len(analysis.question.question_text) > 100 else analysis.question.question_text,\n                analysis.risk_level,\n                f\"{analysis.overall_similarity_score:.3f}\",\n                f\"{analysis.cosine_similarity:.3f}\" if analysis.cosine_similarity else \"N/A\",\n                f\"{analysis.jaccard_similarity:.3f}\" if analysis.jaccard_similarity else \"N/A\", \n                f\"{analysis.levenshtein_similarity:.3f}\" if analysis.levenshtein_similarity else \"N/A\",\n                f\"{analysis.semantic_similarity:.3f}\" if analysis.semantic_similarity else \"N/A\",\n                \"Yes\" if analysis.is_flagged else \"No\",\n                \"Yes\" if analysis.requires_review else \"No\",\n                \"Yes\" if analysis.is_reviewed else \"No\",\n                analysis.review_decision or \"N/A\",\n                analysis.analyzed_at.strftime('%Y-%m-%d %H:%M:%S'),\n                analysis.reviewed_at.strftime('%Y-%m-%d %H:%M:%S') if analysis.reviewed_at else \"N/A\",\n                analysis.reviewer.username if analysis.reviewer else \"N/A\"\n            ]\n            \n            for col, value in enumerate(data, 1):\n                ws.cell(row=row, column=col, value=value)\n        \n        # Auto-adjust column widths\n        for column in ws.columns:\n            max_length = 0\n            column_letter = get_column_letter(column[0].column)\n            for cell in column:\n                try:\n                    if len(str(cell.value)) > max_length:\n                        max_length = len(str(cell.value))\n                except:\n                    pass\n            adjusted_width = min(max_length + 2, 50)\n            ws.column_dimensions[column_letter].width = adjusted_width\n        \n        # Save to BytesIO\n        output = BytesIO()\n        wb.save(output)\n        output.seek(0)\n        \n        # Create response\n        response = make_response(output.getvalue())\n        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n        response.headers['Content-Disposition'] = f'attachment; filename=plagiarism_detection_report_{datetime.now().strftime(\"%Y%m%d_%H%M%S\")}.xlsx'\n        \n        app.logger.info(f\"Plagiarism detection report downloaded by admin {current_user.username}\")\n        return response\n        \n    except Exception as e:\n        app.logger.error(f\"Error generating plagiarism report: {e}\")\n        flash('Error generating report. Please try again.', 'error')\n        return redirect(url_for('admin_plagiarism_detection'))\n\n@app.route('/admin/analytics')\n@login_required\ndef admin_analytics():\n    \"\"\"Comprehensive system analytics dashboard\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Comprehensive analytics data\n    total_users = User.query.count()\n    total_hosts = User.query.filter_by(role='host').count()\n    total_participants = User.query.filter_by(role='participant').count()\n    total_quizzes = Quiz.query.count()\n    active_quizzes = Quiz.query.filter_by(is_active=True).count()\n    total_attempts = QuizAttempt.query.count()\n    completed_attempts = QuizAttempt.query.filter_by(status='completed').count()\n    total_violations = ProctoringEvent.query.count()\n    high_violations = ProctoringEvent.query.filter_by(severity='high').count()\n    total_courses = Course.query.count()\n    active_courses = Course.query.filter_by(is_active=True).count()\n    \n    # Recent activity analytics\n    today = datetime.utcnow().date()\n    week_ago = datetime.utcnow() - timedelta(days=7)\n    month_ago = datetime.utcnow() - timedelta(days=30)\n    \n    today_attempts = QuizAttempt.query.filter(\n        func.date(QuizAttempt.started_at) == today\n    ).count()\n    \n    week_attempts = QuizAttempt.query.filter(\n        QuizAttempt.started_at >= week_ago\n    ).count()\n    \n    month_attempts = QuizAttempt.query.filter(\n        QuizAttempt.started_at >= month_ago\n    ).count()\n    \n    # Performance analytics\n    if completed_attempts > 0:\n        completed_attempts_with_scores = QuizAttempt.query.filter(\n            QuizAttempt.status == 'completed',\n            QuizAttempt.score.isnot(None)\n        ).all()\n        \n        if completed_attempts_with_scores:\n            avg_score = sum(attempt.score for attempt in completed_attempts_with_scores) / len(completed_attempts_with_scores)\n            highest_score = max(attempt.score for attempt in completed_attempts_with_scores)\n            lowest_score = min(attempt.score for attempt in completed_attempts_with_scores)\n        else:\n            avg_score = highest_score = lowest_score = 0\n    else:\n        avg_score = highest_score = lowest_score = 0\n    \n    # Top performing participants\n    top_participants = db.session.query(\n        User.username,\n        func.avg(QuizAttempt.score).label('avg_score'),\n        func.count(QuizAttempt.id).label('attempt_count')\n    ).join(QuizAttempt, User.id == QuizAttempt.participant_id).filter(\n        QuizAttempt.status == 'completed',\n        QuizAttempt.score.isnot(None)\n    ).group_by(User.id, User.username).order_by(\n        func.avg(QuizAttempt.score).desc()\n    ).limit(10).all()\n    \n    # Calculate additional user metrics\n    active_users = User.query.filter(\n        User.last_login >= datetime.utcnow() - timedelta(days=30)\n    ).count()\n    recent_users = User.query.filter(\n        User.created_at >= datetime.utcnow() - timedelta(days=30)\n    ).count()\n    \n    analytics_data = {\n        'users': {\n            'total': total_users,\n            'hosts': total_hosts,\n            'participants': total_participants,\n            'active': active_users,\n            'recent': recent_users\n        },\n        'quizzes': {\n            'total': total_quizzes,\n            'active': active_quizzes\n        },\n        'attempts': {\n            'total': total_attempts,\n            'completed': completed_attempts,\n            'today': today_attempts,\n            'week': week_attempts,\n            'month': month_attempts\n        },\n        'violations': {\n            'total': total_violations,\n            'high': high_violations\n        },\n        'courses': {\n            'total': total_courses,\n            'active': active_courses\n        },\n        'scores': {\n            'average': round(avg_score, 1),\n            'highest': highest_score,\n            'lowest': lowest_score\n        },\n        'top_participants': top_participants\n    }\n    \n    return render_template('admin_analytics.html', analytics=analytics_data)\n\n@app.route('/admin/bulk-operations', endpoint='admin_bulk_users')\n@login_required\ndef admin_bulk_operations():\n    \"\"\"Bulk operations management dashboard\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get recent bulk operation statistics\n    total_users = User.query.count()\n    recent_users = User.query.filter(\n        User.created_at >= datetime.utcnow() - timedelta(days=30)\n    ).count()\n    \n    # Get courses for bulk assignment\n    active_courses = Course.query.filter_by(is_active=True).all()\n    \n    return render_template('admin_bulk_users.html', \n                         total_users=total_users,\n                         recent_users=recent_users,\n                         active_courses=active_courses)\n\n@app.route('/admin/system-settings')\n@login_required\ndef admin_system_settings():\n    \"\"\"Admin system settings\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    return render_template('admin_system_settings.html')\n\n@app.route('/admin/violation-appeals')\n@login_required\ndef admin_violation_appeals():\n    \"\"\"Admin page to manage student violation appeals\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get users with pending appeals (flagged users who requested reconsideration)\n    pending_appeals = db.session.query(UserViolation, User).join(\n        User, UserViolation.user_id == User.id\n    ).filter(\n        UserViolation.is_flagged == True,\n        UserViolation.can_retake == False,\n        UserViolation.notes.ilike('%appeal%')\n    ).order_by(UserViolation.flagged_at.desc()).all()\n    \n    # Get recent violations for context\n    recent_violations = db.session.query(ProctoringEvent, QuizAttempt, User, Quiz).join(\n        QuizAttempt, ProctoringEvent.attempt_id == QuizAttempt.id\n    ).join(\n        User, QuizAttempt.participant_id == User.id\n    ).join(\n        Quiz, QuizAttempt.quiz_id == Quiz.id\n    ).filter(\n        ProctoringEvent.severity.in_(['high', 'critical'])\n    ).order_by(ProctoringEvent.timestamp.desc()).limit(50).all()\n    \n    return render_template('admin_violation_appeals.html', \n                         pending_appeals=pending_appeals,\n                         recent_violations=recent_violations)\n\n@app.route('/admin/approve-appeal/<int:violation_id>', methods=['POST'])\n@login_required\ndef admin_approve_appeal(violation_id):\n    \"\"\"Admin approves a student's violation appeal\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    violation = UserViolation.query.get_or_404(violation_id)\n    decision = request.form.get('decision')  # 'approve' or 'deny'\n    admin_notes = request.form.get('admin_notes', '')\n    \n    if decision == 'approve':\n        violation.can_retake = True\n        violation.retake_approved_by = current_user.id\n        violation.retake_approved_at = datetime.utcnow()\n        violation.notes += f\"\\n\\n[ADMIN APPROVAL - {current_user.username}]: Appeal approved. {admin_notes}\"\n        flash(f'Appeal approved for {violation.user.username}. They can now retake exams.', 'success')\n    else:\n        violation.notes += f\"\\n\\n[ADMIN DENIAL - {current_user.username}]: Appeal denied. {admin_notes}\"\n        flash(f'Appeal denied for {violation.user.username}.', 'info')\n    \n    db.session.commit()\n    return redirect(url_for('admin_violation_appeals'))\n\n@app.route('/student/request-appeal', methods=['GET', 'POST'])\n@login_required\ndef student_request_appeal():\n    \"\"\"Student requests appeal for security violations\"\"\"\n    if current_user.is_admin() or current_user.is_host():\n        flash('This page is for students only.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Check if user has violations\n    violation = UserViolation.query.filter_by(user_id=current_user.id, is_flagged=True).first()\n    \n    if request.method == 'POST':\n        if not violation:\n            flash('You do not have any flagged violations to appeal.', 'error')\n            return redirect(url_for('dashboard'))\n        \n        appeal_reason = request.form.get('appeal_reason', '').strip()\n        if not appeal_reason:\n            flash('Please provide a reason for your appeal.', 'error')\n            return render_template('student_appeal_form.html', violation=violation)\n        \n        # Add appeal to notes\n        current_time = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')\n        violation.notes += f\"\\n\\n[STUDENT APPEAL - {current_time}]: {appeal_reason}\"\n        db.session.commit()\n        \n        flash('Your appeal has been submitted. An administrator will review it shortly.', 'success')\n        return redirect(url_for('dashboard'))\n    \n    return render_template('student_appeal_form.html', violation=violation)\n\n@app.route('/admin/audit-logs')\n@login_required\ndef admin_audit_logs():\n    \"\"\"Admin audit logs\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get recent activities (for now, we'll show quiz attempts and user registrations)\n    recent_attempts = QuizAttempt.query.order_by(QuizAttempt.started_at.desc()).limit(50).all()\n    recent_users = User.query.order_by(User.created_at.desc()).limit(20).all()\n    \n    return render_template('admin_audit_logs.html', recent_attempts=recent_attempts, recent_users=recent_users)\n\n@app.route('/admin/quiz/<int:quiz_id>/toggle-active', methods=['POST'])\n@login_required\ndef admin_toggle_quiz_active(quiz_id):\n    \"\"\"Toggle quiz active status\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    quiz = Quiz.query.get_or_404(quiz_id)\n    quiz.is_active = not quiz.is_active\n    db.session.commit()\n    \n    status = 'activated' if quiz.is_active else 'deactivated'\n    flash(f'Quiz \"{quiz.title}\" has been {status}.', 'success')\n    return redirect(url_for('admin_quiz_management'))\n\n@app.route('/admin/quiz/<int:quiz_id>/delete', methods=['POST'])\n@login_required\ndef admin_delete_quiz(quiz_id):\n    \"\"\"Delete a quiz (admin only)\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    quiz = Quiz.query.get_or_404(quiz_id)\n    \n    # Delete all related data in correct order (respecting foreign keys)\n    # 1. Delete answers first (they reference quiz_attempt)\n    attempts = QuizAttempt.query.filter_by(quiz_id=quiz_id).all()\n    for attempt in attempts:\n        Answer.query.filter_by(attempt_id=attempt.id).delete()\n        ProctoringEvent.query.filter_by(attempt_id=attempt.id).delete()\n    \n    # 2. Delete quiz attempts\n    QuizAttempt.query.filter_by(quiz_id=quiz_id).delete()\n    \n    # 3. Delete question options and questions\n    for question in quiz.questions:\n        QuestionOption.query.filter_by(question_id=question.id).delete()\n    Question.query.filter_by(quiz_id=quiz_id).delete()\n    \n    # 4. Finally delete the quiz\n    db.session.delete(quiz)\n    db.session.commit()\n    \n    flash(f'Quiz \"{quiz.title}\" has been permanently deleted.', 'success')\n    return redirect(url_for('admin_quiz_management'))\n\n# ===== COURSE MANAGEMENT SYSTEM =====\n@app.route('/admin/course-management')\n@login_required\ndef admin_course_management():\n    \"\"\"Admin course management system\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    courses = Course.query.order_by(Course.display_order.asc(), Course.created_at.desc()).all()\n    hosts = User.query.filter_by(role='host').all()\n    participants = User.query.filter_by(role='participant').all()\n    \n    # Get course statistics\n    course_stats = {}\n    for course in courses:\n        stats = {\n            'total_hosts': len(course.host_assignments),\n            'total_participants': len(course.participant_enrollments),\n            'total_quizzes': len(course.quizzes),\n            'active_quizzes': len([q for q in course.quizzes if q.is_active])\n        }\n        course_stats[course.id] = stats\n    \n    return render_template('admin_course_management.html', \n                         courses=courses, \n                         hosts=hosts, \n                         participants=participants,\n                         course_stats=course_stats)\n\n@app.route('/admin/create-course', methods=['POST'])\n@login_required\ndef admin_create_course():\n    \"\"\"Create new course\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    name = request.form.get('name')\n    code = request.form.get('code')\n    description = request.form.get('description')\n    max_participants = request.form.get('max_participants', 100, type=int)\n    \n    # Validation\n    if not all([name, code]):\n        flash('Course name and code are required.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    if Course.query.filter_by(code=code).first():\n        flash('Course code already exists.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    # Create course\n    course = Course()\n    course.name = name\n    course.code = code.upper()\n    course.description = description\n    course.max_participants = max_participants\n    \n    db.session.add(course)\n    db.session.commit()\n    \n    flash(f'Course \"{name}\" ({code}) created successfully.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/assign-host', methods=['POST'])\n@login_required\ndef admin_assign_host_to_course(course_id):\n    \"\"\"Assign host to course\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    course = Course.query.get_or_404(course_id)\n    host_id = request.form.get('host_id', type=int)\n    \n    if not host_id:\n        flash('Please select a host to assign.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    host = User.query.get_or_404(host_id)\n    if host.role != 'host':\n        flash('Selected user is not a host.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    # Check if already assigned\n    existing = HostCourseAssignment.query.filter_by(host_id=host_id, course_id=course_id).first()\n    if existing:\n        flash(f'Host {host.username} is already assigned to course {course.name}.', 'warning')\n        return redirect(url_for('admin_course_management'))\n    \n    # Create assignment\n    assignment = HostCourseAssignment()\n    assignment.host_id = host_id\n    assignment.course_id = course_id\n    assignment.assigned_by = current_user.id\n    \n    db.session.add(assignment)\n    db.session.commit()\n    \n    flash(f'Host {host.username} assigned to course {course.name} successfully.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/enroll-participant', methods=['POST'])\n@login_required\ndef admin_enroll_participant_in_course(course_id):\n    \"\"\"Enroll participant in course\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    course = Course.query.get_or_404(course_id)\n    participant_id = request.form.get('participant_id', type=int)\n    \n    if not participant_id:\n        flash('Please select a participant to enroll.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    participant = User.query.get_or_404(participant_id)\n    if participant.role != 'participant':\n        flash('Selected user is not a participant.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    # Check participant limit\n    current_enrollments = len(course.participant_enrollments)\n    if current_enrollments >= course.max_participants:\n        flash(f'Course {course.name} has reached maximum participant limit ({course.max_participants}).', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    # Check if already enrolled\n    existing = ParticipantEnrollment.query.filter_by(participant_id=participant_id, course_id=course_id).first()\n    if existing:\n        flash(f'Participant {participant.username} is already enrolled in course {course.name}.', 'warning')\n        return redirect(url_for('admin_course_management'))\n    \n    # Create enrollment\n    enrollment = ParticipantEnrollment()\n    enrollment.participant_id = participant_id\n    enrollment.course_id = course_id\n    enrollment.enrolled_by = current_user.id\n    \n    db.session.add(enrollment)\n    db.session.commit()\n    \n    flash(f'Participant {participant.username} enrolled in course {course.name} successfully.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/bulk-enroll-participants', methods=['POST'])\n@login_required\ndef admin_bulk_enroll_participants(course_id):\n    \"\"\"Bulk enroll multiple participants in course\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    course = Course.query.get_or_404(course_id)\n    participant_ids = request.form.getlist('participant_ids')\n    \n    # DEBUG: Log what we're receiving\n    import logging\n    logging.basicConfig(level=logging.DEBUG)\n    logger = logging.getLogger(__name__)\n    logger.debug(f\"üîç BULK ENROLL DEBUG - Course: {course.name} (ID: {course_id})\")\n    logger.debug(f\"üîç Form data keys: {list(request.form.keys())}\")\n    logger.debug(f\"üîç All form data: {dict(request.form)}\")\n    logger.debug(f\"üîç participant_ids received: {participant_ids}\")\n    logger.debug(f\"üîç Number of participant_ids: {len(participant_ids)}\")\n    \n    print(f\"üîç BULK ENROLL - Course: {course.name}, participant_ids: {participant_ids}, count: {len(participant_ids)}\")\n    \n    if not participant_ids:\n        flash('Please select participants to enroll.', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    # Check current enrollment count\n    current_enrollments = len(course.participant_enrollments)\n    available_spots = course.max_participants - current_enrollments\n    \n    if available_spots <= 0:\n        flash(f'Course {course.name} has reached maximum participant limit ({course.max_participants}).', 'error')\n        return redirect(url_for('admin_course_management'))\n    \n    # Limit enrollments to available spots\n    if len(participant_ids) > available_spots:\n        flash(f'Only {available_spots} spots available in course {course.name}. Limiting enrollment to first {available_spots} selected participants.', 'warning')\n        participant_ids = participant_ids[:available_spots]\n    \n    enrolled_count = 0\n    errors = []\n    \n    # Process participants in small batches to prevent timeouts\n    batch_size = 5  # Process 5 participants at a time\n    total_participants = len(participant_ids)\n    \n    for batch_start in range(0, total_participants, batch_size):\n        batch_end = min(batch_start + batch_size, total_participants)\n        batch_ids = participant_ids[batch_start:batch_end]\n        \n        try:\n            # Process current batch\n            for participant_id in batch_ids:\n                try:\n                    participant_id = int(participant_id)\n                    participant = User.query.get(participant_id)\n                    \n                    if not participant:\n                        errors.append(f'Participant with ID {participant_id} not found.')\n                        continue\n                    \n                    if participant.role != 'participant':\n                        errors.append(f'User {participant.username} is not a participant.')\n                        continue\n                    \n                    # Check if already enrolled\n                    existing = ParticipantEnrollment.query.filter_by(\n                        participant_id=participant_id, course_id=course_id\n                    ).first()\n                    \n                    if existing:\n                        errors.append(f'Participant {participant.username} is already enrolled in this course.')\n                        continue\n                    \n                    # Create enrollment\n                    enrollment = ParticipantEnrollment()\n                    enrollment.participant_id = participant_id\n                    enrollment.course_id = course_id\n                    enrollment.enrolled_by = current_user.id\n                    \n                    db.session.add(enrollment)\n                    enrolled_count += 1\n                    \n                except ValueError:\n                    errors.append(f'Invalid participant ID: {participant_id}')\n                except Exception as e:\n                    errors.append(f'Error enrolling participant {participant_id}: {str(e)}')\n            \n            # Commit each batch to prevent timeouts\n            try:\n                db.session.commit()\n                \n                # Add small delay between batches to prevent overwhelming the database\n                if batch_end < total_participants:  # Not the last batch\n                    import time\n                    time.sleep(0.1)\n                    \n            except Exception as batch_error:\n                db.session.rollback()\n                errors.append(f'Batch {batch_start//batch_size + 1}: Database error - {str(batch_error)}')\n                \n        except Exception as batch_exception:\n            db.session.rollback()\n            errors.append(f'Batch {batch_start//batch_size + 1}: Processing error - {str(batch_exception)}')\n    \n    # Final status messages\n    if enrolled_count > 0:\n        flash(f'Successfully enrolled {enrolled_count} participants in course {course.name}.', 'success')\n    if errors:\n        flash(f'Errors encountered: {\"; \".join(errors[:3])}{\"...\" if len(errors) > 3 else \"\"}', 'warning')\n    \n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/remove-host/<int:host_id>', methods=['POST'])\n@login_required\ndef admin_remove_host_from_course(course_id, host_id):\n    \"\"\"Remove host from course\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    assignment = HostCourseAssignment.query.filter_by(host_id=host_id, course_id=course_id).first_or_404()\n    host_name = assignment.host.username\n    course_name = assignment.course.name\n    \n    db.session.delete(assignment)\n    db.session.commit()\n    \n    flash(f'Host {host_name} removed from course {course_name}.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/remove-participant/<int:participant_id>', methods=['POST'])\n@login_required\ndef admin_remove_participant_from_course(course_id, participant_id):\n    \"\"\"Remove participant from course\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    enrollment = ParticipantEnrollment.query.filter_by(participant_id=participant_id, course_id=course_id).first_or_404()\n    participant_name = enrollment.participant.username\n    course_name = enrollment.course.name\n    \n    db.session.delete(enrollment)\n    db.session.commit()\n    \n    flash(f'Participant {participant_name} removed from course {course_name}.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/toggle-status', methods=['POST'])\n@login_required\ndef admin_toggle_course_status(course_id):\n    \"\"\"Toggle course active status\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    course = Course.query.get_or_404(course_id)\n    course.is_active = not course.is_active\n    db.session.commit()\n    \n    status = 'activated' if course.is_active else 'deactivated'\n    flash(f'Course \"{course.name}\" has been {status}.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/admin/course/<int:course_id>/delete', methods=['POST'])\n@login_required\ndef admin_delete_course(course_id):\n    \"\"\"Delete course and all related data\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    course = Course.query.get_or_404(course_id)\n    course_name = course.name\n    \n    # Delete all related data\n    HostCourseAssignment.query.filter_by(course_id=course_id).delete()\n    ParticipantEnrollment.query.filter_by(course_id=course_id).delete()\n    \n    # Remove course association from quizzes (don't delete quizzes)\n    quizzes = Quiz.query.filter_by(course_id=course_id).all()\n    for quiz in quizzes:\n        quiz.course_id = None\n    \n    db.session.delete(course)\n    db.session.commit()\n    \n    flash(f'Course \"{course_name}\" has been permanently deleted.', 'success')\n    return redirect(url_for('admin_course_management'))\n\n@app.route('/api/quiz/<int:quiz_id>/stats')\n@login_required\ndef get_quiz_stats(quiz_id):\n    \"\"\"Get quiz statistics for admin\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    quiz = Quiz.query.get_or_404(quiz_id)\n    attempts = QuizAttempt.query.filter_by(quiz_id=quiz_id).all()\n    violations = ProctoringEvent.query.join(QuizAttempt).filter(QuizAttempt.quiz_id == quiz_id).all()\n    \n    completed_attempts = [a for a in attempts if a.status == 'completed']\n    terminated_attempts = [a for a in attempts if a.status == 'terminated']\n    \n    stats = {\n        'total_attempts': len(attempts),\n        'completed_attempts': len(completed_attempts),\n        'terminated_attempts': len(terminated_attempts),\n        'total_violations': len(violations),\n        'average_score': sum([a.score for a in completed_attempts if a.score]) / len(completed_attempts) if completed_attempts else 0,\n        'highest_score': max([a.score for a in completed_attempts if a.score]) if completed_attempts else 0,\n        'common_violation': violations[0].event_type.replace('_', ' ').title() if violations else 'None'\n    }\n    \n    return jsonify(stats)\n\n@app.route('/api/violations/count')\n@login_required\ndef get_violations_count():\n    \"\"\"Get total violation count for admin dashboard\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    count = ProctoringEvent.query.count()\n    return jsonify({'count': count})\n\n\n@app.route('/api/export-logs')\n@login_required  \ndef export_logs():\n    \"\"\"Export audit logs to CSV\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    import csv\n    import io\n    from flask import make_response\n    \n    output = io.StringIO()\n    writer = csv.writer(output)\n    \n    # Write headers\n    writer.writerow(['Date', 'User', 'Quiz', 'Action', 'Status', 'Score', 'Violations'])\n    \n    # Write data\n    attempts = QuizAttempt.query.order_by(QuizAttempt.started_at.desc()).all()\n    for attempt in attempts:\n        writer.writerow([\n            attempt.started_at.strftime('%Y-%m-%d %H:%M:%S') if attempt.started_at else 'N/A',\n            attempt.participant.username,\n            attempt.quiz.title,\n            'Quiz Attempt',\n            attempt.status,\n            f\"{attempt.score:.1f}%\" if attempt.score else 'N/A',\n            len(attempt.answers) if hasattr(attempt, 'answers') else 0\n        ])\n    \n    response = make_response(output.getvalue())\n    response.headers['Content-Type'] = 'text/csv'\n    response.headers['Content-Disposition'] = 'attachment; filename=audit_logs.csv'\n    \n    return response\n\n@app.route('/api/export-users')\n@login_required  \ndef export_users():\n    \"\"\"Export user data to CSV\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    import csv\n    import io\n    from flask import make_response\n    \n    output = io.StringIO()\n    writer = csv.writer(output)\n    \n    # Write headers\n    writer.writerow(['Username', 'Email', 'Role', 'Status', 'Verified', 'Registered', 'Last Login'])\n    \n    # Write data\n    users = User.query.order_by(User.created_at.desc()).all()\n    for user in users:\n        writer.writerow([\n            user.username,\n            user.email,\n            user.role,\n            'Active' if user.is_verified else 'Inactive',\n            'Yes' if user.is_verified else 'No',\n            user.created_at.strftime('%Y-%m-%d %H:%M:%S') if user.created_at else 'N/A',\n            user.last_login.strftime('%Y-%m-%d %H:%M:%S') if user.last_login else 'Never'\n        ])\n    \n    response = make_response(output.getvalue())\n    response.headers['Content-Type'] = 'text/csv'\n    response.headers['Content-Disposition'] = 'attachment; filename=users_export.csv'\n    \n    return response\n\n# Enhanced Proctoring System API\n@app.route('/api/proctoring/violation', methods=['POST'])\n@login_required\ndef record_enhanced_violation():\n    \"\"\"Enhanced proctoring violation endpoint for new security system\"\"\"\n    try:\n        data = request.get_json()\n        \n        # Validate required fields\n        required_fields = ['attemptId', 'type', 'severity', 'description']\n        for field in required_fields:\n            if field not in data:\n                return jsonify({'error': f'Missing required field: {field}'}), 400\n        \n        # Get attempt and verify ownership\n        attempt = QuizAttempt.query.get(data['attemptId'])\n        if not attempt:\n            return jsonify({'error': 'Attempt not found'}), 404\n            \n        if attempt.participant_id != current_user.id:\n            return jsonify({'error': 'Access denied'}), 403\n        \n        # Create proctoring event\n        event = ProctoringEvent(\n            attempt_id=data['attemptId'],\n            event_type=data['type'],\n            details=data['description'],\n            severity=data['severity'],\n            timestamp=datetime.utcnow()\n        )\n        \n        db.session.add(event)\n        \n        # Check for termination conditions\n        violation_count = ProctoringEvent.query.filter_by(attempt_id=data['attemptId']).count() + 1\n        critical_count = ProctoringEvent.query.filter_by(\n            attempt_id=data['attemptId'], \n            severity='critical'\n        ).count()\n        \n        if data['severity'] == 'critical':\n            critical_count += 1\n        \n        should_terminate = (\n            critical_count >= 1 or\n            violation_count >= 3 or\n            data['type'] in ['multiple_people', 'camera_disabled', 'tab_switch']\n        )\n        \n        if should_terminate:\n            attempt.status = 'terminated'\n            attempt.completed_at = datetime.utcnow()\n        \n        db.session.commit()\n        \n        return jsonify({\n            'message': 'Enhanced violation recorded successfully',\n            'id': event.id,\n            'should_terminate': should_terminate,\n            'violation_count': violation_count\n        }), 201\n        \n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Failed to record enhanced violation: {e}\")\n        return jsonify({'error': 'Failed to record violation'}), 500\n\n@app.route('/api/proctoring/mark-malpractice', methods=['POST'])\n@login_required\ndef mark_malpractice():\n    \"\"\"Mark user as malpractice and handle immediate termination\"\"\"\n    try:\n        data = request.get_json()\n        \n        attempt_id = data.get('attemptId')\n        quiz_id = data.get('quizId')\n        violation = data.get('violation', {})\n        \n        if not attempt_id:\n            return jsonify({'error': 'Attempt ID required'}), 400\n        \n        # Get attempt and verify ownership\n        attempt = QuizAttempt.query.get(attempt_id)\n        if not attempt or attempt.participant_id != current_user.id:\n            return jsonify({'error': 'Access denied'}), 403\n        \n        # Mark attempt as terminated with malpractice flag\n        attempt.status = 'terminated'\n        attempt.completed_at = datetime.utcnow()\n        attempt.termination_reason = f\"Malpractice: {violation.get('description', 'Critical violation detected')}\"\n        attempt.is_flagged = True\n        \n        # Create or update user violation record\n        user_violation = UserViolation.query.filter_by(user_id=current_user.id).first()\n        if not user_violation:\n            user_violation = UserViolation(user_id=current_user.id)\n            db.session.add(user_violation)\n        \n        user_violation.is_flagged = True\n        user_violation.flagged_at = datetime.utcnow()\n        user_violation.flagged_by = None  # System flagged\n        \n        # Create security alert\n        alert = SecurityAlert(\n            user_id=current_user.id,\n            quiz_id=quiz_id,\n            attempt_id=attempt_id,\n            alert_type='immediate_malpractice',\n            severity='critical',\n            description=f\"Immediate malpractice detected: {violation.get('description', 'Unknown')}\",\n            auto_action_taken='quiz_terminated_malpractice'\n        )\n        db.session.add(alert)\n        \n        # Log the malpractice event\n        event = ProctoringEvent(\n            attempt_id=attempt_id,\n            event_type='malpractice_marked',\n            details=f\"User marked as malpractice: {violation.get('description', 'Critical violation')}\",\n            severity='critical',\n            timestamp=datetime.utcnow()\n        )\n        db.session.add(event)\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'message': 'User marked as malpractice successfully',\n            'attempt_terminated': True\n        }), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Failed to mark malpractice: {e}\")\n        return jsonify({'error': 'Failed to mark malpractice'}), 500\n\n@app.route('/api/proctoring/notify-participants', methods=['POST'])\n@login_required\ndef notify_participants():\n    \"\"\"Notify other participants about malpractice detection\"\"\"\n    try:\n        data = request.get_json()\n        \n        quiz_id = data.get('quizId')\n        message = data.get('message', 'A participant has been terminated for malpractice.')\n        \n        if not quiz_id:\n            return jsonify({'error': 'Quiz ID required'}), 400\n        \n        # Get all participants in this quiz (except current user)\n        quiz = Quiz.query.get_or_404(quiz_id)\n        participants = QuizAttempt.query.filter(\n            QuizAttempt.quiz_id == quiz_id,\n            QuizAttempt.participant_id != current_user.id,\n            QuizAttempt.status.in_(['in_progress', 'started'])\n        ).all()\n        \n        # Send email notifications to active participants\n        for attempt in participants:\n            try:\n                participant = attempt.participant\n                subject = f\"‚ö†Ô∏è Quiz Alert - {quiz.title}\"\n                body = f\"\"\"\n                Quiz Alert Notification\n                \n                Quiz: {quiz.title}\n                Alert: {message}\n                Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n                \n                This is an automated notification for your awareness.\n                Please continue with your quiz if it's still in progress.\n                \n                Assessment Platform\n                \"\"\"\n                \n                msg = Message(\n                    subject=subject,\n                    recipients=[participant.email],\n                    body=body\n                )\n                \n                mail.send(msg)\n                \n            except Exception as email_error:\n                logging.error(f\"Failed to send participant notification to {participant.email}: {email_error}\")\n        \n        # Log the notification event\n        event = ProctoringEvent(\n            attempt_id=None,  # System-wide notification\n            event_type='participant_notification_sent',\n            details=f\"Malpractice alert sent to {len(participants)} participants\",\n            severity='medium',\n            timestamp=datetime.utcnow()\n        )\n        db.session.add(event)\n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'message': f'Notifications sent to {len(participants)} participants'\n        }), 200\n        \n    except Exception as e:\n        logging.error(f\"Failed to send participant notifications: {e}\")\n        return jsonify({'error': 'Failed to send notifications'}), 500\n\n@app.route('/api/quiz/force-submit', methods=['POST'])\n@login_required\ndef force_submit_quiz():\n    \"\"\"Force submit quiz due to malpractice\"\"\"\n    try:\n        data = request.get_json()\n        \n        # Find the current user's active quiz attempt\n        attempt = QuizAttempt.query.filter_by(\n            participant_id=current_user.id,\n            status='in_progress'\n        ).first()\n        \n        if not attempt:\n            return jsonify({'error': 'No active quiz attempt found'}), 404\n        \n        # Force submit the attempt\n        attempt.status = 'submitted'\n        attempt.completed_at = datetime.utcnow()\n        attempt.force_submitted = True\n        attempt.termination_reason = data.get('reason', 'Malpractice detected')\n        \n        # Calculate score with current answers (if any)\n        total_questions = len(attempt.quiz.questions)\n        answered_questions = Answer.query.filter_by(attempt_id=attempt.id).count()\n        \n        if total_questions > 0:\n            attempt.score = (answered_questions / total_questions) * 100\n        else:\n            attempt.score = 0\n        \n        # Log the force submission\n        event = ProctoringEvent(\n            attempt_id=attempt.id,\n            event_type='force_submitted',\n            details=f\"Quiz force submitted: {data.get('reason', 'Malpractice detected')}\",\n            severity='critical',\n            timestamp=datetime.utcnow()\n        )\n        db.session.add(event)\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'message': 'Quiz force submitted successfully',\n            'score': attempt.score\n        }), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Failed to force submit quiz: {e}\")\n        return jsonify({'error': 'Failed to force submit quiz'}), 500\n\n# Host Heatmap Dashboard Route\n@app.route('/host/heatmap-dashboard')\n@login_required\ndef host_heatmap_dashboard():\n    \"\"\"Host collaboration heatmap dashboard\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied. Host privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    # Get quizzes created by the current host (or all if admin)\n    if current_user.is_admin():\n        quizzes = Quiz.query.filter_by(is_deleted=False).order_by(Quiz.created_at.desc()).all()\n    else:\n        quizzes = Quiz.query.filter_by(\n            creator_id=current_user.id,\n            is_deleted=False\n        ).order_by(Quiz.created_at.desc()).all()\n    \n    # Get selected quiz if specified\n    selected_quiz_id = request.args.get('quiz_id')\n    selected_quiz = None\n    if selected_quiz_id:\n        selected_quiz = Quiz.query.get(selected_quiz_id)\n        # Verify access to selected quiz\n        if selected_quiz and not current_user.is_admin() and selected_quiz.creator_id != current_user.id:\n            selected_quiz = None\n    \n    # Add attempt counts to quizzes\n    for quiz in quizzes:\n        quiz.attempts = QuizAttempt.query.filter_by(quiz_id=quiz.id).all()\n    \n    return render_template('host_heatmap_dashboard.html',\n                         quizzes=quizzes,\n                         selected_quiz=selected_quiz)\n\n@app.route('/help')\ndef help_page():\n    \"\"\"Comprehensive help and documentation page\"\"\"\n    return render_template('help.html')\n\n# Drag-and-Drop API Endpoints\n@app.route('/api/reorder-courses', methods=['POST'])\n@login_required\ndef api_reorder_courses():\n    \"\"\"API endpoint to handle course reordering via drag-and-drop\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'message': 'Unauthorized access'}), 403\n    \n    try:\n        data = request.get_json()\n        course_ids = data.get('course_ids', [])\n        \n        if not course_ids:\n            return jsonify({'success': False, 'message': 'No course IDs provided'}), 400\n        \n        # Update display_order for each course\n        for index, course_id in enumerate(course_ids):\n            course = Course.query.get(course_id)\n            if course:\n                course.display_order = index\n        \n        db.session.commit()\n        return jsonify({'success': True, 'message': 'Course order updated successfully'})\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'message': f'Error updating course order: {str(e)}'}), 500\n\n@app.route('/api/reorder-quizzes', methods=['POST'])\n@login_required\ndef api_reorder_quizzes():\n    \"\"\"API endpoint to handle quiz reordering via drag-and-drop\"\"\"\n    if not (current_user.is_admin() or current_user.is_host()):\n        return jsonify({'success': False, 'message': 'Unauthorized access'}), 403\n    \n    try:\n        data = request.get_json()\n        quiz_ids = data.get('quiz_ids', [])\n        course_id = data.get('course_id')\n        \n        if not quiz_ids:\n            return jsonify({'success': False, 'message': 'No quiz IDs provided'}), 400\n        \n        # Update display_order for each quiz\n        for index, quiz_id in enumerate(quiz_ids):\n            quiz = Quiz.query.get(quiz_id)\n            if quiz:\n                # Verify user has permission to modify this quiz\n                if not current_user.is_admin() and quiz.creator_id != current_user.id:\n                    return jsonify({'success': False, 'message': 'Unauthorized to modify this quiz'}), 403\n                quiz.display_order = index\n        \n        db.session.commit()\n        return jsonify({'success': True, 'message': 'Quiz order updated successfully'})\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'message': f'Error updating quiz order: {str(e)}'}), 500\n\n# RBAC Admin Routes - Role and Permission Management\n\n@app.route('/admin/rbac')\n@login_required\ndef admin_rbac_dashboard():\n    \"\"\"RBAC management dashboard\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    roles = Role.query.order_by(Role.created_at.desc()).all()\n    permissions = Permission.query.order_by(Permission.category, Permission.name).all()\n    \n    # Group permissions by category\n    permissions_by_category = {}\n    for permission in permissions:\n        category = permission.category\n        if category not in permissions_by_category:\n            permissions_by_category[category] = []\n        permissions_by_category[category].append(permission)\n    \n    # Get recent audit logs\n    recent_logs = RoleAuditLog.query.order_by(RoleAuditLog.created_at.desc()).limit(10).all()\n    \n    # Statistics\n    stats = {\n        'total_roles': len(roles),\n        'total_permissions': len(permissions),\n        'active_roles': len([r for r in roles if r.is_active]),\n        'system_roles': len([r for r in roles if r.is_system_role]),\n        'total_users_with_roles': UserRole.query.filter_by(is_active=True).count()\n    }\n    \n    return render_template('admin_rbac_dashboard.html',\n                         roles=roles,\n                         permissions_by_category=permissions_by_category,\n                         recent_logs=recent_logs,\n                         stats=stats)\n\n@app.route('/admin/rbac/roles')\n@login_required\ndef admin_rbac_roles():\n    \"\"\"Role management interface\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    roles = Role.query.order_by(Role.created_at.desc()).all()\n    permissions = Permission.query.order_by(Permission.category, Permission.name).all()\n    \n    # Add user count and permission details to each role\n    for role in roles:\n        role.active_users = UserRole.query.filter_by(role_id=role.id, is_active=True).count()\n        role.permission_details = [rp.permission for rp in role.role_permissions]\n    \n    return render_template('admin_rbac_roles.html', roles=roles, permissions=permissions)\n\n@app.route('/admin/rbac/permissions')\n@login_required\ndef admin_rbac_permissions():\n    \"\"\"Permission management interface\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    permissions = Permission.query.order_by(Permission.category, Permission.name).all()\n    \n    # Group by category\n    permissions_by_category = {}\n    for permission in permissions:\n        category = permission.category\n        if category not in permissions_by_category:\n            permissions_by_category[category] = []\n        permissions_by_category[category].append(permission)\n    \n    return render_template('admin_rbac_permissions.html', \n                         permissions_by_category=permissions_by_category)\n\n@app.route('/admin/rbac/user-assignments')\n@login_required\ndef admin_rbac_user_assignments():\n    \"\"\"User role assignment interface\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    users = User.query.order_by(User.username).all()\n    roles = Role.query.filter_by(is_active=True).order_by(Role.name).all()\n    \n    # Get current assignments\n    assignments = UserRole.query.filter_by(is_active=True).all()\n    user_assignments = {}\n    for assignment in assignments:\n        if assignment.user_id not in user_assignments:\n            user_assignments[assignment.user_id] = []\n        user_assignments[assignment.user_id].append(assignment)\n    \n    return render_template('admin_rbac_user_assignments.html',\n                         users=users,\n                         roles=roles,\n                         user_assignments=user_assignments)\n\n@app.route('/admin/rbac/audit-logs')\n@login_required\ndef admin_rbac_audit_logs():\n    \"\"\"RBAC audit log viewer\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied. Administrator privileges required.', 'error')\n        return redirect(url_for('dashboard'))\n    \n    page = request.args.get('page', 1, type=int)\n    entity_type = request.args.get('entity_type', '')\n    action = request.args.get('action', '')\n    \n    query = RoleAuditLog.query\n    \n    if entity_type:\n        query = query.filter_by(entity_type=entity_type)\n    if action:\n        query = query.filter_by(action=action)\n    \n    logs = query.order_by(RoleAuditLog.created_at.desc()).paginate(\n        page=page, per_page=50, error_out=False\n    )\n    \n    return render_template('admin_rbac_audit_logs.html', logs=logs, \n                         entity_type=entity_type, action=action)\n\n# RBAC API Endpoints\n\n@app.route('/api/rbac/role', methods=['POST'])\n@login_required\ndef api_create_role():\n    \"\"\"Create a new role\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        \n        role = RBACService.create_role(\n            name=data['name'],\n            display_name=data['display_name'],\n            description=data.get('description', ''),\n            permission_names=data.get('permissions', []),\n            created_by_user_id=current_user.id\n        )\n        \n        return jsonify({\n            'success': True,\n            'message': f'Role \"{role.display_name}\" created successfully',\n            'role_id': role.id\n        })\n    \n    except ValueError as e:\n        return jsonify({'success': False, 'error': str(e)}), 400\n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to create role'}), 500\n\n@app.route('/api/rbac/role/<int:role_id>', methods=['PUT'])\n@login_required\ndef api_update_role(role_id):\n    \"\"\"Update an existing role\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        data['updated_by'] = current_user.id\n        \n        role = RBACService.update_role(role_id, **data)\n        \n        return jsonify({\n            'success': True,\n            'message': f'Role \"{role.display_name}\" updated successfully'\n        })\n    \n    except ValueError as e:\n        return jsonify({'success': False, 'error': str(e)}), 400\n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to update role'}), 500\n\n@app.route('/api/rbac/role/<int:role_id>', methods=['DELETE'])\n@login_required\ndef api_delete_role(role_id):\n    \"\"\"Delete a role\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        RBACService.delete_role(role_id, current_user.id)\n        \n        return jsonify({\n            'success': True,\n            'message': 'Role deleted successfully'\n        })\n    \n    except ValueError as e:\n        return jsonify({'success': False, 'error': str(e)}), 400\n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to delete role'}), 500\n\n@app.route('/api/rbac/assign-role', methods=['POST'])\n@login_required\ndef api_assign_role():\n    \"\"\"Assign role to user\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        \n        expires_at = None\n        if data.get('expires_at'):\n            expires_at = datetime.fromisoformat(data['expires_at'])\n        \n        user_role = RBACService.assign_role_to_user(\n            user_id=data['user_id'],\n            role_name=data['role_name'],\n            assigned_by_user_id=current_user.id,\n            expires_at=expires_at\n        )\n        \n        return jsonify({\n            'success': True,\n            'message': f'Role assigned successfully'\n        })\n    \n    except ValueError as e:\n        return jsonify({'success': False, 'error': str(e)}), 400\n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to assign role'}), 500\n\n@app.route('/api/rbac/revoke-role', methods=['POST'])\n@login_required\ndef api_revoke_role():\n    \"\"\"Revoke role from user\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        \n        RBACService.revoke_role_from_user(\n            user_id=data['user_id'],\n            role_name=data['role_name'],\n            revoked_by_user_id=current_user.id\n        )\n        \n        return jsonify({\n            'success': True,\n            'message': 'Role revoked successfully'\n        })\n    \n    except ValueError as e:\n        return jsonify({'success': False, 'error': str(e)}), 400\n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to revoke role'}), 500\n\n@app.route('/api/rbac/role/<int:role_id>/permissions', methods=['PUT'])\n@login_required\ndef api_update_role_permissions(role_id):\n    \"\"\"Update role permissions\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        role = Role.query.get_or_404(role_id)\n        \n        # Clear existing permissions\n        RolePermission.query.filter_by(role_id=role_id).delete()\n        \n        # Add new permissions\n        for perm_name in data['permissions']:\n            permission = Permission.query.filter_by(name=perm_name).first()\n            if permission:\n                role_permission = RolePermission(\n                    role_id=role_id,\n                    permission_id=permission.id,\n                    granted_by=current_user.id\n                )\n                db.session.add(role_permission)\n        \n        # Create audit log\n        RBACService._create_audit_log(\n            action='update_permissions',\n            entity_type='role',\n            entity_id=role_id,\n            performed_by=current_user.id,\n            new_values=json.dumps({'permissions': data['permissions']})\n        )\n        \n        db.session.commit()\n        \n        return jsonify({\n            'success': True,\n            'message': f'Permissions updated for role \"{role.display_name}\"'\n        })\n    \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'success': False, 'error': 'Failed to update permissions'}), 500\n\n@app.route('/api/rbac/bulk-assign', methods=['POST'])\n@login_required\ndef api_bulk_assign_roles():\n    \"\"\"Bulk assign roles to multiple users\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        \n        results = RBACService.bulk_assign_roles(\n            user_ids=data['user_ids'],\n            role_names=data['role_names'],\n            assigned_by_user_id=current_user.id\n        )\n        \n        successful = len([r for r in results if r['success']])\n        total = len(results)\n        \n        return jsonify({\n            'success': True,\n            'message': f'Bulk assignment completed: {successful}/{total} successful',\n            'results': results\n        })\n    \n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to perform bulk assignment'}), 500\n\n@app.route('/api/rbac/initialize', methods=['POST'])\n@login_required\ndef api_initialize_rbac():\n    \"\"\"Initialize RBAC system with default roles and permissions\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'success': False, 'error': 'Access denied'}), 403\n    \n    try:\n        if initialize_rbac_system:\n            result = initialize_rbac_system()\n            return jsonify({\n                'success': True,\n                'message': 'RBAC system initialized successfully',\n                'permissions_created': result['permissions_created'],\n                'roles_created': result['roles_created']\n            })\n        else:\n            return jsonify({'success': False, 'error': 'RBAC system not available'}), 500\n    \n    except Exception as e:\n        return jsonify({'success': False, 'error': 'Failed to initialize RBAC system'}), 500\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found_error(error):\n    return render_template('404.html'), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    db.session.rollback()\n    return render_template('500.html'), 500\n\n# ===== LTI (Learning Tools Interoperability) Integration =====\n\n@app.route('/lti/launch', methods=['POST'])\ndef lti_launch():\n    \"\"\"LTI 1.1 Launch endpoint - receives launches from LMS\"\"\"\n    try:\n        logging.info(f\"LTI Launch request received from {request.remote_addr}\")\n        logging.debug(f\"LTI Launch parameters: {request.form.to_dict()}\")\n        \n        # Get LTI provider instance\n        lti_provider = get_lti_provider()\n        \n        # Validate OAuth signature\n        if not lti_provider.validate_signature(request.form.to_dict()):\n            logging.warning(\"LTI signature validation failed\")\n            flash('LTI authentication failed. Please contact your administrator.', 'error')\n            return redirect(url_for('home'))\n        \n        # Process launch request\n        success, lti_data = lti_provider.process_launch_request(request.form.to_dict())\n        \n        if not success:\n            logging.error(f\"LTI launch processing failed: {lti_data.get('error')}\")\n            flash(f'LTI launch failed: {lti_data.get(\"error\")}', 'error')\n            return redirect(url_for('home'))\n        \n        # Create or update user from LTI data\n        user = LTIUser.create_or_update_user(lti_data)\n        \n        if not user:\n            logging.error(\"Failed to create/update LTI user\")\n            flash('Failed to create user account from LTI launch.', 'error')\n            return redirect(url_for('home'))\n        \n        # Update user with LTI context information\n        context_info = lti_data.get('context_info', {})\n        grade_info = lti_data.get('grade_info', {})\n        \n        user.lti_consumer_key = request.form.get('oauth_consumer_key')\n        user.lti_context_id = context_info.get('course_id')\n        user.lti_resource_link_id = context_info.get('resource_link_id')\n        user.lti_grade_passback_url = grade_info.get('lis_outcome_service_url')\n        user.lti_result_sourcedid = grade_info.get('lis_result_sourcedid')\n        \n        db.session.commit()\n        \n        # Log the user in\n        login_user(user, remember=True)\n        session['lti_launch'] = True\n        session['lti_data'] = lti_data\n        \n        # Check for custom quiz parameter\n        custom_quiz_id = request.form.get('custom_quiz_id')\n        \n        if custom_quiz_id:\n            # Direct launch to specific quiz\n            try:\n                quiz_id = int(custom_quiz_id)\n                quiz = Quiz.query.get(quiz_id)\n                if quiz and quiz.is_active:\n                    return redirect(url_for('take_quiz', quiz_id=quiz_id))\n                else:\n                    flash('Requested quiz not found or inactive.', 'warning')\n            except (ValueError, TypeError):\n                flash('Invalid quiz identifier.', 'warning')\n        \n        # Redirect based on user role\n        if user.is_admin():\n            return redirect(url_for('admin_dashboard'))\n        elif user.is_host():\n            return redirect(url_for('host_dashboard'))\n        else:\n            return redirect(url_for('participant_dashboard'))\n        \n    except Exception as e:\n        logging.error(f\"LTI launch error: {e}\")\n        flash('An error occurred during LTI launch. Please try again.', 'error')\n        return redirect(url_for('home'))\n\n@app.route('/lti/config.xml')\ndef lti_config_xml():\n    \"\"\"LTI Tool Configuration XML for LMS setup\"\"\"\n    base_url = request.url_root.rstrip('/')\n    consumer_key = \"bigbossizzz_lti_key\"  # Should be configurable\n    \n    xml_config = LTIToolConfiguration.generate_xml_config(base_url, consumer_key)\n    \n    response = make_response(xml_config)\n    response.headers['Content-Type'] = 'application/xml'\n    response.headers['Content-Disposition'] = 'attachment; filename=bigbossizzz_lti_config.xml'\n    \n    return response\n\n@app.route('/lti/config.json')\ndef lti_config_json():\n    \"\"\"LTI 1.3 Tool Configuration JSON for LMS setup\"\"\"\n    base_url = request.url_root.rstrip('/')\n    consumer_key = \"bigbossizzz_lti_key\"\n    \n    json_config = LTIToolConfiguration.generate_json_config(base_url, consumer_key)\n    \n    return jsonify(json_config)\n\n@app.route('/lti/admin')\n@login_required\ndef lti_admin():\n    \"\"\"LTI Administration dashboard\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('home'))\n    \n    # Get LTI user statistics\n    lti_users = User.query.filter(User.lti_user_id.isnot(None)).all()\n    lti_stats = {\n        'total_lti_users': len(lti_users),\n        'lti_participants': len([u for u in lti_users if u.role == 'participant']),\n        'lti_hosts': len([u for u in lti_users if u.role == 'host']),\n        'lti_admins': len([u for u in lti_users if u.role == 'admin']),\n        'unique_contexts': len(set([u.lti_context_id for u in lti_users if u.lti_context_id])),\n        'unique_consumers': len(set([u.lti_consumer_key for u in lti_users if u.lti_consumer_key]))\n    }\n    \n    # Get recent LTI launches (from session logs)\n    recent_launches = []\n    try:\n        for user in lti_users[:10]:  # Show last 10 LTI users\n            recent_launches.append({\n                'user': user,\n                'context_id': user.lti_context_id,\n                'consumer_key': user.lti_consumer_key,\n                'last_login': user.last_login\n            })\n    except Exception as e:\n        logging.error(f\"Error getting LTI launch data: {e}\")\n    \n    return render_template('admin_lti.html', \n                         lti_stats=lti_stats,\n                         recent_launches=recent_launches,\n                         base_url=request.url_root.rstrip('/'))\n\n@app.route('/api/lti/grade-passback', methods=['POST'])\n@login_required\ndef lti_grade_passback():\n    \"\"\"Send grade back to LMS for completed quiz attempts\"\"\"\n    try:\n        data = request.get_json()\n        attempt_id = data.get('attempt_id')\n        \n        if not attempt_id:\n            return jsonify({'success': False, 'error': 'Missing attempt_id'}), 400\n        \n        # Get quiz attempt\n        attempt = QuizAttempt.query.get(attempt_id)\n        if not attempt:\n            return jsonify({'success': False, 'error': 'Quiz attempt not found'}), 404\n        \n        # Check if user has LTI grade passback information\n        user = attempt.participant\n        if not user.lti_grade_passback_url or not user.lti_result_sourcedid:\n            return jsonify({'success': False, 'error': 'No LTI grade passback information available'}), 400\n        \n        # Calculate score\n        if attempt.score is None:\n            attempt.calculate_score()\n            db.session.commit()\n        \n        # Prepare grade information\n        grade_info = {\n            'lis_outcome_service_url': user.lti_grade_passback_url,\n            'lis_result_sourcedid': user.lti_result_sourcedid\n        }\n        \n        # Send grade back to LMS\n        grade_passback = get_lti_grade_passback()\n        success = grade_passback.send_grade(grade_info, attempt.score, 100.0)\n        \n        if success:\n            # Log successful grade passback\n            logging.info(f\"Grade passback successful for attempt {attempt_id}: {attempt.score}%\")\n            return jsonify({'success': True, 'message': 'Grade sent to LMS successfully'})\n        else:\n            logging.error(f\"Grade passback failed for attempt {attempt_id}\")\n            return jsonify({'success': False, 'error': 'Failed to send grade to LMS'}), 500\n        \n    except Exception as e:\n        logging.error(f\"Grade passback error: {e}\")\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@app.route('/lti/quiz-selection')\n@login_required\ndef lti_quiz_selection():\n    \"\"\"Quiz selection page for LTI content selection\"\"\"\n    if not current_user.is_host() and not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('home'))\n    \n    # Get available quizzes for selection\n    if current_user.is_admin():\n        quizzes = Quiz.query.filter_by(is_active=True).all()\n    else:\n        quizzes = Quiz.query.filter_by(creator_id=current_user.id, is_active=True).all()\n    \n    # Check if this is a content selection request\n    is_content_selection = request.args.get('lti_message_type') == 'ContentItemSelectionRequest'\n    return_url = request.args.get('content_item_return_url')\n    \n    return render_template('lti_quiz_selection.html',\n                         quizzes=quizzes,\n                         is_content_selection=is_content_selection,\n                         return_url=return_url)\n\n@app.route('/api/lti/content-item', methods=['POST'])\n@login_required\ndef lti_content_item():\n    \"\"\"Return content item for LTI Deep Linking\"\"\"\n    try:\n        data = request.get_json()\n        quiz_id = data.get('quiz_id')\n        return_url = data.get('return_url')\n        \n        if not quiz_id or not return_url:\n            return jsonify({'success': False, 'error': 'Missing required parameters'}), 400\n        \n        quiz = Quiz.query.get(quiz_id)\n        if not quiz:\n            return jsonify({'success': False, 'error': 'Quiz not found'}), 404\n        \n        # Check permissions\n        if not current_user.is_admin() and quiz.creator_id != current_user.id:\n            return jsonify({'success': False, 'error': 'Access denied'}), 403\n        \n        # Create content item response\n        base_url = request.url_root.rstrip('/')\n        content_item = {\n            \"@context\": \"http://purl.imsglobal.org/ctx/lti/v1/ContentItem\",\n            \"@graph\": [\n                {\n                    \"@type\": \"LtiLinkItem\",\n                    \"url\": f\"{base_url}/lti/launch?custom_quiz_id={quiz_id}\",\n                    \"title\": quiz.title,\n                    \"text\": quiz.description or f\"Take the quiz: {quiz.title}\",\n                    \"mediaType\": \"application/vnd.ims.lti.v1.ltilink\",\n                    \"placementAdvice\": {\n                        \"presentationDocumentTarget\": \"window\"\n                    },\n                    \"custom\": {\n                        \"quiz_id\": str(quiz_id)\n                    }\n                }\n            ]\n        }\n        \n        return jsonify({\n            'success': True,\n            'content_item': content_item,\n            'return_url': return_url\n        })\n        \n    except Exception as e:\n        logging.error(f\"LTI content item error: {e}\")\n        return jsonify({'success': False, 'error': str(e)}), 500\n\n@app.route('/lti/1.3/login', methods=['POST', 'GET'])\ndef lti_13_login():\n    \"\"\"LTI 1.3 OIDC Login endpoint\"\"\"\n    # LTI 1.3 implementation placeholder\n    # This would require full OAuth 2.0 / OIDC implementation\n    return jsonify({\n        'error': 'LTI 1.3 not yet implemented',\n        'message': 'Please use LTI 1.1 endpoints for now'\n    }), 501\n\n@app.route('/lti/1.3/launch', methods=['POST'])\ndef lti_13_launch():\n    \"\"\"LTI 1.3 Launch endpoint\"\"\"\n    # LTI 1.3 implementation placeholder\n    return jsonify({\n        'error': 'LTI 1.3 not yet implemented',\n        'message': 'Please use LTI 1.1 endpoints for now'\n    }), 501\n\n@app.route('/lti/1.3/jwks')\ndef lti_13_jwks():\n    \"\"\"LTI 1.3 JSON Web Key Set endpoint\"\"\"\n    # LTI 1.3 JWKS implementation placeholder\n    return jsonify({\n        'keys': []\n    })\n\n# Helper route for testing LTI integration\n@app.route('/lti/test')\ndef lti_test():\n    \"\"\"LTI Integration test page (development only)\"\"\"\n    if not app.debug:\n        return \"Not available in production\", 404\n    \n    base_url = request.url_root.rstrip('/')\n    test_data = {\n        'launch_url': f\"{base_url}/lti/launch\",\n        'config_xml_url': f\"{base_url}/lti/config.xml\",\n        'config_json_url': f\"{base_url}/lti/config.json\",\n        'consumer_key': 'bigbossizzz_lti_key',\n        'consumer_secret': 'bigbossizzz_lti_secret_change_in_production'\n    }\n    \n    return render_template('lti_test.html', test_data=test_data)\n\n# Automatic grade passback on quiz completion\n@app.after_request\ndef lti_grade_passback_trigger(response):\n    \"\"\"Automatically trigger grade passback for LTI users after quiz completion\"\"\"\n    try:\n        # Only process for quiz submission routes\n        if (request.endpoint == 'submit_quiz' and \n            response.status_code == 302 and  # Successful redirect\n            current_user.is_authenticated and \n            hasattr(current_user, 'lti_user_id') and \n            current_user.lti_user_id):\n            \n            # Get the most recent attempt for automatic grade passback\n            recent_attempt = QuizAttempt.query.filter_by(\n                participant_id=current_user.id,\n                status='completed'\n            ).order_by(QuizAttempt.completed_at.desc()).first()\n            \n            if (recent_attempt and \n                current_user.lti_grade_passback_url and \n                current_user.lti_result_sourcedid):\n                \n                # Trigger grade passback in background\n                try:\n                    grade_info = {\n                        'lis_outcome_service_url': current_user.lti_grade_passback_url,\n                        'lis_result_sourcedid': current_user.lti_result_sourcedid\n                    }\n                    \n                    grade_passback = get_lti_grade_passback()\n                    grade_passback.send_grade(grade_info, recent_attempt.score or 0, 100.0)\n                    \n                    logging.info(f\"Automatic LTI grade passback completed for attempt {recent_attempt.id}\")\n                    \n                except Exception as e:\n                    logging.error(f\"Automatic LTI grade passback failed: {e}\")\n                    \n    except Exception as e:\n        logging.error(f\"LTI grade passback trigger error: {e}\")\n    \n    return response\n\n# ===== Automated Proctoring Reports System =====\n\n@app.route('/admin/proctoring-reports')\n@login_required\ndef admin_proctoring_reports():\n    \"\"\"Proctoring reports dashboard for administrators\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('home'))\n    \n    try:\n        # Get recent report summary\n        generator = ProctoringReportGenerator()\n        end_date = datetime.utcnow()\n        start_date = end_date - timedelta(days=7)  # Last 7 days\n        \n        # Generate quick summary for dashboard\n        recent_report = generator.generate_comprehensive_report(start_date, end_date)\n        \n        # Get available quizzes for filtering\n        quizzes = Quiz.query.filter_by(is_active=True).all()\n        \n        # Get report statistics\n        report_stats = {\n            'total_attempts_last_week': len(recent_report.get('detailed_findings', {}).get('high_risk_attempts', {}).get('details', [])),\n            'integrity_score': recent_report.get('ai_analysis', {}).get('overall_integrity_score', {}).get('score', 0),\n            'critical_violations': len(recent_report.get('detailed_findings', {}).get('critical_violations', {}).get('details', [])),\n            'security_events': len(recent_report.get('detailed_findings', {}).get('security_events', {}).get('details', []))\n        }\n        \n        return render_template('admin_proctoring_reports.html',\n                             recent_report=recent_report,\n                             report_stats=report_stats,\n                             quizzes=quizzes)\n        \n    except Exception as e:\n        logging.error(f\"Error loading proctoring reports dashboard: {e}\")\n        flash('Error loading proctoring reports. Please try again.', 'error')\n        return redirect(url_for('admin_dashboard'))\n\n@app.route('/api/generate-proctoring-report', methods=['POST'])\n@login_required\ndef api_generate_proctoring_report():\n    \"\"\"Generate custom proctoring report via API\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    try:\n        data = request.get_json()\n        \n        # Parse date parameters\n        start_date_str = data.get('start_date')\n        end_date_str = data.get('end_date')\n        quiz_ids = data.get('quiz_ids', [])\n        user_ids = data.get('user_ids', [])\n        \n        if not start_date_str or not end_date_str:\n            return jsonify({'error': 'Start and end dates are required'}), 400\n        \n        # Parse dates\n        start_date = datetime.fromisoformat(start_date_str.replace('Z', '+00:00'))\n        end_date = datetime.fromisoformat(end_date_str.replace('Z', '+00:00'))\n        \n        # Validate date range\n        if start_date >= end_date:\n            return jsonify({'error': 'Start date must be before end date'}), 400\n        \n        if (end_date - start_date).days > 90:\n            return jsonify({'error': 'Date range cannot exceed 90 days'}), 400\n        \n        # Generate report\n        generator = ProctoringReportGenerator()\n        report = generator.generate_comprehensive_report(\n            start_date, end_date, quiz_ids if quiz_ids else None, user_ids if user_ids else None\n        )\n        \n        if 'error' in report:\n            return jsonify({'error': f'Report generation failed: {report[\"error\"]}'}), 500\n        \n        return jsonify({\n            'success': True,\n            'report': report,\n            'download_url': f'/api/download-report/{report[\"report_id\"]}'\n        })\n        \n    except ValueError as e:\n        return jsonify({'error': f'Invalid date format: {str(e)}'}), 400\n    except Exception as e:\n        logging.error(f\"Error generating proctoring report: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n@app.route('/api/proctoring-analytics', methods=['GET'])\n@login_required\ndef api_proctoring_analytics():\n    \"\"\"Get proctoring analytics data for charts and graphs\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    try:\n        # Get date range from query parameters\n        days = request.args.get('days', 30, type=int)\n        end_date = datetime.utcnow()\n        start_date = end_date - timedelta(days=days)\n        \n        # Get violation trends\n        violations_by_day = db.session.query(\n            func.date(UserViolation.flagged_at).label('date'),\n            func.count(UserViolation.id).label('count')\n        ).filter(\n            UserViolation.flagged_at >= start_date,\n            UserViolation.flagged_at <= end_date\n        ).group_by(func.date(UserViolation.flagged_at)).all()\n        \n        # Get proctoring events by type\n        events_by_type = db.session.query(\n            ProctoringEvent.event_type,\n            func.count(ProctoringEvent.id).label('count')\n        ).filter(\n            ProctoringEvent.timestamp >= start_date,\n            ProctoringEvent.timestamp <= end_date\n        ).group_by(ProctoringEvent.event_type).all()\n        \n        # Get security alerts by severity\n        alerts_by_severity = db.session.query(\n            SecurityAlert.severity,\n            func.count(SecurityAlert.id).label('count')\n        ).filter(\n            SecurityAlert.created_at >= start_date,\n            SecurityAlert.created_at <= end_date\n        ).group_by(SecurityAlert.severity).all()\n        \n        # Get quiz completion rates\n        total_attempts = db.session.query(QuizAttempt).filter(\n            QuizAttempt.started_at >= start_date,\n            QuizAttempt.started_at <= end_date\n        ).count()\n        \n        completed_attempts = db.session.query(QuizAttempt).filter(\n            QuizAttempt.started_at >= start_date,\n            QuizAttempt.started_at <= end_date,\n            QuizAttempt.status == 'completed'\n        ).count()\n        \n        flagged_attempts = db.session.query(QuizAttempt).filter(\n            QuizAttempt.started_at >= start_date,\n            QuizAttempt.started_at <= end_date,\n            QuizAttempt.is_flagged == True\n        ).count()\n        \n        analytics_data = {\n            'violation_trends': [\n                {'date': str(row.date), 'count': row.count} \n                for row in violations_by_day\n            ],\n            'events_by_type': [\n                {'type': row.event_type, 'count': row.count} \n                for row in events_by_type\n            ],\n            'alerts_by_severity': [\n                {'severity': row.severity, 'count': row.count} \n                for row in alerts_by_severity\n            ],\n            'completion_stats': {\n                'total_attempts': total_attempts,\n                'completed_attempts': completed_attempts,\n                'flagged_attempts': flagged_attempts,\n                'completion_rate': round((completed_attempts / total_attempts * 100) if total_attempts > 0 else 0, 2),\n                'flag_rate': round((flagged_attempts / total_attempts * 100) if total_attempts > 0 else 0, 2)\n            },\n            'period': {\n                'start_date': start_date.isoformat(),\n                'end_date': end_date.isoformat(),\n                'days': days\n            }\n        }\n        \n        return jsonify(analytics_data)\n        \n    except Exception as e:\n        logging.error(f\"Error generating proctoring analytics: {e}\")\n        return jsonify({'error': 'Failed to generate analytics'}), 500\n\n# ===== Enhanced Analytics & Insights System =====\n\n@app.route('/admin/analytics-dashboard')\n@login_required\ndef admin_analytics_dashboard():\n    \"\"\"Enhanced analytics dashboard for comprehensive insights\"\"\"\n    if not current_user.is_admin():\n        flash('Access denied.', 'error')\n        return redirect(url_for('home'))\n    \n    try:\n        # Initialize analytics engine\n        analytics = get_analytics_engine()\n        \n        # Get comprehensive analytics report\n        comprehensive_report = analytics.generate_comprehensive_report()\n        \n        # Get real-time institutional metrics\n        institutional_metrics = analytics.dashboard.get_real_time_metrics()\n        \n        # Get live monitoring data\n        live_data = analytics.dashboard.get_live_monitoring_data()\n        \n        return render_template('admin_analytics_dashboard.html',\n                             comprehensive_report=comprehensive_report,\n                             institutional_metrics=institutional_metrics,\n                             live_data=live_data)\n        \n    except Exception as e:\n        logging.error(f\"Error loading analytics dashboard: {e}\")\n        flash('Error loading analytics dashboard. Please try again.', 'error')\n        return redirect(url_for('admin_dashboard'))\n\n@app.route('/api/predictive-analytics', methods=['GET'])\n@login_required\ndef api_predictive_analytics():\n    \"\"\"Get predictive analytics for student risk assessment\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    try:\n        user_id = request.args.get('user_id', type=int)\n        course_id = request.args.get('course_id', type=int)\n        limit = request.args.get('limit', 50, type=int)\n        \n        # Initialize predictive analytics\n        predictor = PredictiveAnalytics()\n        \n        # Analyze student risk\n        risk_profiles = predictor.analyze_student_risk(user_id, course_id)\n        \n        # Limit results for performance\n        if limit and len(risk_profiles) > limit:\n            risk_profiles = risk_profiles[:limit]\n        \n        # Convert to serializable format\n        results = []\n        for profile in risk_profiles:\n            results.append({\n                'user_id': profile.user_id,\n                'username': profile.username,\n                'risk_score': profile.risk_score,\n                'risk_level': profile.risk_level,\n                'risk_factors': profile.risk_factors,\n                'intervention_recommendations': profile.intervention_recommendations,\n                'predicted_failure_probability': profile.predicted_failure_probability,\n                'engagement_score': profile.engagement_score,\n                'performance_trend': profile.performance_trend,\n                'last_activity': profile.last_activity.isoformat() if profile.last_activity else None,\n                'courses_enrolled': profile.courses_enrolled,\n                'avg_quiz_score': profile.avg_quiz_score,\n                'violation_count': profile.violation_count,\n                'proctoring_issues': profile.proctoring_issues\n            })\n        \n        # Calculate summary statistics\n        summary = {\n            'total_students': len(results),\n            'high_risk_count': len([r for r in results if r['risk_level'] in ['High', 'Critical']]),\n            'medium_risk_count': len([r for r in results if r['risk_level'] == 'Medium']),\n            'low_risk_count': len([r for r in results if r['risk_level'] in ['Low', 'Minimal']]),\n            'average_risk_score': round(sum(r['risk_score'] for r in results) / len(results), 2) if results else 0,\n            'most_common_risk_factors': {}\n        }\n        \n        # Count risk factors\n        all_factors = []\n        for r in results:\n            all_factors.extend(r['risk_factors'])\n        \n        from collections import Counter\n        factor_counts = Counter(all_factors)\n        summary['most_common_risk_factors'] = dict(factor_counts.most_common(10))\n        \n        return jsonify({\n            'success': True,\n            'students': results,\n            'summary': summary,\n            'generated_at': datetime.utcnow().isoformat()\n        })\n        \n    except Exception as e:\n        logging.error(f\"Error in predictive analytics API: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n@app.route('/api/institutional-metrics', methods=['GET'])\n@login_required\ndef api_institutional_metrics():\n    \"\"\"Get real-time institutional dashboard metrics\"\"\"\n    if not current_user.is_admin():\n        return jsonify({'error': 'Access denied'}), 403\n    \n    try:\n        # Initialize dashboard\n        dashboard = InstitutionalDashboard()\n        \n        # Get real-time metrics\n        metrics = dashboard.get_real_time_metrics()\n        \n        # Get live monitoring data\n        live_data = dashboard.get_live_monitoring_data()\n        \n        return jsonify({\n            'success': True,\n            'metrics': {\n                'total_students': metrics.total_students,\n                'active_students_today': metrics.active_students_today,\n                'quizzes_in_progress': metrics.quizzes_in_progress,\n                'completed_quizzes_today': metrics.completed_quizzes_today,\n                'average_performance': metrics.average_performance,\n                'high_risk_students': metrics.high_risk_students,\n                'security_alerts_today': metrics.security_alerts_today,\n                'system_uptime': metrics.system_uptime,\n                'concurrent_users': metrics.concurrent_users,\n                'violation_rate': metrics.violation_rate\n            },\n            'live_data': live_data,\n            'generated_at': datetime.utcnow().isoformat()\n        })\n        \n    except Exception as e:\n        logging.error(f\"Error in institutional metrics API: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\n\n@app.route('/api/user/theme-preference', methods=['POST'])\n@login_required\ndef save_theme_preference():\n    \"\"\"Save user theme preference\"\"\"\n    try:\n        data = request.get_json()\n        theme = data.get('theme', 'auto')\n        \n        # Validate theme\n        valid_themes = ['auto', 'light', 'dark']\n        if theme not in valid_themes:\n            return jsonify({'error': 'Invalid theme'}), 400\n        \n        # Save to user model (assuming we add theme_preference field)\n        current_user.theme_preference = theme\n        db.session.commit()\n        \n        return jsonify({'success': True, 'theme': theme})\n        \n    except Exception as e:\n        logging.error(f\"Error saving theme preference: {e}\")\n        return jsonify({'error': 'Failed to save preference'}), 500\n\n@app.route('/sw.js')\ndef service_worker():\n    \"\"\"Serve service worker from root path for proper scope\"\"\"\n    return app.send_static_file('../sw.js')\n\n@app.route('/api/connectivity-check', methods=['HEAD', 'GET'])\ndef connectivity_check():\n    \"\"\"Fast connectivity check for offline manager\"\"\"\n    return '', 204\n\n@app.route('/api/quiz/sync-progress', methods=['POST'])\n@login_required\ndef sync_quiz_progress():\n    \"\"\"Sync quiz progress from offline storage\"\"\"\n    try:\n        data = request.get_json()\n        quiz_id = data.get('quizId')\n        progress = data.get('progress', {})\n        \n        if not quiz_id:\n            return jsonify({'error': 'Quiz ID required'}), 400\n        \n        # Update quiz progress in database\n        # This would typically update the user's progress\n        logging.info(f\"Syncing offline progress for quiz {quiz_id} for user {current_user.id}\")\n        \n        return jsonify({\n            'success': True,\n            'message': 'Progress synced successfully',\n            'quiz_id': quiz_id\n        })\n        \n    except Exception as e:\n        logging.error(f\"Error syncing quiz progress: {e}\")\n        return jsonify({'error': 'Failed to sync progress'}), 500\n","size_bytes":302678},"static/css/custom.css":{"content":"/* Custom CSS for Proctoring Platform */\n\n/* Fix admin dropdown overflow for mobile/small screens */\n.navbar .dropdown-menu {\n    max-height: 70vh !important;\n    overflow-y: auto !important;\n    overscroll-behavior: contain !important;\n    padding: 0.5rem 0 !important;\n}\n\n/* Ensure dropdown items are properly visible */\n.navbar .dropdown-item {\n    padding: 0.375rem 1rem !important;\n    white-space: nowrap !important;\n    font-size: 0.875rem !important;\n}\n\n/* Make dropdown wider on mobile to prevent text cutoff */\n@media (max-width: 768px) {\n    .navbar .dropdown-menu {\n        min-width: 280px !important;\n        max-width: 90vw !important;\n        left: auto !important;\n        right: 0 !important;\n    }\n}\n\n/* Ensure dropdown header is visible */\n.navbar .dropdown-header {\n    padding: 0.375rem 1rem !important;\n    font-weight: 600 !important;\n    color: #6c757d !important;\n    font-size: 0.75rem !important;\n    text-transform: uppercase !important;\n    letter-spacing: 0.05em !important;\n}\n\n/* Base styles that complement Bootstrap dark theme */\n:root {\n    --custom-primary: #0d6efd;\n    --custom-success: #198754;\n    --custom-warning: #ffc107;\n    --custom-danger: #dc3545;\n    --custom-info: #0dcaf0;\n    --custom-light: #f8f9fa;\n    --custom-dark: #212529;\n    --custom-purple: #6f42c1;\n}\n\n/* Additional background colors */\n.bg-purple {\n    background-color: var(--custom-purple) !important;\n}\n\n/* Smooth transitions for all interactive elements */\n* {\n    transition: all 0.2s ease;\n}\n\n/* Custom card hover effects */\n.card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n.card-hover-primary:hover {\n    border-color: var(--custom-primary);\n}\n\n.card-hover-success:hover {\n    border-color: var(--custom-success);\n}\n\n/* Quiz-specific styles */\n.quiz-container {\n    max-width: 900px;\n    margin: 0 auto;\n}\n\n.question-card {\n    margin-bottom: 2rem;\n    border-left: 4px solid var(--custom-primary);\n}\n\n.question-card:hover {\n    border-left-color: var(--custom-success);\n}\n\n/* Timer styles */\n.timer-container {\n    position: sticky;\n    top: 20px;\n    z-index: 100;\n}\n\n.time-warning {\n    animation: pulse 1s infinite;\n    color: var(--custom-warning) !important;\n}\n\n.time-critical {\n    animation: pulse 0.5s infinite;\n    color: var(--custom-danger) !important;\n}\n\n@keyframes pulse {\n    0% { opacity: 1; }\n    50% { opacity: 0.6; }\n    100% { opacity: 1; }\n}\n\n/* Progress bar enhancements */\n.quiz-progress {\n    height: 8px;\n    border-radius: 10px;\n}\n\n.quiz-progress .progress-bar {\n    border-radius: 10px;\n    transition: width 0.3s ease;\n}\n\n/* Custom button styles */\n.btn-quiz-primary {\n    background: linear-gradient(45deg, var(--custom-primary), #4dabf7);\n    border: none;\n    color: white;\n    font-weight: 500;\n}\n\n.btn-quiz-primary:hover {\n    background: linear-gradient(45deg, #0056b3, var(--custom-primary));\n    transform: translateY(-1px);\n    box-shadow: 0 4px 12px rgba(13, 110, 253, 0.3);\n}\n\n/* Proctoring status indicator */\n.proctoring-indicator {\n    position: fixed;\n    top: 80px;\n    right: 20px;\n    z-index: 1050;\n    padding: 8px 12px;\n    border-radius: 20px;\n    font-size: 0.85rem;\n    font-weight: 500;\n}\n\n.proctoring-active {\n    background: rgba(255, 193, 7, 0.9);\n    color: #000;\n    border: 2px solid var(--custom-warning);\n}\n\n.proctoring-violation {\n    background: rgba(220, 53, 69, 0.9);\n    color: #fff;\n    border: 2px solid var(--custom-danger);\n    animation: shake 0.5s infinite;\n}\n\n@keyframes shake {\n    0%, 100% { transform: translateX(0); }\n    25% { transform: translateX(-5px); }\n    75% { transform: translateX(5px); }\n}\n\n/* Dashboard cards */\n.dashboard-stat-card {\n    transition: all 0.3s ease;\n    cursor: pointer;\n}\n\n.dashboard-stat-card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);\n}\n\n.dashboard-stat-card i {\n    opacity: 0.8;\n}\n\n/* Quiz results styling */\n.result-card {\n    border-radius: 12px;\n    overflow: hidden;\n}\n\n.result-correct {\n    border-left: 5px solid var(--custom-success);\n    background: rgba(25, 135, 84, 0.1);\n}\n\n.result-incorrect {\n    border-left: 5px solid var(--custom-danger);\n    background: rgba(220, 53, 69, 0.1);\n}\n\n.result-unanswered {\n    border-left: 5px solid var(--bs-secondary);\n    background: rgba(108, 117, 125, 0.1);\n}\n\n/* Profile page enhancements */\n.profile-avatar {\n    width: 120px;\n    height: 120px;\n    border-radius: 50%;\n    border: 4px solid var(--custom-primary);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: var(--custom-light);\n    margin: 0 auto 20px;\n}\n\n.profile-stats {\n    background: linear-gradient(135deg, var(--custom-primary), #4dabf7);\n    color: white;\n    border-radius: 12px;\n}\n\n/* Form enhancements */\n.form-control:focus {\n    border-color: var(--custom-primary);\n    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);\n}\n\n.form-check-input:checked {\n    background-color: var(--custom-primary);\n    border-color: var(--custom-primary);\n}\n\n/* Loading states */\n.loading-spinner {\n    display: inline-block;\n    width: 20px;\n    height: 20px;\n    border: 2px solid #e5e7eb;\n    border-radius: 50%;\n    border-top-color: #374151;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n/* Professional loading animations */\n@keyframes professionalSpin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n@keyframes professionalProgress {\n    0% { transform: translateX(-100%); }\n    50% { transform: translateX(100%); }\n    100% { transform: translateX(300%); }\n}\n\n/* Alert enhancements */\n.alert-info {\n    border-left: 4px solid var(--custom-info);\n}\n\n.alert-success {\n    border-left: 4px solid var(--custom-success);\n}\n\n.alert-warning {\n    border-left: 4px solid var(--custom-warning);\n}\n\n.alert-danger {\n    border-left: 4px solid var(--custom-danger);\n}\n\n/* Navigation enhancements */\n.navbar-brand {\n    font-weight: 600;\n    font-size: 1.5rem;\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n}\n\n.navbar-brand i {\n    margin-right: 8px;\n    color: var(--custom-primary);\n}\n\n/* Footer styling */\nfooter {\n    margin-top: auto;\n}\n\n/* Responsive adjustments */\n@media (max-width: 768px) {\n    .proctoring-indicator {\n        position: relative;\n        top: auto;\n        right: auto;\n        margin: 10px 0;\n    }\n    \n    .quiz-container {\n        padding: 0 10px;\n    }\n    \n    .dashboard-stat-card {\n        margin-bottom: 15px;\n    }\n    \n    .card {\n        margin-bottom: 20px;\n    }\n}\n\n/* Print styles for quiz results */\n@media print {\n    .no-print {\n        display: none !important;\n    }\n    \n    .card {\n        border: 1px solid #dee2e6 !important;\n        box-shadow: none !important;\n    }\n    \n    .btn {\n        display: none !important;\n    }\n    \n    .navbar, .footer {\n        display: none !important;\n    }\n}\n\n/* Accessibility improvements */\n.sr-only {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    padding: 0;\n    margin: -1px;\n    overflow: hidden;\n    clip: rect(0, 0, 0, 0);\n    white-space: nowrap;\n    border: 0;\n}\n\n/* Focus styles for better accessibility */\n.btn:focus, .form-control:focus, .form-check-input:focus {\n    outline: 2px solid var(--custom-primary);\n    outline-offset: 2px;\n}\n\n/* High contrast mode support */\n@media (prefers-contrast: high) {\n    .card {\n        border: 2px solid currentColor;\n    }\n    \n    .btn {\n        border: 2px solid currentColor;\n    }\n}\n\n/* Reduced motion support */\n@media (prefers-reduced-motion: reduce) {\n    * {\n        animation-duration: 0.01ms !important;\n        animation-iteration-count: 1 !important;\n        transition-duration: 0.01ms !important;\n    }\n}\n\n/* Custom scrollbar for webkit browsers */\n::-webkit-scrollbar {\n    width: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--bs-gray-200);\n    border-radius: 10px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--custom-primary);\n    border-radius: 10px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #0056b3;\n}\n\n/* Quiz attempt status indicators */\n.status-completed {\n    color: var(--custom-success);\n}\n\n.status-in-progress {\n    color: var(--custom-warning);\n}\n\n.status-abandoned {\n    color: var(--custom-danger);\n}\n\n/* Modal enhancements */\n.modal-content {\n    border-radius: 12px;\n    border: none;\n    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);\n}\n\n.modal-header {\n    border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n    border-radius: 12px 12px 0 0;\n}\n\n.modal-footer {\n    border-top: 1px solid rgba(0, 0, 0, 0.1);\n    border-radius: 0 0 12px 12px;\n}\n\n/* ===== LOADING SCREEN STYLES ===== */\n.loading-screen {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, 0.95);\n    backdrop-filter: blur(8px);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 9999;\n    transition: opacity 0.5s ease-out;\n}\n\n.loading-content {\n    text-align: center;\n    color: #374151;\n    max-width: 280px;\n}\n\n.simple-spinner {\n    width: 50px;\n    height: 50px;\n    border: 3px solid #e5e7eb;\n    border-top: 3px solid #374151;\n    border-radius: 50%;\n    animation: simple-spin 0.8s linear infinite;\n    margin: 0 auto 1.5rem;\n}\n\n@keyframes simple-spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n.typing-text {\n    white-space: nowrap;\n    overflow: hidden;\n}\n\n.cursor {\n    animation: blink 1s infinite;\n}\n\n@keyframes blink {\n    0%, 50% { opacity: 1; }\n    51%, 100% { opacity: 0; }\n}\n\n.loading-hidden {\n    opacity: 0;\n    pointer-events: none;\n}\n\n/* Enhanced course management styles */\n.course-card {\n    border-radius: 12px;\n    overflow: hidden;\n    transition: all 0.3s ease;\n    border: none;\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n}\n\n.course-card:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 10px 30px rgba(0,0,0,0.15);\n}\n\n/* White theme body override */\nbody.light-theme {\n    background-color: #f8f9fa !important;\n    color: #212529 !important;\n}\n\n/* Robotic theme for icons throughout the app */\n.fas.fa-robot {\n    color: #0066cc;\n    text-shadow: 0 0 8px rgba(0, 102, 204, 0.4);\n}\n\n.fas.fa-eye {\n    color: #00ff41;\n    text-shadow: 0 0 8px rgba(0, 255, 65, 0.4);\n}\n\n.text-primary {\n    color: #0066cc !important;\n}\n\n/* ===== RESPONSIVE DESIGN ENHANCEMENTS ===== */\n/* Mobile First Approach */\n@media (max-width: 576px) {\n    .security-monitoring {\n        width: 280px;\n        height: 200px;\n    }\n    \n    .monitoring-zone {\n        border-radius: 15px;\n    }\n    \n    .person-silhouette i {\n        font-size: 2rem;\n    }\n    \n    .radar-sweep {\n        width: 120px;\n        height: 120px;\n        margin: -60px 0 0 -60px;\n    }\n    \n    .radar-sweep::before {\n        height: 60px;\n        margin-top: -60px;\n    }\n    \n    .robotic-eye-scanner {\n        width: 40px;\n        height: 40px;\n        top: -20px;\n        right: -20px;\n    }\n    \n    .eye-outer {\n        width: 30px;\n        height: 30px;\n    }\n    \n    .eye-iris {\n        width: 18px;\n        height: 18px;\n    }\n    \n    .eye-pupil {\n        width: 6px;\n        height: 6px;\n    }\n    \n    .ring-1 { width: 35px; height: 35px; }\n    .ring-2 { width: 50px; height: 50px; }\n    .ring-3 { width: 65px; height: 65px; }\n    \n    .status-indicators {\n        flex-direction: column;\n        gap: 8px;\n    }\n    \n    .indicator {\n        font-size: 0.7rem;\n        padding: 3px 8px;\n    }\n    \n    .security-messages {\n        font-size: 12px;\n        padding: 10px;\n        max-width: 280px;\n    }\n    \n    .navbar-brand {\n        font-size: 1.1rem;\n    }\n    \n    .robotic-eye-icon {\n        font-size: 1em;\n    }\n    \n    .progress {\n        width: 250px !important;\n    }\n    \n    /* Enhanced Card Responsiveness */\n    .card {\n        margin-bottom: 1rem;\n    }\n    \n    .admin-card {\n        margin-bottom: 1rem;\n    }\n    \n    .course-card {\n        margin-bottom: 1rem;\n    }\n    \n    .btn-group {\n        flex-direction: column;\n    }\n    \n    .btn-group .btn {\n        margin-bottom: 0.25rem;\n    }\n    \n    /* Form Responsiveness */\n    .form-control {\n        font-size: 16px; /* Prevents zoom on iOS */\n    }\n    \n    .btn {\n        padding: 0.75rem 1rem;\n        font-size: 1rem;\n    }\n    \n    /* Modal Responsiveness */\n    .modal-dialog {\n        margin: 1rem 0.5rem;\n    }\n    \n    .modal-lg {\n        max-width: calc(100vw - 1rem);\n    }\n    \n    /* Quiz Interface Responsiveness */\n    .quiz-container {\n        padding: 0 0.5rem;\n    }\n    \n    .question-card {\n        margin-bottom: 1.5rem;\n    }\n    \n    .camera-preview {\n        width: 120px;\n        height: 90px;\n        bottom: 10px;\n        right: 10px;\n    }\n    \n    .proctoring-indicator {\n        position: static;\n        margin: 1rem 0;\n        text-align: center;\n    }\n    \n    /* Dashboard Responsiveness */\n    .dashboard-stat-card {\n        margin-bottom: 1rem;\n    }\n    \n    .row.mb-4 .col-md-3 {\n        margin-bottom: 1rem;\n    }\n}\n\n@media (min-width: 577px) and (max-width: 768px) {\n    .security-monitoring {\n        width: 350px;\n        height: 250px;\n    }\n    \n    .radar-sweep {\n        width: 160px;\n        height: 160px;\n        margin: -80px 0 0 -80px;\n    }\n    \n    .radar-sweep::before {\n        height: 80px;\n        margin-top: -80px;\n    }\n    \n    .status-indicators {\n        gap: 12px;\n    }\n    \n    .security-messages {\n        max-width: 320px;\n    }\n    \n    /* Table Responsiveness */\n    .table-responsive {\n        border: none;\n    }\n    \n    .table {\n        font-size: 0.875rem;\n    }\n    \n    .table th,\n    .table td {\n        padding: 0.5rem 0.25rem;\n    }\n}\n\n@media (min-width: 769px) and (max-width: 992px) {\n    .security-monitoring {\n        width: 380px;\n        height: 280px;\n    }\n    \n    /* Navigation Responsiveness */\n    .navbar-nav {\n        text-align: center;\n    }\n    \n    .navbar-nav .nav-link {\n        padding: 0.75rem 1rem;\n    }\n}\n\n@media (min-width: 1200px) {\n    .security-monitoring {\n        width: 450px;\n        height: 350px;\n    }\n    \n    .radar-sweep {\n        width: 240px;\n        height: 240px;\n        margin: -120px 0 0 -120px;\n    }\n    \n    .radar-sweep::before {\n        height: 120px;\n        margin-top: -120px;\n    }\n    \n    .robotic-eye-scanner {\n        width: 80px;\n        height: 80px;\n        top: -40px;\n        right: -40px;\n    }\n    \n    .eye-outer {\n        width: 50px;\n        height: 50px;\n    }\n    \n    .eye-iris {\n        width: 32px;\n        height: 32px;\n    }\n    \n    .eye-pupil {\n        width: 10px;\n        height: 10px;\n    }\n    \n    .ring-1 { width: 60px; height: 60px; }\n    .ring-2 { width: 85px; height: 85px; }\n    .ring-3 { width: 110px; height: 110px; }\n}\n\n/* Footer Responsiveness */\n@media (max-width: 768px) {\n    footer .row {\n        text-align: center;\n    }\n    \n    footer .col-md-6:last-child {\n        margin-top: 1rem;\n    }\n}\n\n/* Container responsiveness */\n@media (max-width: 576px) {\n    .container {\n        padding-left: 15px;\n        padding-right: 15px;\n    }\n}\n\n/* Enhanced hover effects for mobile */\n@media (hover: none) {\n    .card:hover,\n    .course-card:hover,\n    .question-card:hover {\n        transform: none;\n        box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n    }\n}\n\n/* Floating Scroll to Top Button */\n.scroll-to-top {\n    position: fixed;\n    bottom: 30px;\n    right: 30px;\n    width: 50px;\n    height: 50px;\n    background: var(--custom-primary);\n    color: white;\n    border: none;\n    border-radius: 50%;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n    cursor: pointer;\n    display: none;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.2rem;\n    transition: all 0.3s ease;\n    z-index: 1000;\n}\n\n.scroll-to-top:hover {\n    background: #0056b3;\n    transform: translateY(-2px);\n    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);\n}\n\n.scroll-to-top.show {\n    display: flex;\n    animation: fadeInUp 0.3s ease;\n}\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* Responsive adjustments for floating button */\n@media (max-width: 768px) {\n    .scroll-to-top {\n        bottom: 20px;\n        right: 20px;\n        width: 45px;\n        height: 45px;\n        font-size: 1rem;\n    }\n}\n","size_bytes":16342},"static/js/proctoring.js":{"content":"// Proctoring.js - Advanced proctoring functionality for quiz monitoring\n\nclass ProctoringManager {\n    constructor(attemptId) {\n        this.attemptId = attemptId;\n        this.isActive = false;\n        this.violations = [];\n        this.mediaStream = null;\n        this.videoElement = null;\n        this.canvas = null;\n        this.context = null;\n        this.detectionInterval = null;\n        \n        // WebSocket connection for real-time monitoring\n        this.socket = null;\n        this.socketReconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        \n        // Enhanced face detection\n        this.faceDetectionModel = null;\n        this.lastDetectedFaces = 0;\n        this.noFaceDetectedCount = 0;\n        this.multipleFaceDetectedCount = 0;\n        this.suspiciousMovementCount = 0;\n        this.previousImageData = null;\n        \n        // Enhanced violation tracking\n        this.violationCount = 0;\n        this.highSeverityCount = 0;\n        this.isTerminated = false;\n        this.maxViolations = 3;\n        this.lastViolationTime = null;\n        this.violationBuffer = [];\n        \n        // Configuration - Enhanced like Moodle Proctoring Pro\n        this.config = {\n            // Core proctoring features\n            faceDetection: true,\n            tabSwitchDetection: true,\n            fullscreenEnforcement: true,\n            screenshotDetection: true,\n            audioMonitoring: true,\n            mouseMoveTracking: true,\n            keyboardMonitoring: true,\n            windowBlurDetection: true,\n            multipleTabDetection: true,\n            rightClickDisabled: true,\n            copyPasteDisabled: true,\n            devToolsDetection: true,\n            printScreenBlocked: true,\n            selectTextDisabled: true,\n            \n            // NEW: Moodle Proctoring Pro-like features\n            intervalCapture: true,\n            captureIntervalMs: 30000, // 30 seconds like Moodle Proctoring Pro\n            imageQuality: 0.8,\n            preExamFaceVerification: true,\n            faceVerificationRequired: true,\n            screenResizeDetection: true,\n            windowResizeDetection: true,\n            browserChangeDetection: true,\n            bulkImageAnalysis: true,\n            autoTerminateOnViolations: true,\n            violationThreshold: 5\n        };\n        \n        // NEW: Interval capture system\n        this.intervalCaptureTimer = null;\n        this.capturedImages = [];\n        this.faceVerificationStatus = 'pending';\n        this.preExamVerificationComplete = false;\n        \n        this.init();\n    }\n\n    async init() {\n        console.log('Initializing Enhanced Proctoring System (Moodle Proctoring Pro style)...');\n        \n        try {\n            // NEW: Pre-exam face verification like Moodle Proctoring Pro\n            if (this.config.preExamFaceVerification) {\n                await this.performPreExamVerification();\n            }\n            \n            await this.requestPermissions();\n            this.setupEventListeners();\n            this.setupEnhancedDetection(); // NEW: Enhanced detection methods\n            this.initWebSocket();\n            this.startMonitoring();\n            this.startAdvancedFaceDetection();\n            \n            // NEW: Start interval-based captures like Moodle Proctoring Pro\n            if (this.config.intervalCapture) {\n                this.startIntervalCapture();\n            }\n            \n            this.showProctoringStatus('active');\n        } catch (error) {\n            console.error('Proctoring initialization failed:', error);\n            this.showProctoringStatus('error', error.message);\n            // If pre-verification fails, block quiz access\n            if (error.type === 'face_verification_failed') {\n                this.blockQuizAccess(error.message);\n            }\n        }\n    }\n\n    async requestPermissions() {\n        // Enhanced browser compatibility check\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n            // Try older browser APIs as fallback\n            if (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) {\n                console.warn('Using legacy getUserMedia API');\n                return this.requestPermissionsLegacy();\n            } else {\n                throw new Error('Camera access not supported by this browser. Please use a modern browser like Chrome, Firefox, or Safari.');\n            }\n        }\n\n        // Check for HTTPS requirement\n        if (location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(location.hostname)) {\n            throw new Error('Camera access requires a secure connection (HTTPS). Please access this page via HTTPS.');\n        }\n\n        try {\n            // Request camera and microphone access with enhanced error handling\n            this.mediaStream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: { ideal: 640, min: 320 },\n                    height: { ideal: 480, min: 240 },\n                    frameRate: { ideal: 15, min: 10 },\n                    facingMode: 'user'\n                },\n                audio: this.config.audioMonitoring\n            });\n\n            // Setup video element for face detection\n            this.setupVideoElement();\n            console.log('Camera access granted successfully');\n            \n        } catch (error) {\n            console.error('Camera access error:', error);\n            \n            if (error.name === 'NotAllowedError') {\n                throw new Error('Camera permission denied. Please click \"Allow\" when prompted and refresh the page.');\n            } else if (error.name === 'NotFoundError') {\n                throw new Error('No camera found. Please connect a camera and refresh the page.');\n            } else if (error.name === 'OverconstrainedError') {\n                console.warn('Camera constraints too strict, trying with basic settings');\n                return this.requestBasicPermissions();\n            } else if (error.name === 'SecurityError') {\n                throw new Error('Security error accessing camera. Please ensure you are on a secure connection.');\n            } else {\n                throw new Error(`Camera access error: ${error.message}`);\n            }\n        }\n    }\n    \n    async requestBasicPermissions() {\n        try {\n            this.mediaStream = await navigator.mediaDevices.getUserMedia({\n                video: true,\n                audio: false\n            });\n            this.setupVideoElement();\n            console.log('Basic camera access granted');\n        } catch (error) {\n            throw new Error(`Even basic camera access failed: ${error.message}`);\n        }\n    }\n    \n    requestPermissionsLegacy() {\n        return new Promise((resolve, reject) => {\n            const getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n            \n            getUserMedia.call(navigator, {\n                video: true,\n                audio: false\n            }, (stream) => {\n                this.mediaStream = stream;\n                this.setupVideoElement();\n                resolve();\n            }, (error) => {\n                reject(new Error(`Legacy camera access failed: ${error.message}`));\n            });\n        });\n    }\n\n    setupVideoElement() {\n        try {\n            // Create video element for face detection with enhanced error handling\n            this.videoElement = document.createElement('video');\n            this.videoElement.style.cssText = `\n                position: fixed;\n                top: 10px;\n                right: 10px;\n                width: 200px;\n                height: 150px;\n                z-index: 9999;\n                border: 2px solid #28a745;\n                border-radius: 8px;\n                background: #000;\n                box-shadow: 0 4px 8px rgba(0,0,0,0.3);\n            `;\n            this.videoElement.autoplay = true;\n            this.videoElement.muted = true;\n            this.videoElement.playsInline = true; // Important for iOS\n            \n            // Add error handling for video element\n            this.videoElement.onerror = (e) => {\n                console.error('Video element error:', e);\n                this.recordViolation('video_error', 'Video playback error', 'medium');\n            };\n            \n            this.videoElement.onloadedmetadata = () => {\n                console.log('Video metadata loaded successfully');\n            };\n            \n            // Set video source\n            if (this.mediaStream) {\n                this.videoElement.srcObject = this.mediaStream;\n            } else {\n                throw new Error('No media stream available');\n            }\n            \n            document.body.appendChild(this.videoElement);\n            \n            // Add status indicator\n            this.createStatusIndicator();\n            \n        } catch (error) {\n            console.error('Error setting up video element:', error);\n            throw new Error(`Video setup failed: ${error.message}`);\n        }\n\n        // Setup canvas for face detection\n        this.canvas = document.createElement('canvas');\n        this.context = this.canvas.getContext('2d');\n        this.canvas.width = 640;\n        this.canvas.height = 480;\n    }\n    \n    initWebSocket() {\n        try {\n            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n            const wsUrl = `${protocol}//${window.location.host}/ws/proctoring/${this.attemptId}`;\n            \n            this.socket = new WebSocket(wsUrl);\n            \n            this.socket.onopen = () => {\n                console.log('WebSocket connected for real-time monitoring');\n                this.socketReconnectAttempts = 0;\n                this.sendWebSocketMessage('connection_established', {\n                    timestamp: new Date().toISOString(),\n                    userAgent: navigator.userAgent,\n                    screenResolution: `${screen.width}x${screen.height}`\n                });\n            };\n            \n            this.socket.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                this.handleWebSocketMessage(data);\n            };\n            \n            this.socket.onclose = () => {\n                console.log('WebSocket connection closed');\n                this.reconnectWebSocket();\n            };\n            \n            this.socket.onerror = (error) => {\n                console.error('WebSocket error:', error);\n            };\n            \n        } catch (error) {\n            console.warn('WebSocket not available, falling back to HTTP polling');\n            this.startPollingFallback();\n        }\n    }\n    \n    reconnectWebSocket() {\n        if (this.socketReconnectAttempts < this.maxReconnectAttempts && !this.isTerminated) {\n            this.socketReconnectAttempts++;\n            setTimeout(() => {\n                console.log(`Attempting WebSocket reconnection (${this.socketReconnectAttempts}/${this.maxReconnectAttempts})`);\n                this.initWebSocket();\n            }, 3000 * this.socketReconnectAttempts);\n        }\n    }\n    \n    sendWebSocketMessage(type, data) {\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n            this.socket.send(JSON.stringify({\n                type: type,\n                attemptId: this.attemptId,\n                timestamp: new Date().toISOString(),\n                data: data\n            }));\n        }\n    }\n    \n    handleWebSocketMessage(message) {\n        switch (message.type) {\n            case 'warning':\n                this.showWarningMessage(message.data.message);\n                break;\n            case 'terminate_quiz':\n                this.terminateQuiz(message.data.reason);\n                break;\n            case 'host_message':\n                this.showHostMessage(message.data.message);\n                break;\n        }\n    }\n    \n    startPollingFallback() {\n        // Fallback to HTTP polling if WebSocket is not available\n        setInterval(() => {\n            this.sendViolationUpdate();\n        }, 10000);\n    }\n    \n    async startAdvancedFaceDetection() {\n        // Load face detection model if available\n        try {\n            if (typeof cv !== 'undefined') {\n                console.log('OpenCV.js detected, using advanced face detection');\n                this.faceDetectionModel = new cv.CascadeClassifier();\n                this.faceDetectionModel.load('haarcascade_frontalface_default.xml');\n            }\n        } catch (error) {\n            console.log('Advanced face detection not available, using basic detection');\n        }\n        \n        // Start face detection loop\n        this.faceDetectionLoop();\n    }\n    \n    faceDetectionLoop() {\n        if (this.isTerminated) return;\n        \n        if (this.videoElement && this.videoElement.readyState === 4) {\n            this.context.drawImage(this.videoElement, 0, 0, 640, 480);\n            \n            // Get current image data\n            const currentImageData = this.context.getImageData(0, 0, 640, 480);\n            \n            // Detect faces\n            const faceCount = this.detectFaces(currentImageData);\n            \n            // Check for violations\n            this.checkFaceViolations(faceCount);\n            \n            // Detect suspicious movement\n            if (this.previousImageData) {\n                this.detectSuspiciousMovement(currentImageData, this.previousImageData);\n            }\n            \n            this.previousImageData = currentImageData;\n            this.lastDetectedFaces = faceCount;\n            \n            // Send real-time update\n            this.sendWebSocketMessage('face_detection_update', {\n                faceCount: faceCount,\n                timestamp: new Date().toISOString()\n            });\n        }\n        \n        // Continue detection loop\n        setTimeout(() => this.faceDetectionLoop(), 2000);\n    }\n\n    // NEW: Pre-exam face verification like Moodle Proctoring Pro\n    async performPreExamVerification() {\n        return new Promise((resolve, reject) => {\n            console.log('Starting pre-exam face verification...');\n            \n            // Show verification modal\n            this.showVerificationModal();\n            \n            // Wait for user to capture verification image\n            document.getElementById('capture-verification-btn').addEventListener('click', async () => {\n                try {\n                    const verificationImage = await this.captureVerificationImage();\n                    const verified = await this.verifyUserIdentity(verificationImage);\n                    \n                    if (verified) {\n                        this.preExamVerificationComplete = true;\n                        this.faceVerificationStatus = 'verified';\n                        this.hideVerificationModal();\n                        resolve();\n                    } else {\n                        const error = new Error('Face verification failed. Please ensure good lighting and look directly at the camera.');\n                        error.type = 'face_verification_failed';\n                        reject(error);\n                    }\n                } catch (error) {\n                    error.type = 'face_verification_failed';\n                    reject(error);\n                }\n            });\n        });\n    }\n\n    // NEW: Enhanced detection setup like Moodle Proctoring Pro\n    setupEnhancedDetection() {\n        // Screen resize detection\n        if (this.config.screenResizeDetection) {\n            let originalWidth = window.screen.width;\n            let originalHeight = window.screen.height;\n            \n            setInterval(() => {\n                if (window.screen.width !== originalWidth || window.screen.height !== originalHeight) {\n                    this.logViolation('screen_resize', \n                        `Screen resolution changed from ${originalWidth}x${originalHeight} to ${window.screen.width}x${window.screen.height}`, \n                        'medium');\n                    originalWidth = window.screen.width;\n                    originalHeight = window.screen.height;\n                }\n            }, 5000);\n        }\n\n        // Window resize detection\n        if (this.config.windowResizeDetection) {\n            let originalWindowWidth = window.innerWidth;\n            let originalWindowHeight = window.innerHeight;\n            \n            window.addEventListener('resize', () => {\n                const newWidth = window.innerWidth;\n                const newHeight = window.innerHeight;\n                \n                if (Math.abs(newWidth - originalWindowWidth) > 50 || Math.abs(newHeight - originalWindowHeight) > 50) {\n                    this.logViolation('window_resize', \n                        `Browser window resized significantly from ${originalWindowWidth}x${originalWindowHeight} to ${newWidth}x${newHeight}`, \n                        'medium');\n                }\n                \n                originalWindowWidth = newWidth;\n                originalWindowHeight = newHeight;\n            });\n        }\n\n        // Enhanced developer tools detection\n        if (this.config.devToolsDetection) {\n            this.detectDevTools();\n        }\n    }\n\n    // NEW: Interval-based image capture like Moodle Proctoring Pro\n    startIntervalCapture() {\n        console.log(`Starting interval capture every ${this.config.captureIntervalMs / 1000} seconds`);\n        \n        this.intervalCaptureTimer = setInterval(async () => {\n            if (this.isActive && !this.isTerminated) {\n                try {\n                    const capturedImage = await this.captureCurrentFrame();\n                    await this.sendCapturedImage(capturedImage);\n                    this.capturedImages.push({\n                        timestamp: new Date().toISOString(),\n                        image: capturedImage,\n                        analyzed: false\n                    });\n                    \n                    // Keep only last 100 images\n                    if (this.capturedImages.length > 100) {\n                        this.capturedImages.shift();\n                    }\n                } catch (error) {\n                    console.error('Interval capture failed:', error);\n                    this.logViolation('capture_failed', 'Failed to capture webcam image', 'low');\n                }\n            }\n        }, this.config.captureIntervalMs);\n    }\n\n    // NEW: Enhanced developer tools detection\n    detectDevTools() {\n        let devtools = {\n            open: false,\n            orientation: null\n        };\n        \n        setInterval(() => {\n            const threshold = 160;\n            let orientation = window.outerHeight - window.innerHeight > threshold ? 'vertical' : 'horizontal';\n            \n            if (!(window.outerHeight - window.innerHeight > threshold) && \n                !(window.outerWidth - window.innerWidth > threshold)) {\n                devtools.open = false;\n            } else {\n                if (!devtools.open || devtools.orientation !== orientation) {\n                    devtools.open = true;\n                    devtools.orientation = orientation;\n                    this.logViolation('devtools_opened', \n                        `Developer tools detected (${orientation} orientation)`, \n                        'high');\n                }\n            }\n        }, 1000);\n        \n        // Additional F12 key detection\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'F12' || \n                (e.ctrlKey && e.shiftKey && e.key === 'I') ||\n                (e.ctrlKey && e.shiftKey && e.key === 'C') ||\n                (e.ctrlKey && e.shiftKey && e.key === 'J')) {\n                e.preventDefault();\n                this.logViolation('devtools_shortcut', \n                    `Developer tools shortcut blocked: ${e.key}`, \n                    'high');\n                return false;\n            }\n        });\n    }\n    \n    detectFaces(imageData) {\n        // Enhanced biometric-style face detection with multi-person detection\n        const data = imageData.data;\n        const width = 640;\n        const height = 480;\n        \n        // Check if camera is blocked first\n        if (this.isCameraBlocked(data)) {\n            this.logViolation('camera_blocked', 'Camera appears to be blocked or covered', 'high');\n            return 0;\n        }\n        \n        // Detect face regions using enhanced algorithm\n        const faceRegions = this.detectFaceRegions(data, width, height);\n        const faceCount = faceRegions.length;\n        \n        // Enhanced lighting check\n        const avgBrightness = this.calculateAverageBrightness(data);\n        if (avgBrightness < 25) {\n            this.logViolation('poor_lighting', 'Environment too dark for proper face detection', 'medium');\n        }\n        \n        return faceCount;\n    }\n    \n    detectFaceRegions(data, width, height) {\n        const faces = [];\n        const blockSize = 40; // Larger blocks for better accuracy\n        \n        for (let y = 0; y < height - blockSize; y += 20) {\n            for (let x = 0; x < width - blockSize; x += 20) {\n                const faceScore = this.calculateFaceScore(data, x, y, blockSize, width);\n                \n                if (faceScore > 0.4) {\n                    // Check if this region overlaps with existing faces\n                    const overlaps = faces.some(face => \n                        Math.abs(face.x - x) < blockSize && Math.abs(face.y - y) < blockSize\n                    );\n                    \n                    if (!overlaps) {\n                        faces.push({ x, y, score: faceScore, width: blockSize, height: blockSize });\n                    }\n                }\n            }\n        }\n        \n        // Filter out weak detections and merge nearby regions\n        return this.refineFaceDetections(faces);\n    }\n    \n    calculateFaceScore(data, startX, startY, blockSize, width) {\n        let skinPixels = 0;\n        let totalPixels = 0;\n        let edgePixels = 0;\n        \n        for (let y = startY; y < startY + blockSize; y++) {\n            for (let x = startX; x < startX + blockSize; x++) {\n                if (y >= 0 && y < 480 && x >= 0 && x < width) {\n                    const i = (y * width + x) * 4;\n                    if (i < data.length - 3) {\n                        const r = data[i];\n                        const g = data[i + 1];\n                        const b = data[i + 2];\n                        \n                        totalPixels++;\n                        \n                        // Enhanced skin tone detection\n                        if (this.isEnhancedSkinTone(r, g, b)) {\n                            skinPixels++;\n                        }\n                        \n                        // Edge detection for facial features\n                        if (this.isEdgePixel(data, x, y, width)) {\n                            edgePixels++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (totalPixels === 0) return 0;\n        \n        const skinRatio = skinPixels / totalPixels;\n        const edgeRatio = edgePixels / totalPixels;\n        \n        // Combined score considering skin tone and facial features\n        return (skinRatio * 0.6) + (edgeRatio * 0.4);\n    }\n    \n    isEnhancedSkinTone(r, g, b) {\n        // More sophisticated skin tone detection\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        \n        return r > 95 && g > 40 && b > 20 && \n               max - min > 15 && \n               Math.abs(r - g) > 15 && \n               r > g && r > b &&\n               r < 255 && g < 200 && b < 170 &&\n               (r + g + b) > 200; // Ensure sufficient brightness\n    }\n    \n    isEdgePixel(data, x, y, width) {\n        const i = (y * width + x) * 4;\n        const rightI = (y * width + x + 1) * 4;\n        const downI = ((y + 1) * width + x) * 4;\n        \n        if (rightI >= data.length || downI >= data.length) return false;\n        \n        const grayCenter = (data[i] + data[i + 1] + data[i + 2]) / 3;\n        const grayRight = (data[rightI] + data[rightI + 1] + data[rightI + 2]) / 3;\n        const grayDown = (data[downI] + data[downI + 1] + data[downI + 2]) / 3;\n        \n        return Math.abs(grayCenter - grayRight) > 25 || Math.abs(grayCenter - grayDown) > 25;\n    }\n    \n    refineFaceDetections(faces) {\n        // Sort by score and filter out weak detections\n        faces.sort((a, b) => b.score - a.score);\n        \n        if (faces.length <= 1) return faces;\n        \n        // Remove overlapping detections (keep the stronger ones)\n        const refined = [];\n        for (let i = 0; i < faces.length; i++) {\n            const current = faces[i];\n            let isOverlapped = false;\n            \n            for (let j = 0; j < refined.length; j++) {\n                const existing = refined[j];\n                const distance = Math.sqrt(\n                    Math.pow(current.x - existing.x, 2) + \n                    Math.pow(current.y - existing.y, 2)\n                );\n                \n                if (distance < 60) { // Faces closer than 60 pixels are considered same person\n                    isOverlapped = true;\n                    break;\n                }\n            }\n            \n            if (!isOverlapped && current.score > 0.5) {\n                refined.push(current);\n            }\n        }\n        \n        return refined;\n    }\n    \n    isCameraBlocked(data) {\n        let darkPixels = 0;\n        const totalPixels = data.length / 4;\n        \n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n            const brightness = (r + g + b) / 3;\n            \n            if (brightness < 15) {\n                darkPixels++;\n            }\n        }\n        \n        // If more than 85% of pixels are very dark, camera is likely blocked\n        return (darkPixels / totalPixels) > 0.85;\n    }\n    \n    calculateAverageBrightness(data) {\n        let totalBrightness = 0;\n        const totalPixels = data.length / 4;\n        \n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n            totalBrightness += (r + g + b) / 3;\n        }\n        \n        return totalPixels > 0 ? totalBrightness / totalPixels : 0;\n    }\n    \n    checkFaceViolations(faceCount) {\n        if (faceCount === 0) {\n            this.noFaceDetectedCount++;\n            if (this.noFaceDetectedCount > 5) { // 10 seconds of no face\n                this.logViolation('no_face_detected', 'Participant not visible in camera', 'high');\n                this.noFaceDetectedCount = 0;\n            }\n        } else if (faceCount > 1) {\n            this.multipleFaceDetectedCount++;\n            if (this.multipleFaceDetectedCount > 3) { // 6 seconds of multiple faces\n                this.logViolation('multiple_faces', `${faceCount} faces detected in camera`, 'high');\n                this.multipleFaceDetectedCount = 0;\n            }\n        } else {\n            // Reset counters when normal\n            this.noFaceDetectedCount = 0;\n            this.multipleFaceDetectedCount = 0;\n        }\n    }\n    \n    detectSuspiciousMovement(currentData, previousData) {\n        let totalDiff = 0;\n        const data1 = currentData.data;\n        const data2 = previousData.data;\n        \n        // Calculate pixel differences\n        for (let i = 0; i < data1.length; i += 16) { // Sample every 4th pixel for performance\n            const diff = Math.abs(data1[i] - data2[i]) + \n                        Math.abs(data1[i + 1] - data2[i + 1]) + \n                        Math.abs(data1[i + 2] - data2[i + 2]);\n            totalDiff += diff;\n        }\n        \n        const avgDiff = totalDiff / (data1.length / 16);\n        \n        // Detect suspicious rapid movement\n        if (avgDiff > 50) {\n            this.suspiciousMovementCount++;\n            if (this.suspiciousMovementCount > 10) {\n                this.logViolation('suspicious_movement', 'Rapid or suspicious movement detected', 'medium');\n                this.suspiciousMovementCount = 0;\n            }\n        } else {\n            this.suspiciousMovementCount = Math.max(0, this.suspiciousMovementCount - 1);\n        }\n    }\n\n    setupEventListeners() {\n        // Tab switch detection\n        if (this.config.tabSwitchDetection) {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.logViolation('tab_switch', 'User switched away from quiz tab', 'high');\n                    this.notifyHostAdmin('Student switched away from quiz tab', 'high');\n                }\n            });\n        }\n\n        // Window blur detection\n        if (this.config.windowBlurDetection) {\n            window.addEventListener('blur', () => {\n                this.logViolation('window_blur', 'Quiz window lost focus', 'medium');\n                this.notifyHostAdmin('Student left quiz window', 'medium');\n            });\n        }\n\n        // Right-click prevention\n        if (this.config.rightClickDisabled) {\n            document.addEventListener('contextmenu', (e) => {\n                e.preventDefault();\n                this.logViolation('right_click_attempt', 'Right-click attempted', 'low');\n                return false;\n            });\n        }\n\n        // Enhanced copy/paste and security prevention\n        if (this.config.copyPasteDisabled) {\n            // Block text selection\n            document.body.style.userSelect = 'none';\n            document.body.style.webkitUserSelect = 'none';\n            document.body.style.mozUserSelect = 'none';\n            document.body.style.msUserSelect = 'none';\n            \n            // Disable drag and drop\n            document.addEventListener('dragstart', (e) => {\n                e.preventDefault();\n                return false;\n            });\n            \n            document.addEventListener('selectstart', (e) => {\n                e.preventDefault();\n                this.logViolation('text_selection', 'Text selection attempted', 'low');\n                return false;\n            });\n\n            // Block copy/paste events directly\n            document.addEventListener('copy', (e) => {\n                e.preventDefault();\n                this.logViolation('copy_attempt', 'Copy operation blocked', 'medium');\n                return false;\n            });\n\n            document.addEventListener('paste', (e) => {\n                e.preventDefault();\n                this.logViolation('paste_attempt', 'Paste operation blocked', 'medium');\n                return false;\n            });\n\n            document.addEventListener('cut', (e) => {\n                e.preventDefault();\n                this.logViolation('cut_attempt', 'Cut operation blocked', 'medium');\n                return false;\n            });\n\n            document.addEventListener('keydown', (e) => {\n                // Block comprehensive list of shortcuts\n                const blockedCombos = [\n                    // Copy/Paste operations\n                    { ctrl: true, key: 'c' },\n                    { ctrl: true, key: 'v' },\n                    { ctrl: true, key: 'a' },\n                    { ctrl: true, key: 'x' },\n                    { ctrl: true, key: 'z' },\n                    { ctrl: true, key: 's' },\n                    // Developer tools\n                    { key: 'F12' },\n                    { ctrl: true, shift: true, key: 'i' },\n                    { ctrl: true, shift: true, key: 'c' },\n                    { ctrl: true, shift: true, key: 'j' },\n                    { ctrl: true, shift: true, key: 'k' },\n                    { ctrl: true, key: 'u' },\n                    // Navigation\n                    { ctrl: true, key: 'r' },\n                    { key: 'F5' },\n                    { ctrl: true, key: 'h' },\n                    { ctrl: true, key: 'l' },\n                    { ctrl: true, key: 't' },\n                    { ctrl: true, key: 'n' },\n                    { ctrl: true, key: 'w' },\n                    { alt: true, key: 'F4' },\n                    // Print\n                    { ctrl: true, key: 'p' },\n                    { key: 'PrintScreen' }\n                ];\n\n                for (let combo of blockedCombos) {\n                    if ((!combo.ctrl || e.ctrlKey) && \n                        (!combo.shift || e.shiftKey) && \n                        (!combo.alt || e.altKey) && \n                        e.key.toLowerCase() === combo.key.toLowerCase()) {\n                        \n                        e.preventDefault();\n                        e.stopPropagation();\n                        this.logViolation('blocked_shortcut', `Blocked shortcut: ${combo.key}`, 'medium');\n                        this.notifyHostAdmin(`Student attempted blocked shortcut: ${combo.key}`, 'medium');\n                        return false;\n                    }\n                }\n            });\n        }\n\n        // Enhanced screenshot detection\n        this.setupScreenshotDetection();\n        \n        // Enhanced browser focus monitoring\n        this.setupBrowserFocusMonitoring();\n\n        // Enhanced screenshot detection and prevention\n        if (this.config.screenshotDetection) {\n            // Print Screen key detection\n            document.addEventListener('keydown', (e) => {\n                if (e.key === 'PrintScreen') {\n                    e.preventDefault();\n                    this.logViolation('screenshot_attempt', 'Screenshot attempt blocked', 'high');\n                    return false;\n                }\n            });\n            \n            document.addEventListener('keyup', (e) => {\n                if (e.key === 'PrintScreen') {\n                    e.preventDefault();\n                    this.logViolation('screenshot_attempt', 'Screenshot key detected', 'high');\n                    return false;\n                }\n            });\n            \n            // Detect screenshot via clipboard API\n            document.addEventListener('paste', (e) => {\n                if (e.clipboardData && e.clipboardData.files.length > 0) {\n                    this.logViolation('screenshot_detected', 'Screenshot pasted from clipboard', 'high');\n                }\n            });\n            \n            // Block Windows snipping tool shortcuts\n            document.addEventListener('keydown', (e) => {\n                // Windows + Shift + S (Snipping Tool)\n                if (e.metaKey && e.shiftKey && e.key === 'S') {\n                    e.preventDefault();\n                    this.logViolation('snipping_tool_blocked', 'Snipping tool shortcut blocked', 'high');\n                    return false;\n                }\n            });\n            \n            // Detect screen recording software shortcuts\n            const screenRecordShortcuts = [\n                { alt: true, key: 'r' }, // Common screen record\n                { ctrl: true, shift: true, key: 'r' }, // Various screen recorders\n                { meta: true, shift: true, key: 'r' }, // Mac screen record\n            ];\n            \n            document.addEventListener('keydown', (e) => {\n                for (let combo of screenRecordShortcuts) {\n                    if ((!combo.ctrl || e.ctrlKey) && \n                        (!combo.shift || e.shiftKey) && \n                        (!combo.alt || e.altKey) && \n                        (!combo.meta || e.metaKey) && \n                        e.key.toLowerCase() === combo.key.toLowerCase()) {\n                        \n                        e.preventDefault();\n                        e.stopPropagation();\n                        this.logViolation('screen_record_blocked', 'Screen recording shortcut blocked', 'high');\n                        return false;\n                    }\n                }\n            });\n        }\n\n        // Multiple tab detection\n        if (this.config.multipleTabDetection) {\n            window.addEventListener('storage', (e) => {\n                if (e.key === 'quiz_active_tab') {\n                    this.logViolation('multiple_tabs', 'Multiple quiz tabs detected', 'high');\n                }\n            });\n            localStorage.setItem('quiz_active_tab', this.attemptId);\n        }\n\n        // Fullscreen change detection\n        document.addEventListener('fullscreenchange', () => {\n            if (!document.fullscreenElement && this.config.fullscreenEnforcement) {\n                this.logViolation('fullscreen_exit', 'Exited fullscreen mode', 'medium');\n                this.enforceFullscreen();\n            }\n        });\n\n        // Mouse movement tracking (for unusual patterns)\n        if (this.config.mouseMoveTracking) {\n            let mouseMovements = [];\n            document.addEventListener('mousemove', (e) => {\n                mouseMovements.push({\n                    x: e.clientX,\n                    y: e.clientY,\n                    timestamp: Date.now()\n                });\n                \n                // Keep only recent movements (last 10 seconds)\n                const cutoff = Date.now() - 10000;\n                mouseMovements = mouseMovements.filter(m => m.timestamp > cutoff);\n                \n                // Detect unusual patterns (e.g., too regular/automated movement)\n                if (mouseMovements.length > 100) {\n                    this.analyzeMouseMovements(mouseMovements);\n                }\n            });\n        }\n\n        // Face detection setup\n        if (this.config.faceDetection && this.videoElement) {\n            this.videoElement.addEventListener('loadedmetadata', () => {\n                this.startFaceDetection();\n            });\n        }\n\n        // DevTools detection\n        if (this.config.devToolsDetection) {\n            this.detectDevTools();\n        }\n    }\n\n    startMonitoring() {\n        this.isActive = true;\n        \n        // Start periodic checks\n        this.detectionInterval = setInterval(() => {\n            this.performPeriodicChecks();\n        }, 5000); // Check every 5 seconds\n\n        console.log('Proctoring monitoring started');\n    }\n\n    stopMonitoring() {\n        this.isActive = false;\n        \n        if (this.detectionInterval) {\n            clearInterval(this.detectionInterval);\n        }\n        \n        if (this.mediaStream) {\n            this.mediaStream.getTracks().forEach(track => track.stop());\n        }\n        \n        if (this.videoElement && this.videoElement.parentNode) {\n            this.videoElement.parentNode.removeChild(this.videoElement);\n        }\n\n        localStorage.removeItem('quiz_active_tab');\n        \n        console.log('Proctoring monitoring stopped');\n    }\n\n    startFaceDetection() {\n        if (!this.videoElement || !this.canvas) return;\n\n        const detectFaces = () => {\n            if (!this.isActive) return;\n\n            this.context.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);\n            \n            // Basic face detection using image analysis\n            // In a real implementation, you would use a proper face detection library\n            const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n            const faceCount = this.analyzeImageForFaces(imageData);\n            \n            if (faceCount === 0) {\n                this.logViolation('no_face_detected', 'No face detected in camera', 'high');\n            } else if (faceCount > 1) {\n                this.logViolation('multiple_faces', `${faceCount} faces detected`, 'high');\n            }\n            \n            // Continue detection\n            setTimeout(detectFaces, 2000); // Check every 2 seconds\n        };\n\n        detectFaces();\n    }\n\n    analyzeImageForFaces(imageData) {\n        // Simplified face detection - in production, use proper libraries like face-api.js\n        // This is a placeholder that returns a random number for demonstration\n        \n        // Check for basic skin color detection\n        const data = imageData.data;\n        let skinPixels = 0;\n        const totalPixels = data.length / 4;\n        \n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n            \n            // Simple skin color detection\n            if (r > 95 && g > 40 && b > 20 && \n                Math.max(r, g, b) - Math.min(r, g, b) > 15 &&\n                Math.abs(r - g) > 15 && r > g && r > b) {\n                skinPixels++;\n            }\n        }\n        \n        const skinRatio = skinPixels / totalPixels;\n        \n        // Estimate face count based on skin ratio\n        if (skinRatio > 0.1) return 1; // Assume one face\n        if (skinRatio > 0.2) return 2; // Might be multiple faces\n        return 0; // No face detected\n    }\n\n    analyzeMouseMovements(movements) {\n        // Detect if movements are too regular (possible automation)\n        if (movements.length < 10) return;\n        \n        const distances = [];\n        const intervals = [];\n        \n        for (let i = 1; i < movements.length; i++) {\n            const prev = movements[i - 1];\n            const curr = movements[i];\n            \n            const distance = Math.sqrt(\n                Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)\n            );\n            const interval = curr.timestamp - prev.timestamp;\n            \n            distances.push(distance);\n            intervals.push(interval);\n        }\n        \n        // Calculate variance in distances and intervals\n        const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;\n        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;\n        \n        const distanceVariance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;\n        const intervalVariance = intervals.reduce((sum, i) => sum + Math.pow(i - avgInterval, 2), 0) / intervals.length;\n        \n        // If movements are too regular, it might be automated\n        if (distanceVariance < 5 && intervalVariance < 100) {\n            this.logViolation('suspicious_mouse_pattern', 'Detected potentially automated mouse movements', 'medium');\n        }\n    }\n\n    detectDevTools() {\n        // Multiple methods to detect developer tools\n        let devtools = {open: false, orientation: null};\n        \n        setInterval(() => {\n            if (window.outerHeight - window.innerHeight > 200 || \n                window.outerWidth - window.innerWidth > 200) {\n                if (!devtools.open) {\n                    devtools.open = true;\n                    this.logViolation('devtools_opened', 'Developer tools opened', 'high');\n                }\n            } else {\n                devtools.open = false;\n            }\n        }, 500);\n\n        // Detect console access\n        let consoleOpened = false;\n        Object.defineProperty(console, '_commandLineAPI', {\n            get: function() {\n                if (!consoleOpened) {\n                    consoleOpened = true;\n                    proctoringManager.logViolation('console_access', 'Console accessed', 'high');\n                }\n                return undefined;\n            }\n        });\n    }\n\n    performPeriodicChecks() {\n        // Check window dimensions for unusual changes\n        if (window.innerWidth < 800 || window.innerHeight < 600) {\n            this.logViolation('window_resize', 'Window resized to unusually small dimensions', 'medium');\n        }\n        \n        // Check if page is in focus\n        if (document.hasFocus && !document.hasFocus()) {\n            this.logViolation('focus_lost', 'Page lost focus', 'medium');\n        }\n        \n        // Check for multiple instances\n        const tabCount = localStorage.getItem('quiz_tab_count') || '0';\n        if (parseInt(tabCount) > 1) {\n            this.logViolation('multiple_instances', 'Multiple quiz instances detected', 'high');\n        }\n    }\n\n    enforceFullscreen() {\n        if (document.documentElement.requestFullscreen) {\n            document.documentElement.requestFullscreen();\n        }\n    }\n\n    logViolation(type, description, severity = 'medium') {\n        if (this.isTerminated) {\n            return; // No more violations after termination\n        }\n        \n        const violation = {\n            type: type,\n            description: description,\n            severity: severity,\n            timestamp: new Date().toISOString(),\n            attemptId: this.attemptId,\n            userAgent: navigator.userAgent,\n            url: window.location.href\n        };\n        \n        this.violations.push(violation);\n        \n        // Enhanced violation tracking\n        this.violationCount++;\n        if (severity === 'high') {\n            this.highSeverityCount++;\n        }\n        \n        // Store in violation buffer for pattern analysis\n        this.violationBuffer.push({\n            ...violation,\n            timestamp: Date.now()\n        });\n        \n        // Clean old violations (last 5 minutes)\n        const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);\n        this.violationBuffer = this.violationBuffer.filter(v => v.timestamp > fiveMinutesAgo);\n        \n        console.warn('Proctoring violation:', violation);\n        console.warn(`Total violations: ${this.violationCount}, High severity: ${this.highSeverityCount}`);\n        \n        // Check for immediate termination conditions\n        if (this.shouldTerminateQuiz(violation)) {\n            this.terminateQuiz(violation);\n            return;\n        }\n        \n        // Send to server\n        this.sendViolationToServer(violation);\n        \n        // Show warning to user\n        this.showViolationWarning(violation);\n        \n        // Update security status display\n        this.updateSecurityStatus();\n    }\n\n    async sendViolationToServer(violation) {\n        try {\n            const response = await fetch('/api/proctoring/event', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(violation)\n            });\n            \n            if (!response.ok) {\n                console.error('Failed to send violation to server');\n                return;\n            }\n            \n            const result = await response.json();\n            \n            // If quiz is terminated due to violation, trigger local termination\n            if (result.status === 'terminated') {\n                this.isTerminated = true;\n                this.showTerminationMessage({\n                    type: 'server_terminated',\n                    description: result.message || 'Quiz terminated by security system',\n                    severity: 'critical'\n                });\n                return;\n            }\n        } catch (error) {\n            console.error('Error sending violation to server:', error);\n        }\n    }\n\n    showViolationWarning(violation) {\n        const warningDiv = document.createElement('div');\n        warningDiv.className = 'alert alert-warning alert-dismissible fade show position-fixed';\n        warningDiv.style.cssText = `\n            top: 120px;\n            right: 20px;\n            z-index: 1051;\n            max-width: 350px;\n        `;\n        \n        let message = 'Proctoring Alert: ';\n        switch (violation.severity) {\n            case 'high':\n                message = '[CRITICAL] Security Violation: ';\n                warningDiv.className = warningDiv.className.replace('alert-warning', 'alert-danger');\n                break;\n            case 'medium':\n                message = '[WARNING] Proctoring Warning: ';\n                break;\n            case 'low':\n                message = '[INFO] Proctoring Notice: ';\n                warningDiv.className = warningDiv.className.replace('alert-warning', 'alert-info');\n                break;\n        }\n        \n        warningDiv.innerHTML = `\n            <strong>${message}</strong>${violation.description}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        document.body.appendChild(warningDiv);\n        \n        // Auto-remove after 8 seconds\n        setTimeout(() => {\n            if (warningDiv.parentNode) {\n                warningDiv.remove();\n            }\n        }, 8000);\n        \n        // Play warning sound\n        this.playWarningSound();\n    }\n    \n    shouldTerminateQuiz(violation) {\n        if (this.isTerminated) {\n            return false;\n        }\n        \n        // Immediate termination violations (zero tolerance)\n        const immediateTerminationTypes = [\n            'console_access',\n            'multiple_instances',\n            'devtools_opened'\n        ];\n        \n        if (immediateTerminationTypes.includes(violation.type)) {\n            return true;\n        }\n        \n        // Terminate after maximum violations reached\n        if (this.violationCount >= this.maxViolations) {\n            return true;\n        }\n        \n        // Terminate after 2 high severity violations\n        if (this.highSeverityCount >= 2) {\n            return true;\n        }\n        \n        // Terminate if too many violations in short time (4 violations in 2 minutes)\n        const twoMinutesAgo = Date.now() - (2 * 60 * 1000);\n        const recentViolations = this.violationBuffer.filter(v => v.timestamp > twoMinutesAgo);\n        if (recentViolations.length >= 4) {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    terminateQuiz(triggerViolation) {\n        this.isTerminated = true;\n        this.isActive = false;\n        \n        // Stop all monitoring\n        this.stopMonitoring();\n        \n        // Log the termination\n        const terminationViolation = {\n            type: 'quiz_terminated',\n            description: `Quiz terminated due to: ${triggerViolation.description}`,\n            severity: 'critical',\n            timestamp: new Date().toISOString(),\n            attemptId: this.attemptId,\n            userAgent: navigator.userAgent,\n            url: window.location.href,\n            triggerViolation: triggerViolation\n        };\n        \n        // Send termination event to server\n        fetch('/api/proctoring/event', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(terminationViolation)\n        }).catch(error => {\n            console.error('Failed to send termination event:', error);\n        });\n        \n        // Show termination message\n        this.showTerminationMessage(triggerViolation);\n        \n        // Disable all form inputs\n        this.disableQuizInterface();\n        \n        // Auto-redirect after 10 seconds\n        setTimeout(() => {\n            window.location.href = '/dashboard';\n        }, 10000);\n    }\n    \n    showTerminationMessage(violation) {\n        // Remove all existing alerts\n        document.querySelectorAll('.alert').forEach(alert => alert.remove());\n        \n        // Create termination overlay\n        const overlay = document.createElement('div');\n        overlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(220, 53, 69, 0.95);\n            z-index: 10000;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-family: Arial, sans-serif;\n        `;\n        \n        overlay.innerHTML = `\n            <div style=\"text-align: center; max-width: 600px; padding: 40px;\">\n                <i class=\"fas fa-exclamation-triangle\" style=\"font-size: 80px; margin-bottom: 20px; color: #fff;\"></i>\n                <h1 style=\"font-size: 2.5rem; margin-bottom: 20px; color: #fff;\">QUIZ TERMINATED</h1>\n                <h3 style=\"margin-bottom: 30px; color: #fff;\">[CRITICAL] SECURITY VIOLATION DETECTED</h3>\n                <div style=\"background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin-bottom: 30px;\">\n                    <p style=\"font-size: 1.2rem; margin-bottom: 10px; color: #fff;\"><strong>Violation Type:</strong> ${violation.type.replace('_', ' ').toUpperCase()}</p>\n                    <p style=\"font-size: 1.1rem; margin-bottom: 10px; color: #fff;\"><strong>Description:</strong> ${violation.description}</p>\n                    <p style=\"font-size: 1rem; color: #fff;\"><strong>Total Violations:</strong> ${this.violationCount}</p>\n                </div>\n                <div style=\"background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;\">\n                    <p style=\"margin: 0; font-size: 1rem; color: #fff;\">[WARNING] Your exam session has been flagged for review</p>\n                    <p style=\"margin: 5px 0 0 0; font-size: 0.9rem; color: #fff;\">Contact your administrator for retake permissions</p>\n                </div>\n                <p style=\"font-size: 1rem; margin-bottom: 0; color: #fff;\">Redirecting to dashboard in <span id=\"countdown\">10</span> seconds...</p>\n            </div>\n        `;\n        \n        document.body.appendChild(overlay);\n        \n        // Countdown timer\n        let countdown = 10;\n        const countdownElement = document.getElementById('countdown');\n        const timer = setInterval(() => {\n            countdown--;\n            if (countdownElement) {\n                countdownElement.textContent = countdown;\n            }\n            if (countdown <= 0) {\n                clearInterval(timer);\n            }\n        }, 1000);\n        \n        // Play termination sound\n        this.playTerminationSound();\n    }\n    \n    updateSecurityStatus() {\n        let status = 'secure';\n        let message = `[INFO] Secure - ${this.violationCount} violations detected`;\n        \n        if (this.violationCount >= 1) {\n            status = 'warning';\n            message = `? Warning - ${this.violationCount} violations (${this.maxViolations - this.violationCount} remaining)`;\n        }\n        \n        if (this.violationCount >= this.maxViolations - 1) {\n            status = 'danger';\n            message = `? Critical - ${this.violationCount} violations (1 more will terminate quiz)`;\n        }\n        \n        if (this.highSeverityCount >= 1) {\n            status = 'danger';\n            message = `? High Risk - ${this.highSeverityCount} high-severity violations detected`;\n        }\n        \n        this.showProctoringStatus(status, message);\n    }\n    \n    disableQuizInterface() {\n        // Disable all form inputs\n        const form = document.getElementById('quiz-form');\n        if (form) {\n            const inputs = form.querySelectorAll('input, textarea, button, select');\n            inputs.forEach(input => {\n                input.disabled = true;\n                input.style.opacity = '0.5';\n            });\n        }\n        \n        // Add overlay to prevent interaction\n        const overlay = document.createElement('div');\n        overlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0,0,0,0.3);\n            z-index: 999;\n            pointer-events: none;\n        `;\n        document.body.appendChild(overlay);\n    }\n    \n    playTerminationSound() {\n        try {\n            // Create termination sound sequence\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            \n            // Create dramatic sound sequence\n            const frequencies = [880, 659, 523, 440];  // A5, E5, C5, A4\n            \n            frequencies.forEach((freq, index) => {\n                const oscillator = audioContext.createOscillator();\n                const gainNode = audioContext.createGain();\n                \n                oscillator.connect(gainNode);\n                gainNode.connect(audioContext.destination);\n                \n                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.3);\n                oscillator.type = 'square';\n                \n                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + index * 0.3);\n                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.3 + 0.2);\n                \n                oscillator.start(audioContext.currentTime + index * 0.3);\n                oscillator.stop(audioContext.currentTime + index * 0.3 + 0.2);\n            });\n        } catch (error) {\n            console.error('Failed to play termination sound:', error);\n        }\n    }\n    \n    stopMonitoring() {\n        // Stop all monitoring activities\n        if (this.mediaStream) {\n            const tracks = this.mediaStream.getTracks();\n            tracks.forEach(track => track.stop());\n        }\n        \n        // Clear intervals\n        if (this.detectionInterval) {\n            clearInterval(this.detectionInterval);\n        }\n        \n        // Hide camera view\n        if (this.videoElement) {\n            this.videoElement.style.display = 'none';\n        }\n        \n        this.isActive = false;\n    }\n\n    showProctoringStatus(status, message = '') {\n        let existingIndicator = document.getElementById('proctoring-indicator');\n        \n        if (existingIndicator) {\n            existingIndicator.remove();\n        }\n        \n        const indicator = document.createElement('div');\n        indicator.id = 'proctoring-indicator';\n        indicator.className = 'proctoring-indicator';\n        \n        switch (status) {\n            case 'active':\n                indicator.className += ' proctoring-active';\n                indicator.innerHTML = '<i class=\"fas fa-eye\"></i> Proctoring Active';\n                break;\n            case 'error':\n                indicator.className += ' proctoring-violation';\n                indicator.innerHTML = `<i class=\"fas fa-exclamation-triangle\"></i> Error: ${message}`;\n                break;\n            case 'inactive':\n                indicator.className += ' bg-secondary text-white';\n                indicator.innerHTML = '<i class=\"fas fa-eye-slash\"></i> Proctoring Inactive';\n                break;\n        }\n        \n        document.body.appendChild(indicator);\n    }\n\n    playWarningSound() {\n        try {\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            // Create warning sound pattern\n            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);\n            oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);\n            oscillator.frequency.setValueAtTime(400, audioContext.currentTime + 0.2);\n            \n            oscillator.type = 'square';\n            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.3);\n        } catch (e) {\n            console.log('Audio warning not available');\n        }\n    }\n\n    getViolationSummary() {\n        const summary = {\n            total: this.violations.length,\n            high: this.violations.filter(v => v.severity === 'high').length,\n            medium: this.violations.filter(v => v.severity === 'medium').length,\n            low: this.violations.filter(v => v.severity === 'low').length,\n            types: {}\n        };\n        \n        this.violations.forEach(v => {\n            summary.types[v.type] = (summary.types[v.type] || 0) + 1;\n        });\n        \n        return summary;\n    }\n    \n    // Enhanced auto-termination functionality\n    terminateQuizImmediately(reason) {\n        if (this.isTerminated) return;\n        \n        this.isTerminated = true;\n        console.error('Auto-terminating quiz:', reason);\n        \n        // Send termination request to server\n        fetch(`/api/monitoring/auto-terminate/${this.attemptId}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ reason: reason })\n        }).then(response => response.json())\n        .then(data => {\n            if (data.success) {\n                this.showTerminationScreen(reason);\n            }\n        }).catch(error => {\n            console.error('Failed to terminate quiz:', error);\n            // Force termination anyway\n            this.showTerminationScreen(reason);\n        });\n    }\n    \n    showTerminationScreen(reason) {\n        // Create full-screen termination overlay\n        const overlay = document.createElement('div');\n        overlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: #dc3545;\n            z-index: 10000;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            color: white;\n            font-family: Arial, sans-serif;\n        `;\n        \n        const messageBox = document.createElement('div');\n        messageBox.style.cssText = `\n            text-align: center;\n            padding: 40px;\n            max-width: 600px;\n        `;\n        \n        messageBox.innerHTML = `\n            <h1 style=\"margin-bottom: 30px; font-size: 3em;\">? QUIZ TERMINATED</h1>\n            <h2 style=\"margin-bottom: 20px;\">Security Violation Detected</h2>\n            <p style=\"font-size: 1.2em; margin-bottom: 30px;\">${reason}</p>\n            <p style=\"font-size: 1em;\">Contact your instructor if you believe this is an error.</p>\n            <p style=\"font-size: 0.9em; margin-top: 30px;\">This session has been recorded for review.</p>\n        `;\n        \n        overlay.appendChild(messageBox);\n        document.body.appendChild(overlay);\n        \n        // Completely lock down the page\n        this.lockdownPage();\n        \n        // Auto-redirect after 10 seconds\n        setTimeout(() => {\n            window.location.href = '/participant/dashboard';\n        }, 10000);\n    }\n    \n    lockdownPage() {\n        // Block all keyboard events\n        document.addEventListener('keydown', function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n        }, true);\n        \n        // Block right-click\n        document.addEventListener('contextmenu', function(e) {\n            e.preventDefault();\n            return false;\n        }, true);\n        \n        // Block text selection\n        document.addEventListener('selectstart', function(e) {\n            e.preventDefault();\n            return false;\n        }, true);\n    }\n    \n    // Enhanced device logging for security tracking\n    logDeviceInfo() {\n        const deviceInfo = {\n            userAgent: navigator.userAgent,\n            screenResolution: `${screen.width}x${screen.height}`,\n            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n            language: navigator.language,\n            platform: navigator.platform,\n            cookieEnabled: navigator.cookieEnabled,\n            onLine: navigator.onLine,\n            quizId: this.quizId || null\n        };\n        \n        deviceInfo.deviceType = this.detectDeviceType();\n        deviceInfo.browserInfo = this.getBrowserInfo();\n        \n        // Send to server for logging\n        fetch('/api/device-log', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(deviceInfo)\n        }).catch(error => {\n            console.error('Failed to log device info:', error);\n        });\n    }\n    \n    detectDeviceType() {\n        const userAgent = navigator.userAgent;\n        if (/tablet/i.test(userAgent)) return 'tablet';\n        if (/mobile/i.test(userAgent)) return 'mobile';\n        return 'desktop';\n    }\n    \n    getBrowserInfo() {\n        const userAgent = navigator.userAgent;\n        let browser = 'Unknown';\n        \n        if (userAgent.indexOf('Chrome') > -1) browser = 'Chrome';\n        else if (userAgent.indexOf('Firefox') > -1) browser = 'Firefox';\n        else if (userAgent.indexOf('Safari') > -1) browser = 'Safari';\n        else if (userAgent.indexOf('Edge') > -1) browser = 'Edge';\n        \n        return `${browser} ${navigator.appVersion}`;\n    }\n\n    // NEW: Helper methods for Moodle Proctoring Pro-style features\n    showVerificationModal() {\n        const modal = document.createElement('div');\n        modal.id = 'face-verification-modal';\n        modal.style.cssText = `\n            position: fixed; top: 0; left: 0; width: 100%; height: 100%;\n            background: rgba(0,0,0,0.8); z-index: 10000; display: flex;\n            align-items: center; justify-content: center; color: white;\n        `;\n        \n        modal.innerHTML = `\n            <div style=\"background: #343a40; padding: 30px; border-radius: 10px; text-align: center; max-width: 500px;\">\n                <h2 style=\"margin-bottom: 20px;\">? Identity Verification Required</h2>\n                <p style=\"margin-bottom: 20px;\">Please verify your identity before starting the exam.</p>\n                <p style=\"margin-bottom: 30px; font-size: 0.9em; color: #adb5bd;\">\n                    Look directly at the camera and ensure good lighting for best results.\n                </p>\n                <div id=\"verification-preview\" style=\"margin-bottom: 20px; width: 320px; height: 240px; background: #000; border-radius: 8px; margin: 0 auto 20px;\"></div>\n                <button id=\"capture-verification-btn\" class=\"btn btn-primary\" style=\"margin-right: 10px;\">\n                    ? Capture & Verify\n                </button>\n                <button id=\"cancel-verification-btn\" class=\"btn btn-secondary\">Cancel</button>\n            </div>\n        `;\n        \n        document.body.appendChild(modal);\n        \n        // Handle cancel\n        document.getElementById('cancel-verification-btn').addEventListener('click', () => {\n            this.hideVerificationModal();\n            window.location.href = '/dashboard';\n        });\n    }\n\n    async captureVerificationImage() {\n        if (!this.videoElement || !this.canvas) {\n            throw new Error('Camera not available for verification');\n        }\n        \n        // Capture current frame\n        this.context.drawImage(this.videoElement, 0, 0, 640, 480);\n        return this.canvas.toDataURL('image/jpeg', this.config.imageQuality);\n    }\n\n    async verifyUserIdentity(imageData) {\n        try {\n            const response = await fetch('/api/proctoring/verify-identity', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    image: imageData,\n                    attemptId: this.attemptId\n                })\n            });\n            \n            const result = await response.json();\n            return result.verified === true;\n        } catch (error) {\n            console.error('Identity verification failed:', error);\n            return false; // Fail safe\n        }\n    }\n\n    // ===== REAL-TIME NOTIFICATION SYSTEM =====\n    notifyHostAdmin(message, severity = 'medium') {\n        // Send immediate notification to hosts and admins\n        const notification = {\n            message,\n            severity,\n            student: this.getStudentInfo(),\n            timestamp: new Date().toISOString(),\n            attemptId: this.attemptId\n        };\n\n        // Send via real-time WebSocket if available\n        if (window.realTimeSocket && window.realTimeSocket.connected) {\n            window.realTimeSocket.emit('violation_alert', {\n                student: this.getStudentInfo(),\n                violationType: 'proctoring_violation',\n                message: message,\n                severity: severity,\n                timestamp: new Date().toISOString(),\n                attemptId: this.attemptId\n            });\n        }\n\n        // Also send via HTTP API as backup\n        fetch('/api/proctoring/notify-violation', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(notification)\n        }).catch(err => console.error('Failed to send violation notification:', err));\n    }\n\n    getStudentInfo() {\n        // Get student identification info for notifications\n        return {\n            id: window.currentUserId || 'unknown',\n            name: window.currentUserName || 'Unknown Student',\n            email: window.currentUserEmail || 'unknown@example.com'\n        };\n    }\n\n    setupScreenshotDetection() {\n        // Enhanced screenshot detection beyond just PrintScreen key\n        \n        // Detect print screen attempts\n        document.addEventListener('keyup', (e) => {\n            if (e.key === 'PrintScreen') {\n                this.logViolation('screenshot_attempt', 'Screenshot attempt detected (PrintScreen)', 'high');\n                this.notifyHostAdmin('Student attempted to take screenshot', 'high');\n            }\n        });\n\n        // Monitor clipboard for screenshot pastes\n        document.addEventListener('paste', (e) => {\n            const items = e.clipboardData?.items;\n            if (items) {\n                for (let item of items) {\n                    if (item.type.indexOf('image') !== -1) {\n                        this.logViolation('image_paste', 'Image pasted from clipboard (possible screenshot)', 'high');\n                        this.notifyHostAdmin('Student pasted image from clipboard', 'high');\n                        break;\n                    }\n                }\n            }\n        });\n    }\n\n    setupBrowserFocusMonitoring() {\n        // Enhanced focus monitoring with multiple detection methods\n        let focusLostTime = 0;\n\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                focusLostTime = Date.now();\n            } else if (focusLostTime > 0) {\n                const timeAway = Date.now() - focusLostTime;\n                if (timeAway > 3000) { // More than 3 seconds away\n                    this.logViolation('extended_focus_loss', \n                        `Student was away for ${Math.round(timeAway/1000)} seconds`, 'high');\n                    this.notifyHostAdmin(`Student was away from quiz for ${Math.round(timeAway/1000)} seconds`, 'high');\n                }\n                focusLostTime = 0;\n            }\n        });\n\n        // Mouse leave detection (student left quiz area)\n        document.addEventListener('mouseleave', () => {\n            this.logViolation('mouse_left_window', 'Mouse cursor left the quiz window', 'low');\n        });\n    }\n\n    hideVerificationModal() {\n        const modal = document.getElementById('face-verification-modal');\n        if (modal) modal.remove();\n    }\n\n    blockQuizAccess(message) {\n        document.body.innerHTML = `\n            <div style=\"display: flex; align-items: center; justify-content: center; height: 100vh; background: #dc3545; color: white; font-family: Arial;\">\n                <div style=\"text-align: center; max-width: 600px; padding: 40px;\">\n                    <h1 style=\"margin-bottom: 30px;\">? Access Denied</h1>\n                    <h3 style=\"margin-bottom: 20px;\">Face Verification Failed</h3>\n                    <p style=\"margin-bottom: 30px; font-size: 1.1em;\">${message}</p>\n                    <p>Please contact your instructor for assistance.</p>\n                    <button onclick=\"window.location.href='/dashboard'\" style=\"margin-top: 20px; padding: 10px 20px; background: white; color: #dc3545; border: none; border-radius: 5px; cursor: pointer;\">\n                        Return to Dashboard\n                    </button>\n                </div>\n            </div>\n        `;\n    }\n\n    async captureCurrentFrame() {\n        if (!this.videoElement || !this.canvas) {\n            throw new Error('Camera not available for capture');\n        }\n        \n        this.context.drawImage(this.videoElement, 0, 0, 640, 480);\n        return this.canvas.toDataURL('image/jpeg', this.config.imageQuality);\n    }\n\n    async sendCapturedImage(imageData) {\n        try {\n            await fetch('/api/proctoring/image-capture', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    image: imageData,\n                    attemptId: this.attemptId,\n                    timestamp: new Date().toISOString()\n                })\n            });\n        } catch (error) {\n            console.error('Failed to send captured image:', error);\n        }\n    }\n}\n\n// Global initialization function\nfunction initializeProctoring(attemptId) {\n    if (window.proctoringManager) {\n        window.proctoringManager.stopMonitoring();\n    }\n    \n    window.proctoringManager = new ProctoringManager(attemptId);\n}\n\n// Auto-cleanup when page unloads\nwindow.addEventListener('beforeunload', () => {\n    if (window.proctoringManager) {\n        window.proctoringManager.stopMonitoring();\n    }\n});\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ProctoringManager;\n}\n","size_bytes":73825},"static/js/quiz.js":{"content":"// Quiz.js - Enhanced quiz functionality with proctoring integration and heatmap tracking\n\nclass HeatmapTracker {\n    constructor(attemptId) {\n        this.attemptId = attemptId;\n        this.questionStartTimes = new Map();\n        this.interactionQueue = [];\n        this.isTracking = true;\n        this.flushInterval = null;\n        this.currentQuestionId = null;\n        \n        this.initializeTracking();\n    }\n    \n    initializeTracking() {\n        if (!this.isTracking) return;\n        \n        // Store event listeners for cleanup\n        this.eventListeners = [];\n        \n        // Start periodic data flushing\n        this.flushInterval = setInterval(() => {\n            this.flushInteractions();\n        }, 5000); // Flush every 5 seconds\n        \n        // Track mouse clicks\n        this.clickHandler = (e) => this.trackInteraction('click', e);\n        document.addEventListener('click', this.clickHandler);\n        this.eventListeners.push(['document', 'click', this.clickHandler]);\n        \n        // Track mouse movement (throttled)\n        this.setupMouseMovementTracking();\n        \n        // Track mouse hovers on question elements\n        document.querySelectorAll('.question-card, .question-input, .form-check').forEach(element => {\n            const enterHandler = (e) => this.trackInteraction('hover_start', e);\n            const leaveHandler = (e) => this.trackInteraction('hover_end', e);\n            \n            element.addEventListener('mouseenter', enterHandler);\n            element.addEventListener('mouseleave', leaveHandler);\n            \n            this.eventListeners.push(['element', element, 'mouseenter', enterHandler]);\n            this.eventListeners.push(['element', element, 'mouseleave', leaveHandler]);\n        });\n        \n        // Track question focus/visibility changes\n        this.setupQuestionVisibilityTracking();\n        \n        // Track scroll behavior\n        this.setupScrollTracking();\n        \n        // Track window focus/blur\n        this.focusHandler = () => this.trackInteraction('window_focus');\n        this.blurHandler = () => this.trackInteraction('window_blur');\n        \n        window.addEventListener('focus', this.focusHandler);\n        window.addEventListener('blur', this.blurHandler);\n        \n        this.eventListeners.push(['window', 'focus', this.focusHandler]);\n        this.eventListeners.push(['window', 'blur', this.blurHandler]);\n        \n        // Setup final data delivery on page unload\n        this.setupFinalDelivery();\n    }\n    \n    setupMouseMovementTracking() {\n        let lastMouseTime = 0;\n        let lastX = -1, lastY = -1;\n        const MOUSE_THROTTLE = 100; // Limit to ~10 Hz\n        \n        this.mouseMoveHandler = (e) => {\n            const now = Date.now();\n            \n            // Throttle mouse movement events\n            if (now - lastMouseTime < MOUSE_THROTTLE) return;\n            \n            // Skip if mouse hasn't moved significantly\n            const deltaX = Math.abs(e.clientX - lastX);\n            const deltaY = Math.abs(e.clientY - lastY);\n            if (deltaX < 5 && deltaY < 5) return;\n            \n            lastMouseTime = now;\n            lastX = e.clientX;\n            lastY = e.clientY;\n            \n            this.trackInteraction('mouse_move', e);\n        };\n        \n        document.addEventListener('mousemove', this.mouseMoveHandler);\n        this.eventListeners.push(['document', 'mousemove', this.mouseMoveHandler]);\n    }\n    \n    setupScrollTracking() {\n        let scrollTimeout;\n        this.scrollHandler = () => {\n            clearTimeout(scrollTimeout);\n            scrollTimeout = setTimeout(() => {\n                this.trackInteraction('scroll', null, {\n                    scrollTop: window.pageYOffset,\n                    scrollLeft: window.pageXOffset\n                });\n            }, 150); // Debounce scroll events\n        };\n        \n        document.addEventListener('scroll', this.scrollHandler);\n        this.eventListeners.push(['document', 'scroll', this.scrollHandler]);\n    }\n    \n    setupFinalDelivery() {\n        // Use beforeunload and visibilitychange for final data delivery\n        this.beforeUnloadHandler = (e) => {\n            this.sendFinalBatch();\n        };\n        \n        this.visibilityChangeHandler = () => {\n            if (document.visibilityState === 'hidden') {\n                this.sendFinalBatch();\n            }\n        };\n        \n        window.addEventListener('beforeunload', this.beforeUnloadHandler);\n        document.addEventListener('visibilitychange', this.visibilityChangeHandler);\n        \n        this.eventListeners.push(['window', 'beforeunload', this.beforeUnloadHandler]);\n        this.eventListeners.push(['document', 'visibilitychange', this.visibilityChangeHandler]);\n    }\n    \n    setupQuestionVisibilityTracking() {\n        // Use Intersection Observer to track which questions are visible\n        this.visibilityObserver = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                const questionCard = entry.target;\n                const questionId = this.getQuestionIdFromElement(questionCard);\n                \n                if (entry.isIntersecting) {\n                    // Question came into view - only start timing if not already tracking\n                    if (!this.questionStartTimes.has(questionId)) {\n                        this.startQuestionTiming(questionId);\n                        this.trackInteraction('question_view_start', null, {\n                            questionId: questionId,\n                            visibility: entry.intersectionRatio\n                        });\n                    }\n                } else {\n                    // Question left view - only end timing if we were tracking\n                    if (this.questionStartTimes.has(questionId)) {\n                        this.endQuestionTiming(questionId);\n                        this.trackInteraction('question_view_end', null, {\n                            questionId: questionId\n                        });\n                    }\n                }\n            });\n        }, {\n            threshold: [0.1, 0.5, 0.9] // Track partial visibility\n        });\n        \n        // Observe all question cards\n        document.querySelectorAll('.question-card').forEach(card => {\n            this.visibilityObserver.observe(card);\n        });\n    }\n    \n    getQuestionIdFromElement(element) {\n        // Extract question ID from element attributes or content\n        const questionIdAttr = element.getAttribute('data-question-id');\n        if (questionIdAttr) return parseInt(questionIdAttr);\n        \n        // Try to find from input names\n        const inputs = element.querySelectorAll('.question-input');\n        if (inputs.length > 0) {\n            const name = inputs[0].name;\n            const match = name.match(/question_(\\d+)/);\n            if (match) return parseInt(match[1]);\n        }\n        \n        // Fallback: use element position\n        const allQuestions = document.querySelectorAll('.question-card');\n        const index = Array.from(allQuestions).indexOf(element);\n        return index >= 0 ? index + 1 : null;\n    }\n    \n    startQuestionTiming(questionId) {\n        if (questionId && !this.questionStartTimes.has(questionId)) {\n            this.questionStartTimes.set(questionId, Date.now());\n        }\n    }\n    \n    endQuestionTiming(questionId) {\n        if (questionId && this.questionStartTimes.has(questionId)) {\n            const startTime = this.questionStartTimes.get(questionId);\n            const timeSpent = Date.now() - startTime;\n            \n            this.trackInteraction('question_time', null, {\n                questionId: questionId,\n                timeSpent: timeSpent\n            });\n            \n            this.questionStartTimes.delete(questionId);\n        }\n    }\n    \n    trackInteraction(type, event = null, additionalData = {}) {\n        if (!this.isTracking) return;\n        \n        const interaction = {\n            type: type,\n            timestamp: Date.now(),\n            attemptId: this.attemptId,\n            ...additionalData\n        };\n        \n        // Add event-specific data\n        if (event) {\n            interaction.x = event.clientX;\n            interaction.y = event.clientY;\n            interaction.target = this.getElementInfo(event.target);\n            \n            // Get question context\n            const questionElement = event.target.closest('.question-card');\n            if (questionElement) {\n                interaction.questionId = this.getQuestionIdFromElement(questionElement);\n            }\n        }\n        \n        // Add to queue\n        this.interactionQueue.push(interaction);\n        \n        // If queue is getting large, flush immediately\n        if (this.interactionQueue.length >= 50) {\n            this.flushInteractions();\n        }\n    }\n    \n    getElementInfo(element) {\n        if (!element) return null;\n        \n        return {\n            tagName: element.tagName,\n            className: element.className,\n            id: element.id,\n            type: element.type || null,\n            name: element.name || null,\n            value: element.type === 'radio' ? element.value : null\n        };\n    }\n    \n    async flushInteractions() {\n        if (this.interactionQueue.length === 0) return;\n        \n        const batch = [...this.interactionQueue];\n        this.interactionQueue = [];\n        \n        try {\n            // Send as single batched request\n            await this.sendInteractionBatch(batch);\n        } catch (error) {\n            console.warn('Failed to send interaction batch:', error);\n            // Re-queue failed interactions (up to a limit) \n            if (this.interactionQueue.length < 100) {\n                this.interactionQueue.unshift(...batch);\n            }\n        }\n    }\n    \n    async sendInteractionBatch(interactions) {\n        if (interactions.length === 0) return;\n        \n        try {\n            const response = await fetch('/api/heatmap/interaction/batch', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    interactions: interactions,\n                    attemptId: this.attemptId\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}`);\n            }\n            \n            return await response.json();\n        } catch (error) {\n            console.warn('Failed to send interaction batch:', error);\n            throw error;\n        }\n    }\n    \n    sendFinalBatch() {\n        // Use sendBeacon for guaranteed delivery on page unload\n        if (this.interactionQueue.length === 0) return;\n        \n        const batch = [...this.interactionQueue];\n        this.interactionQueue = [];\n        \n        try {\n            if (navigator.sendBeacon) {\n                const data = JSON.stringify({\n                    interactions: batch,\n                    attemptId: this.attemptId,\n                    final: true\n                });\n                \n                navigator.sendBeacon('/api/heatmap/interaction/batch', data);\n            } else {\n                // Fallback for browsers without sendBeacon\n                this.sendInteractionBatch(batch).catch(() => {\n                    // Silent failure on unload\n                });\n            }\n        } catch (error) {\n            console.warn('Failed to send final batch:', error);\n        }\n    }\n    \n    trackAnswerChange(questionId, answerValue, answerType) {\n        this.trackInteraction('answer_change', null, {\n            questionId: questionId,\n            answerValue: answerValue,\n            answerType: answerType,\n            timestamp: Date.now()\n        });\n    }\n    \n    trackQuestionFocus(questionId) {\n        this.currentQuestionId = questionId;\n        this.startQuestionTiming(questionId);\n        this.trackInteraction('question_focus', null, {\n            questionId: questionId\n        });\n    }\n    \n    trackQuestionBlur(questionId) {\n        if (this.currentQuestionId === questionId) {\n            this.endQuestionTiming(questionId);\n            this.currentQuestionId = null;\n        }\n        this.trackInteraction('question_blur', null, {\n            questionId: questionId\n        });\n    }\n    \n    destroy() {\n        this.isTracking = false;\n        \n        // Send final batch\n        this.sendFinalBatch();\n        \n        // Clear intervals\n        if (this.flushInterval) {\n            clearInterval(this.flushInterval);\n            this.flushInterval = null;\n        }\n        \n        // Remove all event listeners\n        this.eventListeners.forEach(([target, eventOrElement, typeOrHandler, handler]) => {\n            if (target === 'document') {\n                document.removeEventListener(eventOrElement, typeOrHandler);\n            } else if (target === 'window') {\n                window.removeEventListener(eventOrElement, typeOrHandler);\n            } else if (target === 'element') {\n                eventOrElement.removeEventListener(typeOrHandler, handler);\n            }\n        });\n        this.eventListeners = [];\n        \n        // Disconnect intersection observer\n        if (this.visibilityObserver) {\n            this.visibilityObserver.disconnect();\n            this.visibilityObserver = null;\n        }\n        \n        // Clear question timing\n        this.questionStartTimes.clear();\n    }\n}\n\nclass QuizManager {\n    constructor(timeLimit, attemptId) {\n        this.timeLimit = timeLimit * 60; // Convert to seconds\n        this.timeRemaining = this.timeLimit;\n        this.attemptId = attemptId;\n        this.timerInterval = null;\n        this.autoSaveInterval = null;\n        this.answers = new Map();\n        this.isSubmitted = false;\n        \n        // Initialize heatmap tracking\n        this.heatmapTracker = new HeatmapTracker(attemptId);\n        \n        this.init();\n    }\n\n    init() {\n        this.startTimer();\n        this.setupEventListeners();\n        this.startAutoSave();\n        this.loadExistingAnswers();\n        this.updateProgress();\n        this.preventUnload();\n    }\n\n    startTimer() {\n        const timerElement = document.getElementById('timer');\n        if (!timerElement) return;\n\n        this.timerInterval = setInterval(() => {\n            this.timeRemaining--;\n            this.updateTimerDisplay();\n            \n            // Warning notifications\n            if (this.timeRemaining === 300) { // 5 minutes\n                this.showTimeWarning('5 minutes remaining!');\n                timerElement.classList.add('time-warning');\n            }\n            \n            if (this.timeRemaining === 60) { // 1 minute\n                this.showTimeWarning('1 minute remaining!', 'danger');\n                timerElement.classList.remove('time-warning');\n                timerElement.classList.add('time-critical');\n            }\n            \n            // Auto-submit when time runs out\n            if (this.timeRemaining <= 0) {\n                this.autoSubmitQuiz();\n            }\n        }, 1000);\n    }\n\n    updateTimerDisplay() {\n        const timerElement = document.getElementById('timer');\n        if (!timerElement) return;\n\n        const minutes = Math.floor(this.timeRemaining / 60);\n        const seconds = this.timeRemaining % 60;\n        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n        \n        timerElement.textContent = display;\n        \n        // Update page title with remaining time\n        document.title = `[${display}] Quiz in Progress`;\n    }\n\n    setupEventListeners() {\n        // Answer change listeners with enhanced tracking\n        document.querySelectorAll('.question-input').forEach(input => {\n            if (input.type === 'radio') {\n                input.addEventListener('change', (e) => {\n                    this.handleAnswerChange(e.target.name, e.target.value, 'radio');\n                });\n                \n                // Track focus events for questions\n                input.addEventListener('focus', (e) => {\n                    const questionId = this.extractQuestionId(e.target.name);\n                    if (questionId && this.heatmapTracker) {\n                        this.heatmapTracker.trackQuestionFocus(questionId);\n                    }\n                });\n                \n                input.addEventListener('blur', (e) => {\n                    const questionId = this.extractQuestionId(e.target.name);\n                    if (questionId && this.heatmapTracker) {\n                        this.heatmapTracker.trackQuestionBlur(questionId);\n                    }\n                });\n                \n            } else if (input.tagName === 'TEXTAREA') {\n                input.addEventListener('input', (e) => {\n                    this.handleAnswerChange(e.target.name, e.target.value, 'text');\n                });\n                \n                // Enhanced tracking for text inputs\n                input.addEventListener('focus', (e) => {\n                    const questionId = this.extractQuestionId(e.target.name);\n                    if (questionId && this.heatmapTracker) {\n                        this.heatmapTracker.trackQuestionFocus(questionId);\n                    }\n                });\n                \n                input.addEventListener('blur', (e) => {\n                    const questionId = this.extractQuestionId(e.target.name);\n                    if (questionId && this.heatmapTracker) {\n                        this.heatmapTracker.trackQuestionBlur(questionId);\n                    }\n                });\n                \n                // Track typing patterns\n                let typingTimer;\n                input.addEventListener('keydown', (e) => {\n                    clearTimeout(typingTimer);\n                    typingTimer = setTimeout(() => {\n                        if (this.heatmapTracker) {\n                            this.heatmapTracker.trackInteraction('typing_pause', null, {\n                                questionId: this.extractQuestionId(e.target.name),\n                                textLength: e.target.value.length\n                            });\n                        }\n                    }, 1000); // 1 second pause indicates end of typing burst\n                });\n            }\n        });\n\n        // Form submission\n        const quizForm = document.getElementById('quizForm');\n        if (quizForm) {\n            quizForm.addEventListener('submit', (e) => {\n                if (!this.isSubmitted) {\n                    e.preventDefault();\n                    this.showSubmissionConfirmation();\n                }\n            });\n        }\n\n        // Save draft button\n        const saveDraftBtn = document.querySelector('[onclick=\"saveDraft()\"]');\n        if (saveDraftBtn) {\n            saveDraftBtn.addEventListener('click', (e) => {\n                e.preventDefault();\n                this.saveDraft();\n            });\n        }\n\n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            // Ctrl+S to save draft\n            if (e.ctrlKey && e.key === 's') {\n                e.preventDefault();\n                this.saveDraft();\n            }\n            // Ctrl+Enter to submit (if confirmed)\n            if (e.ctrlKey && e.key === 'Enter') {\n                e.preventDefault();\n                this.showSubmissionConfirmation();\n            }\n        });\n    }\n\n    handleAnswerChange(questionName, value, type) {\n        this.answers.set(questionName, { value, type, timestamp: new Date() });\n        this.updateProgress();\n        \n        // Track answer change for heatmap\n        const questionId = this.extractQuestionId(questionName);\n        if (questionId && this.heatmapTracker) {\n            this.heatmapTracker.trackAnswerChange(questionId, value, type);\n        }\n        \n        // Auto-save after answer change (debounced)\n        clearTimeout(this.autoSaveTimeout);\n        this.autoSaveTimeout = setTimeout(() => {\n            this.saveDraft(false); // Silent save\n        }, 2000);\n    }\n    \n    extractQuestionId(questionName) {\n        // Extract question ID from question name (e.g., \"question_5\" -> 5)\n        const match = questionName.match(/question_(\\d+)/);\n        return match ? parseInt(match[1]) : null;\n    }\n\n    updateProgress() {\n        const totalQuestions = document.querySelectorAll('.question-card').length;\n        let answeredQuestions = 0;\n        \n        // Count answered questions\n        const questionNames = new Set();\n        document.querySelectorAll('.question-input').forEach(input => {\n            if (input.type === 'radio' && input.checked) {\n                questionNames.add(input.name);\n            } else if (input.tagName === 'TEXTAREA' && input.value.trim()) {\n                questionNames.add(input.name);\n            }\n        });\n        \n        answeredQuestions = questionNames.size;\n        const percentage = totalQuestions > 0 ? (answeredQuestions / totalQuestions) * 100 : 0;\n        \n        // Update progress bar\n        const progressBar = document.getElementById('progressBar');\n        const progressText = document.getElementById('progressText');\n        \n        if (progressBar) {\n            progressBar.style.width = `${percentage}%`;\n            progressBar.setAttribute('aria-valuenow', percentage);\n            \n            if (percentage === 100) {\n                progressBar.classList.add('bg-success');\n                progressBar.classList.remove('bg-primary');\n            } else {\n                progressBar.classList.remove('bg-success');\n                progressBar.classList.add('bg-primary');\n            }\n        }\n        \n        if (progressText) {\n            progressText.textContent = `${answeredQuestions} of ${totalQuestions} answered`;\n        }\n\n        return { answered: answeredQuestions, total: totalQuestions, percentage };\n    }\n\n    showSubmissionConfirmation() {\n        const progress = this.updateProgress();\n        const unanswered = progress.total - progress.answered;\n        \n        // Update modal content\n        const summaryElement = document.getElementById('submissionSummary');\n        if (summaryElement) {\n            let message = `You have answered ${progress.answered} out of ${progress.total} questions.`;\n            if (unanswered > 0) {\n                message += ` ${unanswered} questions remain unanswered and will be marked as incorrect.`;\n            }\n            summaryElement.textContent = message;\n        }\n        \n        // Show confirmation modal\n        const submitModal = document.getElementById('submitModal');\n        if (submitModal) {\n            const modal = new bootstrap.Modal(submitModal);\n            modal.show();\n            \n            // Setup confirm button\n            const confirmBtn = submitModal.querySelector('.btn-success');\n            if (confirmBtn) {\n                confirmBtn.onclick = () => {\n                    modal.hide();\n                    this.submitQuiz();\n                };\n            }\n        } else {\n            // Fallback to simple confirm dialog\n            const confirmed = confirm(`Are you sure you want to submit your quiz?\\n\\nAnswered: ${progress.answered}/${progress.total} questions\\n\\nThis action cannot be undone.`);\n            if (confirmed) {\n                this.submitQuiz();\n            }\n        }\n    }\n\n    submitQuiz() {\n        if (this.isSubmitted) return;\n        \n        this.isSubmitted = true;\n        this.clearTimers();\n        \n        // Show loading state\n        this.showLoadingState('Submitting quiz...');\n        \n        // Submit the form\n        const quizForm = document.getElementById('quizForm');\n        if (quizForm) {\n            // Add submission timestamp\n            const timestampInput = document.createElement('input');\n            timestampInput.type = 'hidden';\n            timestampInput.name = 'submission_timestamp';\n            timestampInput.value = new Date().toISOString();\n            quizForm.appendChild(timestampInput);\n            \n            quizForm.submit();\n        }\n    }\n\n    autoSubmitQuiz() {\n        if (this.isSubmitted) return;\n        \n        this.showAlert('Time\\'s up! Submitting quiz automatically...', 'warning');\n        \n        setTimeout(() => {\n            this.submitQuiz();\n        }, 2000);\n    }\n\n    saveDraft(showNotification = true) {\n        if (this.isSubmitted) return;\n\n        const formData = new FormData();\n        formData.append('attempt_id', this.attemptId);\n        formData.append('action', 'save_draft');\n        \n        // Collect current answers\n        document.querySelectorAll('.question-input').forEach(input => {\n            if (input.type === 'radio' && input.checked) {\n                formData.append(input.name, input.value);\n            } else if (input.tagName === 'TEXTAREA') {\n                formData.append(input.name, input.value);\n            }\n        });\n\n        // Save to localStorage as backup\n        const draftData = {\n            attemptId: this.attemptId,\n            answers: Object.fromEntries(formData.entries()),\n            timestamp: new Date().toISOString(),\n            timeRemaining: this.timeRemaining\n        };\n        localStorage.setItem(`quiz_draft_${this.attemptId}`, JSON.stringify(draftData));\n        \n        if (showNotification) {\n            this.showAlert('Draft saved successfully!', 'success', 3000);\n        }\n        \n        // In a real implementation, you would also send this to the server\n        // fetch('/api/save-draft', { method: 'POST', body: formData })\n    }\n\n    loadExistingAnswers() {\n        // Try to load from localStorage first\n        const draftData = localStorage.getItem(`quiz_draft_${this.attemptId}`);\n        if (draftData) {\n            try {\n                const data = JSON.parse(draftData);\n                // You could restore the draft here if needed\n                console.log('Draft data found:', data);\n            } catch (e) {\n                console.error('Error parsing draft data:', e);\n            }\n        }\n    }\n\n    startAutoSave() {\n        // Auto-save every 30 seconds\n        this.autoSaveInterval = setInterval(() => {\n            if (!this.isSubmitted) {\n                this.saveDraft(false);\n            }\n        }, 30000);\n    }\n\n    clearTimers() {\n        if (this.timerInterval) {\n            clearInterval(this.timerInterval);\n            this.timerInterval = null;\n        }\n        if (this.autoSaveInterval) {\n            clearInterval(this.autoSaveInterval);\n            this.autoSaveInterval = null;\n        }\n        if (this.autoSaveTimeout) {\n            clearTimeout(this.autoSaveTimeout);\n            this.autoSaveTimeout = null;\n        }\n        \n        // Clean up heatmap tracking\n        if (this.heatmapTracker) {\n            this.heatmapTracker.destroy();\n            this.heatmapTracker = null;\n        }\n    }\n\n    preventUnload() {\n        window.addEventListener('beforeunload', (e) => {\n            if (!this.isSubmitted) {\n                const message = 'Are you sure you want to leave? Your quiz progress may be lost.';\n                e.preventDefault();\n                e.returnValue = message;\n                return message;\n            }\n        });\n\n        // Handle visibility change (tab switching)\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden && !this.isSubmitted) {\n                // Log potential proctoring violation\n                if (window.proctoringManager) {\n                    window.proctoringManager.logEvent('tab_switch', 'User switched away from quiz tab');\n                }\n                \n                // Track tab switch in heatmap\n                if (this.heatmapTracker) {\n                    this.heatmapTracker.trackInteraction('tab_hidden');\n                }\n            } else if (!this.isSubmitted) {\n                // Track return to tab\n                if (this.heatmapTracker) {\n                    this.heatmapTracker.trackInteraction('tab_visible');\n                }\n            }\n        });\n    }\n\n    showTimeWarning(message, type = 'warning') {\n        this.showAlert(message, type, 5000);\n        \n        // Play notification sound if available\n        this.playNotificationSound();\n    }\n\n    showAlert(message, type = 'info', duration = 5000) {\n        // Create alert element\n        const alertDiv = document.createElement('div');\n        alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;\n        alertDiv.style.cssText = `\n            top: 100px;\n            right: 20px;\n            z-index: 1050;\n            max-width: 300px;\n        `;\n        \n        alertDiv.innerHTML = `\n            ${message}\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        document.body.appendChild(alertDiv);\n        \n        // Auto-remove after duration\n        if (duration > 0) {\n            setTimeout(() => {\n                if (alertDiv.parentNode) {\n                    alertDiv.remove();\n                }\n            }, duration);\n        }\n    }\n\n    showLoadingState(message) {\n        const loadingDiv = document.createElement('div');\n        loadingDiv.id = 'quiz-loading';\n        loadingDiv.className = 'position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center';\n        loadingDiv.style.cssText = `\n            background: rgba(0, 0, 0, 0.8);\n            z-index: 9999;\n        `;\n        \n        loadingDiv.innerHTML = `\n            <div class=\"text-center text-white\">\n                <div class=\"spinner-border text-primary mb-3\" role=\"status\">\n                    <span class=\"visually-hidden\">Loading...</span>\n                </div>\n                <h4>${message}</h4>\n            </div>\n        `;\n        \n        document.body.appendChild(loadingDiv);\n    }\n\n    playNotificationSound() {\n        // Create and play a simple notification sound\n        try {\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.value = 800;\n            oscillator.type = 'sine';\n            \n            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n            \n            oscillator.start();\n            oscillator.stop(audioContext.currentTime + 0.5);\n        } catch (e) {\n            // Silently fail if audio context is not available\n            console.log('Audio notification not available');\n        }\n    }\n\n    // Utility methods\n    formatTime(seconds) {\n        const minutes = Math.floor(seconds / 60);\n        const secs = seconds % 60;\n        return `${minutes}:${secs.toString().padStart(2, '0')}`;\n    }\n\n    getQuestionProgress() {\n        const questions = document.querySelectorAll('.question-card');\n        const answered = [];\n        const unanswered = [];\n        \n        questions.forEach((questionCard, index) => {\n            const inputs = questionCard.querySelectorAll('.question-input');\n            let hasAnswer = false;\n            \n            inputs.forEach(input => {\n                if (input.type === 'radio' && input.checked) {\n                    hasAnswer = true;\n                } else if (input.tagName === 'TEXTAREA' && input.value.trim()) {\n                    hasAnswer = true;\n                }\n            });\n            \n            if (hasAnswer) {\n                answered.push(index + 1);\n            } else {\n                unanswered.push(index + 1);\n            }\n        });\n        \n        return { answered, unanswered };\n    }\n}\n\n// Initialize quiz manager when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Check if we're on a quiz-taking page\n    const quizForm = document.getElementById('quizForm');\n    if (quizForm) {\n        // Extract quiz parameters from the page\n        const timeLimitElement = document.querySelector('[data-time-limit]');\n        const attemptIdElement = document.querySelector('[data-attempt-id]');\n        \n        if (timeLimitElement && attemptIdElement) {\n            const timeLimit = parseInt(timeLimitElement.dataset.timeLimit);\n            const attemptId = parseInt(attemptIdElement.dataset.attemptId);\n            \n            // Initialize quiz manager\n            window.quizManager = new QuizManager(timeLimit, attemptId);\n        }\n    }\n});\n\n// Global functions for backward compatibility\nfunction updateProgress() {\n    if (window.quizManager) {\n        return window.quizManager.updateProgress();\n    }\n}\n\nfunction saveDraft() {\n    if (window.quizManager) {\n        window.quizManager.saveDraft(true);\n    }\n}\n\nfunction confirmSubmit() {\n    if (window.quizManager) {\n        window.quizManager.showSubmissionConfirmation();\n    }\n    return false; // Prevent default form submission\n}\n\nfunction submitQuiz() {\n    if (window.quizManager) {\n        window.quizManager.submitQuiz();\n    }\n}\n","size_bytes":33476},"static/js/loading.js":{"content":"/**\n * Assessment Platform Loading System\n * Provides professional loading animations and user feedback\n */\n\nclass LoadingManager {\n    constructor() {\n        this.isLoading = false;\n        this.overlay = null;\n        this.init();\n    }\n\n    init() {\n        // Create loading overlay element\n        this.createOverlay();\n        \n        // Add event listeners for form submissions\n        this.attachFormListeners();\n        \n        // Add event listeners for AJAX requests\n        this.attachAjaxListeners();\n    }\n\n    createOverlay() {\n        this.overlay = document.createElement('div');\n        this.overlay.id = 'loadingOverlay';\n        this.overlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(255, 255, 255, 0.95);\n            backdrop-filter: blur(10px);\n            z-index: 10000;\n            display: none;\n            align-items: center;\n            justify-content: center;\n        `;\n        \n        this.overlay.innerHTML = `\n            <div style=\"text-align: center; color: #333; max-width: 320px; margin: 0 auto;\">\n                <div style=\"margin: 0 auto 2rem; width: 60px; height: 60px;\">\n                    <div class=\"professional-spinner\" style=\"\n                        width: 60px;\n                        height: 60px;\n                        border-radius: 50%;\n                        border: 3px solid #e5e7eb;\n                        border-top: 3px solid #374151;\n                        animation: professionalSpin 0.8s linear infinite;\n                    \"></div>\n                </div>\n                \n                <div style=\"font-size: 1.1rem; margin-bottom: 0.75rem; color: #374151; font-weight: 500; letter-spacing: 0.025em;\">\n                    <span class=\"loading-text\">Loading...</span>\n                </div>\n                \n                <div style=\"width: 200px; height: 2px; background: #e5e7eb; border-radius: 1px; margin: 0 auto; overflow: hidden;\">\n                    <div style=\"height: 100%; background: #374151; border-radius: 1px; animation: professionalProgress 1.5s ease-in-out infinite;\"></div>\n                </div>\n            </div>\n        `;\n        \n        // Add CSS animations\n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes professionalSpin {\n                0% { transform: rotate(0deg); }\n                100% { transform: rotate(360deg); }\n            }\n            \n            @keyframes professionalProgress {\n                0% { width: 0%; margin-left: 0%; }\n                50% { width: 60%; margin-left: 20%; }\n                100% { width: 0%; margin-left: 100%; }\n            }\n        `;\n        document.head.appendChild(style);\n        \n        document.body.appendChild(this.overlay);\n    }\n\n    show(message = 'Loading...') {\n        if (this.isLoading) return;\n        \n        this.isLoading = true;\n        \n        // Update message if provided\n        const messageElement = this.overlay.querySelector('.loading-text');\n        if (messageElement) {\n            messageElement.textContent = message;\n        }\n        \n        this.overlay.style.display = 'flex';\n        \n        // Animate in\n        setTimeout(() => {\n            this.overlay.style.opacity = '1';\n        }, 10);\n    }\n\n    hide() {\n        if (!this.isLoading) return;\n        \n        this.isLoading = false;\n        \n        // Animate out\n        this.overlay.style.opacity = '0';\n        setTimeout(() => {\n            this.overlay.style.display = 'none';\n        }, 300);\n    }\n\n    attachFormListeners() {\n        document.addEventListener('submit', (event) => {\n            const form = event.target;\n            \n            // Only show loading for specific forms that need it\n            const needsLoading = form.classList.contains('needs-loading') ||\n                               form.hasAttribute('data-loading') ||\n                               form.action?.includes('/quiz/') ||\n                               form.action?.includes('/create') ||\n                               form.action?.includes('/upload');\n            \n            // Skip if form explicitly doesn't need loading or doesn't need it\n            if (form.hasAttribute('data-no-loading') || !needsLoading) {\n                return;\n            }\n            \n            // Skip for simple forms like login, search, and navigation\n            if (form.classList.contains('search-form') || \n                form.classList.contains('quick-action') ||\n                form.classList.contains('simple-form')) {\n                return;\n            }\n            \n            if (form.tagName === 'FORM') {\n                this.show('Processing...');\n            }\n        });\n    }\n\n    attachAjaxListeners() {\n        // Intercept fetch requests only for specific endpoints\n        const originalFetch = window.fetch;\n        window.fetch = (...args) => {\n            const url = args[0];\n            \n            // Only show loading for data-heavy or complex requests\n            const needsLoading = url?.includes('/api/') ||\n                               url?.includes('/upload') ||\n                               url?.includes('/quiz/') ||\n                               url?.includes('/create') ||\n                               url?.includes('/generate');\n            \n            if (needsLoading) {\n                this.show('Processing...');\n            }\n            \n            return originalFetch(...args).finally(() => {\n                if (needsLoading) {\n                    setTimeout(() => this.hide(), 500);\n                }\n            });\n        };\n\n        // Intercept XMLHttpRequest with selective loading\n        const originalOpen = XMLHttpRequest.prototype.open;\n        XMLHttpRequest.prototype.open = function(...args) {\n            const method = args[0];\n            const url = args[1];\n            \n            // Only show loading for specific XMLHttpRequests\n            const needsLoading = (method === 'POST' || method === 'PUT' || method === 'DELETE') &&\n                               (url?.includes('/api/') ||\n                                url?.includes('/upload') ||\n                                url?.includes('/quiz/') ||\n                                url?.includes('/create') ||\n                                url?.includes('/generate'));\n            \n            if (needsLoading) {\n                this.addEventListener('loadstart', () => {\n                    window.loadingManager?.show('Processing...');\n                });\n                this.addEventListener('loadend', () => {\n                    setTimeout(() => window.loadingManager?.hide(), 500);\n                });\n            }\n            \n            return originalOpen.apply(this, args);\n        };\n    }\n\n    // Utility methods for specific loading scenarios\n    showWithRedirect(message, redirectUrl, delay = 2000) {\n        this.show(message);\n        setTimeout(() => {\n            window.location.href = redirectUrl;\n        }, delay);\n    }\n\n    showForPromise(promise, message = 'Processing...') {\n        this.show(message);\n        return promise.finally(() => {\n            setTimeout(() => this.hide(), 300);\n        });\n    }\n}\n\n// Initialize loading manager when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.loadingManager = new LoadingManager();\n});\n\n// Export for use in other scripts\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = LoadingManager;\n}\n\n// ===== PROFESSIONAL LOADING ENHANCEMENTS =====\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Hide initial loading screen after content loads\n    setTimeout(() => {\n        const loadingScreen = document.getElementById('loading-screen');\n        if (loadingScreen) {\n            loadingScreen.classList.add('loading-hidden');\n            setTimeout(() => {\n                loadingScreen.style.display = 'none';\n            }, 500);\n        }\n    }, 2000);\n    \n    // Smooth scrolling for better UX\n    document.documentElement.style.scrollBehavior = 'smooth';\n    \n    // Enhanced form validation\n    const forms = document.querySelectorAll('form');\n    forms.forEach(form => {\n        form.addEventListener('submit', function(e) {\n            const requiredFields = form.querySelectorAll('[required]');\n            let isValid = true;\n            \n            requiredFields.forEach(field => {\n                if (!field.value.trim()) {\n                    field.classList.add('is-invalid');\n                    isValid = false;\n                } else {\n                    field.classList.remove('is-invalid');\n                    field.classList.add('is-valid');\n                }\n            });\n            \n            if (!isValid) {\n                e.preventDefault();\n            }\n        });\n    });\n});","size_bytes":8943},"database_migration.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nDatabase Migration Script for BigBossizzz Advanced Features\nRun this script to add new tables and columns for enhanced security and functionality.\n\"\"\"\n\nfrom app import app, db\nfrom models import UploadRecord, DeviceLog, SecurityAlert\nfrom sqlalchemy import text\nimport logging\n\ndef run_migration():\n    \"\"\"Execute database migration for advanced features\"\"\"\n    \n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n    \n    with app.app_context():\n        try:\n            logger.info(\"Starting database migration for advanced features...\")\n            \n            # Create all new tables\n            logger.info(\"Creating new tables...\")\n            db.create_all()\n            \n            # Add new columns to existing tables using raw SQL\n            logger.info(\"Adding new columns to existing tables...\")\n            \n            # Quiz table modifications\n            quiz_columns = [\n                \"ALTER TABLE quiz ADD COLUMN allow_view_responses BOOLEAN DEFAULT 1\",\n                \"ALTER TABLE quiz ADD COLUMN auto_generate_from_upload BOOLEAN DEFAULT 0\", \n                \"ALTER TABLE quiz ADD COLUMN draft_from_upload_id INTEGER\",\n                \"ALTER TABLE quiz ADD COLUMN is_deleted BOOLEAN DEFAULT 0\",\n                \"ALTER TABLE quiz ADD COLUMN max_violations_allowed INTEGER DEFAULT 3\",\n                \"ALTER TABLE quiz ADD COLUMN auto_terminate_on_violation BOOLEAN DEFAULT 1\",\n                \"ALTER TABLE quiz ADD COLUMN face_detection_required BOOLEAN DEFAULT 1\",\n                \"ALTER TABLE quiz ADD COLUMN screen_recording_required BOOLEAN DEFAULT 0\",\n                \"ALTER TABLE quiz ADD COLUMN browser_lockdown BOOLEAN DEFAULT 1\"\n            ]\n            \n            # QuizAttempt table modifications  \n            attempt_columns = [\n                \"ALTER TABLE quiz_attempt ADD COLUMN report_sent BOOLEAN DEFAULT 0\",\n                \"ALTER TABLE quiz_attempt ADD COLUMN violation_count INTEGER DEFAULT 0\",\n                \"ALTER TABLE quiz_attempt ADD COLUMN is_flagged BOOLEAN DEFAULT 0\",\n                \"ALTER TABLE quiz_attempt ADD COLUMN termination_reason TEXT\"\n            ]\n            \n            # Execute column additions (ignore errors if columns already exist)\n            for sql in quiz_columns + attempt_columns:\n                try:\n                    db.session.execute(text(sql))\n                    db.session.commit()\n                    logger.info(f\"Successfully executed: {sql}\")\n                except Exception as e:\n                    db.session.rollback()\n                    if \"duplicate column name\" in str(e).lower() or \"already exists\" in str(e).lower():\n                        logger.info(f\"Column already exists, skipping: {sql}\")\n                    else:\n                        logger.warning(f\"Error executing {sql}: {e}\")\n            \n            # Create indexes for performance\n            indexes = [\n                \"CREATE INDEX IF NOT EXISTS idx_upload_record_host ON upload_record(host_id)\",\n                \"CREATE INDEX IF NOT EXISTS idx_device_log_user ON device_log(user_id)\",\n                \"CREATE INDEX IF NOT EXISTS idx_security_alert_user ON security_alert(user_id)\",\n                \"CREATE INDEX IF NOT EXISTS idx_quiz_attempt_quiz_user ON quiz_attempt(quiz_id, participant_id)\",\n                \"CREATE INDEX IF NOT EXISTS idx_proctoring_event_attempt ON proctoring_event(attempt_id)\"\n            ]\n            \n            logger.info(\"Creating performance indexes...\")\n            for sql in indexes:\n                try:\n                    db.session.execute(text(sql))\n                    db.session.commit()\n                    logger.info(f\"Created index: {sql}\")\n                except Exception as e:\n                    db.session.rollback()\n                    logger.info(f\"Index already exists or error: {e}\")\n            \n            logger.info(\"Database migration completed successfully!\")\n            \n            # Verify tables exist\n            logger.info(\"Verifying new tables...\")\n            inspector = db.inspect(db.engine)\n            tables = inspector.get_table_names()\n            new_tables = ['upload_record', 'device_log', 'security_alert']\n            \n            for table in new_tables:\n                if table in tables:\n                    logger.info(f\"‚úì Table '{table}' created successfully\")\n                else:\n                    logger.error(f\"‚úó Table '{table}' not found!\")\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Migration failed: {e}\")\n            db.session.rollback()\n            return False\n\nif __name__ == \"__main__\":\n    success = run_migration()\n    if success:\n        print(\"‚úÖ Migration completed successfully!\")\n    else:\n        print(\"‚ùå Migration failed. Check logs for details.\")","size_bytes":4883},"static/js/quiz-creation.js":{"content":"/**\n * Enhanced Quiz Creation Interface\n * Provides smooth loading states and modern form experience\n */\n\nclass QuizCreationManager {\n    constructor() {\n        this.currentQuestionIndex = 0;\n        this.questions = [];\n        this.autoSaveEnabled = true;\n        this.autoSaveInterval = null;\n        this.isDirty = false;\n        this.init();\n    }\n\n    init() {\n        // Initialize auto-save\n        this.startAutoSave();\n        \n        // Add loading states to forms\n        this.enhanceFormSubmissions();\n        \n        // Add progress tracking\n        this.initProgressTracking();\n        \n        // Add keyboard shortcuts\n        this.addKeyboardShortcuts();\n        \n        // Initialize question creation flow\n        this.initQuestionFlow();\n    }\n\n    enhanceFormSubmissions() {\n        // Quiz settings form\n        const quizForm = document.querySelector('form[method=\"POST\"]');\n        if (quizForm && !quizForm.hasAttribute('data-no-loading')) {\n            quizForm.addEventListener('submit', (e) => {\n                this.showLoadingState('Updating quiz settings...');\n                const submitBtn = quizForm.querySelector('button[type=\"submit\"]');\n                if (submitBtn) {\n                    const originalText = submitBtn.innerHTML;\n                    submitBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin\"></i> Updating...';\n                    submitBtn.disabled = true;\n                    \n                    // Re-enable after timeout as fallback\n                    setTimeout(() => {\n                        submitBtn.innerHTML = originalText;\n                        submitBtn.disabled = false;\n                    }, 5000);\n                }\n            });\n        }\n\n        // Question forms\n        const questionForms = document.querySelectorAll('.question-form');\n        questionForms.forEach(form => {\n            form.addEventListener('submit', (e) => {\n                this.showLoadingState('Adding question...');\n                this.markClean(); // Question added, mark as clean\n            });\n        });\n    }\n\n    initProgressTracking() {\n        // Create progress indicator\n        const progressContainer = document.createElement('div');\n        progressContainer.className = 'quiz-progress-container';\n        progressContainer.innerHTML = `\n            <div class=\"card border-primary mb-3\">\n                <div class=\"card-body p-3\">\n                    <div class=\"d-flex justify-content-between align-items-center mb-2\">\n                        <h6 class=\"mb-0\"><i class=\"fas fa-chart-line text-primary\"></i> Creation Progress</h6>\n                        <small class=\"text-muted\" id=\"lastSaved\">Auto-saved</small>\n                    </div>\n                    <div class=\"progress mb-2\" style=\"height: 8px;\">\n                        <div class=\"progress-bar bg-primary\" id=\"quizProgress\" role=\"progressbar\" style=\"width: 0%\"></div>\n                    </div>\n                    <div class=\"row text-center\">\n                        <div class=\"col-4\">\n                            <small class=\"text-muted\">Questions</small>\n                            <div class=\"fw-bold text-primary\" id=\"questionCount\">0</div>\n                        </div>\n                        <div class=\"col-4\">\n                            <small class=\"text-muted\">Points</small>\n                            <div class=\"fw-bold text-success\" id=\"totalPoints\">0</div>\n                        </div>\n                        <div class=\"col-4\">\n                            <small class=\"text-muted\">Status</small>\n                            <div class=\"fw-bold text-info\" id=\"quizStatus\">Draft</div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        // Insert progress container\n        const sidebar = document.querySelector('.col-lg-4');\n        if (sidebar) {\n            sidebar.insertBefore(progressContainer, sidebar.firstChild);\n        }\n\n        this.updateProgress();\n    }\n\n    updateProgress() {\n        const questionCount = document.querySelectorAll('.accordion-item').length;\n        const totalPoints = this.calculateTotalPoints();\n        const completionPercentage = Math.min((questionCount / 5) * 100, 100); // Assume 5 questions for full progress\n\n        const progressBar = document.getElementById('quizProgress');\n        const questionCountEl = document.getElementById('questionCount');\n        const totalPointsEl = document.getElementById('totalPoints');\n        const statusEl = document.getElementById('quizStatus');\n\n        if (progressBar) progressBar.style.width = `${completionPercentage}%`;\n        if (questionCountEl) questionCountEl.textContent = questionCount;\n        if (totalPointsEl) totalPointsEl.textContent = totalPoints;\n        if (statusEl) {\n            statusEl.textContent = questionCount === 0 ? 'Draft' : \n                                  questionCount < 3 ? 'In Progress' : 'Ready';\n        }\n    }\n\n    calculateTotalPoints() {\n        const pointsElements = document.querySelectorAll('.question-points');\n        let total = 0;\n        pointsElements.forEach(el => {\n            const points = parseInt(el.textContent) || 0;\n            total += points;\n        });\n        return total;\n    }\n\n    initQuestionFlow() {\n        // Enhanced question modal\n        const modal = document.getElementById('addQuestionModal');\n        if (modal) {\n            // Add step-by-step flow\n            this.enhanceQuestionModal(modal);\n        }\n\n        // Add live preview\n        this.addQuestionPreview();\n    }\n\n    enhanceQuestionModal(modal) {\n        const modalBody = modal.querySelector('.modal-body');\n        if (!modalBody) return;\n\n        // Add question type selection step\n        const originalContent = modalBody.innerHTML;\n        modalBody.innerHTML = `\n            <div class=\"question-creation-steps\">\n                <!-- Step 1: Question Type -->\n                <div class=\"step-content\" id=\"step1\" style=\"display: block;\">\n                    <h5 class=\"mb-3\"><i class=\"fas fa-list-ul\"></i> Select Question Type</h5>\n                    <div class=\"row\">\n                        <div class=\"col-md-6 mb-3\">\n                            <div class=\"card question-type-card\" data-type=\"multiple_choice\">\n                                <div class=\"card-body text-center\">\n                                    <i class=\"fas fa-list-ul fa-2x text-primary mb-2\"></i>\n                                    <h6>Multiple Choice</h6>\n                                    <small class=\"text-muted\">Choose from multiple options</small>\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"col-md-6 mb-3\">\n                            <div class=\"card question-type-card\" data-type=\"true_false\">\n                                <div class=\"card-body text-center\">\n                                    <i class=\"fas fa-check-double fa-2x text-success mb-2\"></i>\n                                    <h6>True/False</h6>\n                                    <small class=\"text-muted\">Simple true or false question</small>\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"col-md-6 mb-3\">\n                            <div class=\"card question-type-card\" data-type=\"text\">\n                                <div class=\"card-body text-center\">\n                                    <i class=\"fas fa-pen fa-2x text-info mb-2\"></i>\n                                    <h6>Text Input</h6>\n                                    <small class=\"text-muted\">Open-ended text response</small>\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"col-md-6 mb-3\">\n                            <div class=\"card question-type-card\" data-type=\"essay\">\n                                <div class=\"card-body text-center\">\n                                    <i class=\"fas fa-file-text fa-2x text-warning mb-2\"></i>\n                                    <h6>Essay</h6>\n                                    <small class=\"text-muted\">Long-form response</small>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                    <div class=\"d-flex justify-content-end\">\n                        <button type=\"button\" class=\"btn btn-primary\" id=\"nextToStep2\" disabled>\n                            Next <i class=\"fas fa-arrow-right\"></i>\n                        </button>\n                    </div>\n                </div>\n\n                <!-- Step 2: Question Details -->\n                <div class=\"step-content\" id=\"step2\" style=\"display: none;\">\n                    <h5 class=\"mb-3\"><i class=\"fas fa-edit\"></i> Question Details</h5>\n                    ${originalContent}\n                    <div class=\"d-flex justify-content-between\">\n                        <button type=\"button\" class=\"btn btn-outline-secondary\" id=\"backToStep1\">\n                            <i class=\"fas fa-arrow-left\"></i> Back\n                        </button>\n                        <button type=\"button\" class=\"btn btn-success\" id=\"saveQuestion\">\n                            <i class=\"fas fa-save\"></i> Save Question\n                        </button>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        // Add step navigation logic\n        this.addStepNavigation(modal);\n    }\n\n    addStepNavigation(modal) {\n        let selectedType = null;\n\n        // Question type selection\n        modal.querySelectorAll('.question-type-card').forEach(card => {\n            card.addEventListener('click', () => {\n                // Remove selection from other cards\n                modal.querySelectorAll('.question-type-card').forEach(c => \n                    c.classList.remove('border-primary', 'bg-light'));\n                \n                // Select this card\n                card.classList.add('border-primary', 'bg-light');\n                selectedType = card.dataset.type;\n                \n                // Enable next button\n                document.getElementById('nextToStep2').disabled = false;\n            });\n        });\n\n        // Step navigation\n        document.getElementById('nextToStep2')?.addEventListener('click', () => {\n            this.showStep(2);\n            // Set the question type in the form\n            const typeSelect = modal.querySelector('select[name=\"question_type\"]');\n            if (typeSelect && selectedType) {\n                typeSelect.value = selectedType;\n                typeSelect.dispatchEvent(new Event('change'));\n            }\n        });\n\n        document.getElementById('backToStep1')?.addEventListener('click', () => {\n            this.showStep(1);\n        });\n    }\n\n    showStep(stepNumber) {\n        document.querySelectorAll('.step-content').forEach(step => {\n            step.style.display = 'none';\n        });\n        const targetStep = document.getElementById(`step${stepNumber}`);\n        if (targetStep) {\n            targetStep.style.display = 'block';\n        }\n    }\n\n    addQuestionPreview() {\n        // Add live preview panel\n        const previewContainer = document.createElement('div');\n        previewContainer.innerHTML = `\n            <div class=\"card mt-3\">\n                <div class=\"card-header\">\n                    <h6><i class=\"fas fa-eye\"></i> Live Preview</h6>\n                </div>\n                <div class=\"card-body\" id=\"questionPreview\">\n                    <p class=\"text-muted text-center\">Select question type to see preview</p>\n                </div>\n            </div>\n        `;\n\n        const modal = document.getElementById('addQuestionModal');\n        if (modal) {\n            const step2 = modal.querySelector('#step2');\n            if (step2) {\n                step2.appendChild(previewContainer);\n            }\n        }\n    }\n\n    startAutoSave() {\n        if (!this.autoSaveEnabled) return;\n\n        this.autoSaveInterval = setInterval(() => {\n            if (this.isDirty) {\n                this.performAutoSave();\n            }\n        }, 30000); // Auto-save every 30 seconds\n\n        // Mark dirty when form changes\n        document.addEventListener('input', (e) => {\n            if (e.target.matches('input, textarea, select')) {\n                this.markDirty();\n            }\n        });\n    }\n\n    toggleAutoSave(enabled) {\n        this.autoSaveEnabled = enabled;\n        \n        if (enabled) {\n            // Start auto-save if it was disabled\n            if (!this.autoSaveInterval) {\n                this.startAutoSave();\n            }\n            this.showToast('Auto-save enabled', 'success');\n        } else {\n            // Stop auto-save interval\n            if (this.autoSaveInterval) {\n                clearInterval(this.autoSaveInterval);\n                this.autoSaveInterval = null;\n            }\n            this.showToast('Auto-save disabled', 'warning');\n        }\n    }\n\n    markDirty() {\n        this.isDirty = true;\n        const lastSaved = document.getElementById('lastSaved');\n        if (lastSaved) {\n            lastSaved.textContent = 'Unsaved changes';\n            lastSaved.classList.add('text-warning');\n        }\n    }\n\n    markClean() {\n        this.isDirty = false;\n        const lastSaved = document.getElementById('lastSaved');\n        if (lastSaved) {\n            lastSaved.textContent = 'Auto-saved';\n            lastSaved.classList.remove('text-warning');\n        }\n    }\n\n    async performAutoSave() {\n        try {\n            // Get form data\n            const quizForm = document.querySelector('form[method=\"POST\"]');\n            if (!quizForm) return;\n\n            const formData = new FormData(quizForm);\n            formData.append('auto_save', '1');\n\n            const response = await fetch(window.location.href, {\n                method: 'POST',\n                body: formData\n            });\n\n            if (response.ok) {\n                this.markClean();\n                this.showToast('Quiz auto-saved', 'success');\n            }\n        } catch (error) {\n            console.error('Auto-save failed:', error);\n        }\n    }\n\n    showLoadingState(message = 'Loading...') {\n        if (window.loadingManager) {\n            window.loadingManager.show(message);\n        }\n    }\n\n    hideLoadingState() {\n        if (window.loadingManager) {\n            window.loadingManager.hide();\n        }\n    }\n\n    showToast(message, type = 'info') {\n        const toast = document.createElement('div');\n        toast.className = `toast align-items-center text-white bg-${type} border-0`;\n        toast.setAttribute('role', 'alert');\n        toast.innerHTML = `\n            <div class=\"d-flex\">\n                <div class=\"toast-body\">${message}</div>\n                <button type=\"button\" class=\"btn-close btn-close-white me-2 m-auto\" data-bs-dismiss=\"toast\"></button>\n            </div>\n        `;\n\n        // Add to toast container or create one\n        let container = document.querySelector('.toast-container');\n        if (!container) {\n            container = document.createElement('div');\n            container.className = 'toast-container position-fixed top-0 end-0 p-3';\n            document.body.appendChild(container);\n        }\n\n        container.appendChild(toast);\n        const bsToast = new bootstrap.Toast(toast);\n        bsToast.show();\n\n        // Remove after hiding\n        toast.addEventListener('hidden.bs.toast', () => {\n            toast.remove();\n        });\n    }\n\n    addKeyboardShortcuts() {\n        document.addEventListener('keydown', (e) => {\n            // Ctrl+S to save\n            if (e.ctrlKey && e.key === 's') {\n                e.preventDefault();\n                this.performAutoSave();\n            }\n            \n            // Ctrl+Q to add question\n            if (e.ctrlKey && e.key === 'q') {\n                e.preventDefault();\n                const addBtn = document.querySelector('[data-bs-target=\"#addQuestionModal\"]');\n                if (addBtn) addBtn.click();\n            }\n        });\n    }\n}\n\n// Global functions for backwards compatibility\nwindow.autoSaveProgress = function() {\n    if (window.quizManager) {\n        window.quizManager.performAutoSave();\n    }\n};\n\n// Initialize when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function() {\n    window.quizManager = new QuizCreationManager();\n});\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', function(e) {\n    if (window.quizManager && window.quizManager.isDirty) {\n        e.preventDefault();\n        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';\n    }\n});","size_bytes":16794},"utils.py":{"content":"from datetime import datetime, timezone, timedelta\n\ndef get_time_greeting():\n    \"\"\"Get time-based greeting based on user's local time\"\"\"\n    # Use UTC+5:30 (IST) as default timezone for better user experience\n    # In production, this should be configurable per user\n    user_timezone = timezone(timedelta(hours=5, minutes=30))\n    current_hour = datetime.now(user_timezone).hour\n    \n    if 5 <= current_hour < 12:\n        return \"Good Morning\"\n    elif 12 <= current_hour < 17:\n        return \"Good Afternoon\"\n    elif 17 <= current_hour < 21:\n        return \"Good Evening\"\n    else:\n        return \"Good Night\"\n\ndef get_greeting_icon():\n    \"\"\"Get greeting icon based on user's local time\"\"\"\n    # Use UTC+5:30 (IST) as default timezone for better user experience\n    user_timezone = timezone(timedelta(hours=5, minutes=30))\n    current_hour = datetime.now(user_timezone).hour\n    \n    if 5 <= current_hour < 12:\n        return \"üåÖ\"\n    elif 12 <= current_hour < 17:\n        return \"‚òÄÔ∏è\"\n    elif 17 <= current_hour < 21:\n        return \"üåÜ\"\n    else:\n        return \"üåô\"","size_bytes":1084},"app_realtime.py":{"content":"\"\"\"\nReal-time BigBossizzz Application with WebSocket Support\nThis replaces the basic Flask app with Flask-SocketIO for real-time functionality\n\"\"\"\n\nimport os\nimport logging\nfrom datetime import datetime\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager, current_user\nfrom flask_socketio import SocketIO, emit, join_room, leave_room, disconnect\nfrom flask_mail import Mail, Message\nfrom sqlalchemy.orm import DeclarativeBase\ntry:\n    from werkzeug.middleware.proxy_fix import ProxyFix\nexcept ImportError:\n    ProxyFix = None\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\nmail = Mail()\n\n# Create the app with SocketIO support\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\")\nif ProxyFix:\n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Configure the database\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = os.environ.get(\"DATABASE_URL\")\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n}\n\n# Email configuration\napp.config['MAIL_SERVER'] = 'smtp.gmail.com'\napp.config['MAIL_PORT'] = 587\napp.config['MAIL_USE_TLS'] = True\napp.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')\napp.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')\n\n# Initialize extensions\ndb.init_app(app)\nmail.init_app(app)\n\n# Initialize SocketIO with eventlet for real-time support\nsocketio = SocketIO(app, \n                   cors_allowed_origins=\"*\",\n                   async_mode='eventlet',\n                   logger=True,\n                   engineio_logger=True)\n\n# Login manager setup\nlogin_manager = LoginManager()\nlogin_manager.init_app(app)\nlogin_manager.login_view = 'login'  # type: ignore\n\n@login_manager.user_loader\ndef load_user(user_id):\n    from models import User\n    return User.query.get(int(user_id))\n\n# Import models and routes\nwith app.app_context():\n    import models\n    import routes\n    db.create_all()\n\n# Real-time WebSocket Events\n@socketio.on('connect')\ndef on_connect(auth):\n    \"\"\"Handle client connection\"\"\"\n    if current_user.is_authenticated:\n        join_room(f\"user_{current_user.id}\")\n        if current_user.is_host() or current_user.is_admin():\n            join_room(\"monitors\")  # Room for hosts and admins\n        logging.info(f\"User {current_user.username} connected to real-time monitoring\")\n        emit('status', {'msg': f'Welcome {current_user.username}!'})\n    else:\n        disconnect()\n\n@socketio.on('disconnect')\ndef on_disconnect():\n    \"\"\"Handle client disconnection\"\"\"\n    if current_user.is_authenticated:\n        leave_room(f\"user_{current_user.id}\")\n        if current_user.is_host() or current_user.is_admin():\n            leave_room(\"monitors\")\n        logging.info(f\"User {current_user.username} disconnected\")\n\n@socketio.on('violation_alert')\ndef handle_violation_alert(data):\n    \"\"\"Handle real-time violation alerts\"\"\"\n    if current_user.is_authenticated:\n        try:\n            # Log the violation to database\n            from models import ProctoringEvent\n            \n            violation = ProctoringEvent(\n                attempt_id=data.get('attemptId'),\n                event_type=data.get('violationType', 'unknown'),\n                details=data.get('message', 'Real-time violation detected'),\n                severity=data.get('severity', 'medium')\n            )\n            db.session.add(violation)\n            db.session.commit()\n            \n            # Send real-time alert to all monitors (hosts and admins)\n            socketio.emit('new_violation', {\n                'student': data.get('student', {}),\n                'violation': data.get('message', 'Violation detected'),\n                'severity': data.get('severity', 'medium'),\n                'timestamp': datetime.utcnow().isoformat(),\n                'attemptId': data.get('attemptId')\n            }, to='monitors')\n            \n            # Send email for high severity violations\n            if data.get('severity') == 'high':\n                send_violation_email(data)\n            \n        except Exception as e:\n            logging.error(f\"Error handling violation alert: {e}\")\n\n@socketio.on('join_monitoring')\ndef on_join_monitoring(data):\n    \"\"\"Allow hosts/admins to join monitoring room\"\"\"\n    if current_user.is_authenticated and (current_user.is_host() or current_user.is_admin()):\n        join_room('monitors')\n        emit('status', {'msg': 'Joined live monitoring room'})\n\ndef send_violation_email(data):\n    \"\"\"Send email notification for high severity violations\"\"\"\n    try:\n        from models import QuizAttempt, Quiz, User\n        \n        attempt_id = data.get('attemptId')\n        attempt = QuizAttempt.query.get(attempt_id)\n        if attempt:\n            quiz = attempt.quiz\n            host = quiz.creator\n            student = attempt.participant\n            \n            msg = Message(\n                subject=f'üö® URGENT: Quiz Violation Alert - {student.username}',\n                recipients=[host.email],\n                body=f'''\nURGENT VIOLATION ALERT\n\nStudent: {student.username} ({student.email})\nQuiz: {quiz.title}\nViolation: {data.get('message', 'Unknown violation')}\nSeverity: {data.get('severity', 'high').upper()}\nTime: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n\nPlease check the live monitoring dashboard immediately.\n                '''\n            )\n            mail.send(msg)\n            logging.info(f\"Violation email sent to {host.email}\")\n            \n    except Exception as e:\n        logging.error(f\"Failed to send violation email: {e}\")\n\nif __name__ == '__main__':\n    # Use socketio.run for real-time support\n    socketio.run(app, host='0.0.0.0', port=5000, debug=True)","size_bytes":5782},"static/js/realtime-monitoring.js":{"content":"/**\n * Real-time Monitoring with WebSocket Support\n * Handles live violation alerts and system monitoring\n */\n\nclass RealTimeMonitoring {\n    constructor() {\n        this.socket = null;\n        this.isConnected = false;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.violationCount = { high: 0, medium: 0, low: 0 };\n        \n        this.init();\n    }\n    \n    init() {\n        // Initialize Socket.IO connection\n        if (typeof io !== 'undefined') {\n            this.socket = io({\n                transports: ['websocket', 'polling'],\n                upgrade: true,\n                rememberUpgrade: true\n            });\n            \n            this.setupSocketEvents();\n        } else {\n            console.warn('Socket.IO not loaded, falling back to polling');\n            this.fallbackToPolling();\n        }\n    }\n    \n    setupSocketEvents() {\n        this.socket.on('connect', () => {\n            this.isConnected = true;\n            this.reconnectAttempts = 0;\n            console.log('Connected to real-time monitoring');\n            \n            // Join monitoring room for hosts/admins\n            if (window.userRole === 'host' || window.userRole === 'admin') {\n                this.socket.emit('join_monitoring', {});\n            }\n            \n            this.updateConnectionStatus(true);\n        });\n        \n        this.socket.on('disconnect', () => {\n            this.isConnected = false;\n            console.log('Disconnected from real-time monitoring');\n            this.updateConnectionStatus(false);\n            this.attemptReconnect();\n        });\n        \n        this.socket.on('new_violation', (data) => {\n            this.handleNewViolation(data);\n        });\n        \n        this.socket.on('status', (data) => {\n            console.log('Status update:', data.msg);\n        });\n        \n        this.socket.on('connect_error', (error) => {\n            console.error('Connection error:', error);\n            this.updateConnectionStatus(false);\n            this.attemptReconnect();\n        });\n    }\n    \n    handleNewViolation(data) {\n        console.log('New violation received:', data);\n        \n        // Update violation counts\n        this.violationCount[data.severity]++;\n        this.updateViolationStats();\n        \n        // Show real-time notification\n        this.showViolationAlert(data);\n        \n        // Add to violation feed\n        this.addViolationToFeed(data);\n        \n        // Play sound alert for high severity\n        if (data.severity === 'high') {\n            this.playAlertSound();\n        }\n    }\n    \n    showViolationAlert(data) {\n        // Create toast notification\n        const toast = document.createElement('div');\n        toast.className = `alert alert-${this.getSeverityClass(data.severity)} alert-dismissible fade show position-fixed`;\n        toast.style.cssText = `\n            top: 20px;\n            right: 20px;\n            z-index: 9999;\n            min-width: 300px;\n            animation: slideIn 0.5s ease-out;\n        `;\n        \n        toast.innerHTML = `\n            <div class=\"d-flex align-items-center\">\n                <i class=\"fas fa-exclamation-triangle me-2\"></i>\n                <div>\n                    <strong>${data.student.name || 'Student'}</strong><br>\n                    <small>${data.violation}</small>\n                </div>\n            </div>\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\"></button>\n        `;\n        \n        document.body.appendChild(toast);\n        \n        // Auto-remove after 10 seconds\n        setTimeout(() => {\n            if (toast.parentNode) {\n                toast.remove();\n            }\n        }, 10000);\n    }\n    \n    addViolationToFeed(data) {\n        const container = document.getElementById('violationsContainer');\n        if (!container) return;\n        \n        const violationCard = this.createViolationCard(data);\n        container.insertAdjacentHTML('afterbegin', violationCard);\n        \n        // Keep only latest 50 violations\n        const cards = container.querySelectorAll('.violation-card');\n        if (cards.length > 50) {\n            for (let i = 50; i < cards.length; i++) {\n                cards[i].remove();\n            }\n        }\n    }\n    \n    createViolationCard(data) {\n        const timestamp = new Date(data.timestamp).toLocaleTimeString();\n        const severityClass = this.getSeverityClass(data.severity);\n        \n        return `\n            <div class=\"violation-card severity-${data.severity} p-3 mb-2\" style=\"animation: slideInLeft 0.5s ease-out;\">\n                <div class=\"d-flex align-items-start\">\n                    <div class=\"violation-type-icon bg-${severityClass} text-white me-3\">\n                        <i class=\"fas fa-exclamation-triangle\"></i>\n                    </div>\n                    <div class=\"flex-grow-1\">\n                        <div class=\"d-flex justify-content-between align-items-start mb-2\">\n                            <h6 class=\"mb-0 fw-bold\">${data.student.name || 'Unknown Student'}</h6>\n                            <small class=\"text-muted\">${timestamp}</small>\n                        </div>\n                        <p class=\"mb-1 text-dark\">${data.violation}</p>\n                        <div class=\"d-flex justify-content-between align-items-center\">\n                            <small class=\"text-muted\">\n                                <i class=\"fas fa-clock\"></i> Real-time alert\n                            </small>\n                            <span class=\"badge bg-${severityClass}\">\n                                ${data.severity.toUpperCase()}\n                            </span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n    }\n    \n    updateViolationStats() {\n        // Update dashboard counters\n        const highElement = document.getElementById('highViolations');\n        const mediumElement = document.getElementById('mediumViolations');\n        const lowElement = document.getElementById('lowViolations');\n        \n        if (highElement) highElement.textContent = this.violationCount.high;\n        if (mediumElement) mediumElement.textContent = this.violationCount.medium;\n        if (lowElement) lowElement.textContent = this.violationCount.low;\n    }\n    \n    updateConnectionStatus(connected) {\n        const indicator = document.querySelector('.live-indicator');\n        if (indicator) {\n            indicator.style.background = connected ? '#28a745' : '#dc3545';\n        }\n        \n        const statusText = document.getElementById('connectionStatus');\n        if (statusText) {\n            statusText.textContent = connected ? 'Connected' : 'Disconnected';\n            statusText.className = connected ? 'text-success' : 'text-danger';\n        }\n    }\n    \n    attemptReconnect() {\n        if (this.reconnectAttempts < this.maxReconnectAttempts && !this.isConnected) {\n            this.reconnectAttempts++;\n            console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n            \n            setTimeout(() => {\n                if (this.socket) {\n                    this.socket.connect();\n                }\n            }, Math.pow(2, this.reconnectAttempts) * 1000); // Exponential backoff\n        }\n    }\n    \n    fallbackToPolling() {\n        console.log('Using polling fallback for real-time updates');\n        setInterval(() => {\n            this.pollForUpdates();\n        }, 3000);\n    }\n    \n    async pollForUpdates() {\n        try {\n            const response = await fetch('/api/monitoring/live-data');\n            const data = await response.json();\n            \n            if (data.participants) {\n                this.updateParticipantData(data.participants);\n            }\n        } catch (error) {\n            console.error('Polling error:', error);\n        }\n    }\n    \n    updateParticipantData(participants) {\n        const activeStudents = document.getElementById('activeStudents');\n        if (activeStudents) {\n            activeStudents.textContent = participants.length;\n        }\n    }\n    \n    getSeverityClass(severity) {\n        switch (severity) {\n            case 'high': return 'danger';\n            case 'medium': return 'warning';\n            case 'low': return 'success';\n            default: return 'info';\n        }\n    }\n    \n    playAlertSound() {\n        const audio = document.getElementById('alertSound');\n        if (audio) {\n            audio.play().catch(() => {\n                // Ignore audio play errors (browser restrictions)\n            });\n        }\n    }\n    \n    // Public methods for manual testing\n    testViolation(severity = 'high') {\n        if (this.socket && this.isConnected) {\n            this.socket.emit('violation_alert', {\n                student: { name: 'Test Student', id: 'test' },\n                violation: 'Test violation for debugging',\n                severity: severity,\n                timestamp: new Date().toISOString(),\n                attemptId: 'test-123'\n            });\n        }\n    }\n    \n    getConnectionStatus() {\n        return {\n            connected: this.isConnected,\n            reconnectAttempts: this.reconnectAttempts,\n            violationCount: this.violationCount\n        };\n    }\n}\n\n// Initialize real-time monitoring when page loads\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Only initialize on monitoring pages\n    if (document.getElementById('violationsContainer') || \n        document.querySelector('.live-indicator')) {\n        \n        window.realTimeMonitoring = new RealTimeMonitoring();\n    }\n});\n\n// Add CSS animations\nconst style = document.createElement('style');\nstyle.textContent = `\n    @keyframes slideIn {\n        from { transform: translateX(100%); opacity: 0; }\n        to { transform: translateX(0); opacity: 1; }\n    }\n    \n    @keyframes slideInLeft {\n        from { transform: translateX(-100%); opacity: 0; }\n        to { transform: translateX(0); opacity: 1; }\n    }\n    \n    .violation-card {\n        transition: all 0.3s ease;\n        border-radius: 8px;\n        border-left: 4px solid;\n    }\n    \n    .violation-card.severity-high {\n        border-left-color: #dc3545;\n        background: linear-gradient(135deg, #ffeaea, #ffebee);\n    }\n    \n    .violation-card.severity-medium {\n        border-left-color: #ffc107;\n        background: linear-gradient(135deg, #fffbf0, #fff8e1);\n    }\n    \n    .violation-card.severity-low {\n        border-left-color: #28a745;\n        background: linear-gradient(135deg, #f0fdf4, #f7fff7);\n    }\n`;\ndocument.head.appendChild(style);","size_bytes":10657},"DEPLOY_TO_RENDER.md":{"content":"# üöÄ Deploy BigBossizzz to Render - Step by Step\n\n## ‚úÖ Pre-Deployment Checklist (COMPLETED)\n- ‚úÖ render.yaml configuration created\n- ‚úÖ requirements.txt with all dependencies  \n- ‚úÖ Production environment variables configured\n- ‚úÖ Email system tested and ready (Brevo 300/day FREE)\n- ‚úÖ PostgreSQL database configuration ready\n- ‚úÖ Health monitoring endpoint working\n\n## üìã Deployment Steps\n\n### Step 1: Create Render Account\n1. Go to https://render.com\n2. Sign up with GitHub (recommended) or email\n3. Verify your account\n\n### Step 2: Connect Your Repository\n1. In Render Dashboard, click \"New +\"\n2. Select \"Web Service\" \n3. Connect your GitHub account\n4. Select your BigBossizzz repository\n\n### Step 3: Configure Service\n**Service Details:**\n- **Name**: `bigbossizzz-proctoring` (or your choice)\n- **Environment**: `Python 3`\n- **Build Command**: `pip install -r requirements.txt`\n- **Start Command**: `gunicorn --bind 0.0.0.0:$PORT --workers 1 --timeout 120 main:app`\n\n### Step 4: Add Environment Variables\nIn Render Dashboard ‚Üí Environment:\n\n**Required Variables:**\n- `BREVO_API_KEY`: Your Brevo API key\n- `BREVO_SENDER_EMAIL`: Your verified email (e.g., noreply@bigbossizzz.com)\n- `FLASK_ENV`: `production`\n\n**Auto-Generated:**\n- `DATABASE_URL`: Automatically provided by PostgreSQL\n- `SESSION_SECRET`: Auto-generated secure key\n\n### Step 5: Add PostgreSQL Database\n1. In Render Dashboard, click \"New +\"\n2. Select \"PostgreSQL\"\n3. Choose Free tier\n4. Name: `bigbossizzz-postgres`\n5. Link to your web service\n\n### Step 6: Deploy\n1. Click \"Create Web Service\"\n2. Wait 3-5 minutes for deployment\n3. Your app will be live at: `https://bigbossizzz-proctoring.onrender.com`\n\n## üåê Custom Domain Setup (BigBossizzz.com)\n\n### After Successful Deployment:\n1. Go to Service Settings ‚Üí Custom Domains\n2. Add `bigbossizzz.com` \n3. Add `www.bigbossizzz.com`\n4. Copy the CNAME records provided\n5. Update your domain registrar's DNS:\n   - CNAME: `bigbossizzz.com` ‚Üí `bigbossizzz-proctoring.onrender.com`\n   - CNAME: `www.bigbossizzz.com` ‚Üí `bigbossizzz-proctoring.onrender.com`\n\n### DNS Propagation\n- Changes take 5-60 minutes to propagate\n- Test with: `nslookup bigbossizzz.com`\n\n## üéì Academic Features Ready\n\nYour deployed platform includes:\n- ‚úÖ **User Registration** with email verification\n- ‚úÖ **Role-based Access** (Admin, Host, Participant) \n- ‚úÖ **Quiz Creation** and management tools\n- ‚úÖ **Proctoring System** with violation detection\n- ‚úÖ **Professional Email** system (300 emails/day free)\n- ‚úÖ **Academic Branding** with custom BigBossizzz logo\n- ‚úÖ **Database Management** with PostgreSQL\n\n## üìä Monitoring & Updates\n\n### Health Check\n- Monitor at: `https://bigbossizzz.com/admin/email-health`\n- Returns JSON status of all systems\n\n### Future Updates\n1. Make changes in your Replit workspace\n2. Push to GitHub repository  \n3. Render auto-deploys changes\n4. Zero downtime updates!\n\n## üí∞ Cost Breakdown\n- **Render Web Service**: 100% FREE (750 hours/month)\n- **PostgreSQL Database**: 100% FREE (1GB storage)\n- **Email Service**: 100% FREE (300 emails/day via Brevo)\n- **Custom Domain**: Only domain registration cost\n\n## üîß Troubleshooting\n\n### Common Issues:\n1. **Build Fails**: Check requirements.txt matches dependencies\n2. **Database Connection**: Verify DATABASE_URL is set\n3. **Email Issues**: Confirm BREVO_API_KEY is valid\n4. **Domain Issues**: Check DNS propagation with `dig bigbossizzz.com`\n\n### Support:\n- Render docs: https://render.com/docs\n- Email system health: `/admin/email-health` endpoint\n- App logs: Available in Render dashboard\n\n## üéâ Post-Deployment\n\nAfter successful deployment:\n1. Test user registration flow\n2. Verify email notifications work  \n3. Test quiz creation and taking\n4. Check proctoring features\n5. Configure any additional academic settings\n\nYour BigBossizzz academic proctoring platform is now **LIVE** and ready for institutional use!","size_bytes":3918},"deployment_trigger.md":{"content":"# BigBossizzz Platform Deployment\n","size_bytes":34},"production_config.md":{"content":"# BigBossizzz Production Configuration for Render\n\n## Required Environment Variables\n\n### Essential (Required for deployment)\n- `DATABASE_URL`: Automatically provided by Render PostgreSQL\n- `SESSION_SECRET`: Automatically generated by Render\n- `BREVO_API_KEY`: Your Brevo API key for email service\n- `FLASK_ENV`: Set to \"production\" (configured in render.yaml)\n\n### Email Configuration (Set in Render Dashboard)\n- `BREVO_SENDER_EMAIL`: Your verified sender email (e.g., noreply@bigbossizzz.com)\n- `BREVO_SENDER_NAME`: \"BigBossizzz Academic Team\" (configured in render.yaml)\n\n## Deployment Checklist\n\n‚úÖ render.yaml created with proper configuration\n‚úÖ requirements.txt created with all dependencies  \n‚úÖ Production environment variables configured\n‚úÖ PostgreSQL database configured in render.yaml\n‚úÖ Gunicorn start command optimized for Render free tier\n‚úÖ Health check endpoint configured (/)\n‚úÖ Email service configured for production\n\n## Custom Domain Setup (BigBossizzz.com)\n\nAfter deployment, in Render Dashboard:\n1. Go to your deployed service\n2. Navigate to Settings ‚Üí Custom Domains\n3. Add \"BigBossizzz.com\" and \"www.BigBossizzz.com\"\n4. Update your domain's DNS with provided CNAME records\n\n## Performance Optimization\n\n- Gunicorn configured with 1 worker (free tier limit)\n- Connection pooling enabled for PostgreSQL\n- Email service optimized for academic use\n- Static files served efficiently","size_bytes":1411},"render.yaml":{"content":"services:\n  - type: web\n    name: bigbossizzz-proctoring\n    env: python\n    plan: free\n    buildCommand: pip install -r requirements.txt\n    startCommand: gunicorn --bind 0.0.0.0:$PORT --workers 1 --timeout 120 main:app\n    healthCheckPath: /\n    envVars:\n      - key: PYTHON_VERSION\n        value: 3.11.13\n      - key: DATABASE_URL\n        fromDatabase:\n          name: bigbossizzz-postgres\n          property: connectionString\n      - key: SESSION_SECRET\n        generateValue: true\n      - key: FLASK_ENV\n        value: production\n      - key: BREVO_API_KEY\n        sync: false\n      - key: BREVO_SENDER_EMAIL \n        sync: false\n      - key: BREVO_SENDER_NAME\n        value: BigBossizzz Academic Team\n      - key: PORT\n        value: 5000\n\ndatabases:\n  - name: bigbossizzz-postgres\n    databaseName: bigbossizzz_production  \n    plan: free","size_bytes":845},"static/js/enhanced-proctoring.js":{"content":"/**\n * Enhanced Enterprise Proctoring System - Live Monitoring Only\n * No image storage - Real-time behavioral analysis\n * Institutional-grade security for BigBossizzz Platform\n */\n\nclass EnhancedProctoringSystem {\n    constructor(attemptId, quizId) {\n        this.attemptId = attemptId;\n        this.quizId = quizId;\n        this.isActive = false;\n        this.violations = [];\n        this.mediaStream = null;\n        this.videoElement = null;\n        this.canvas = null;\n        this.context = null;\n        \n        // Real-time detection (NO IMAGE STORAGE)\n        this.faceDetectionInterval = null;\n        this.lastFaceCount = 0;\n        this.lookAwayCount = 0;\n        this.multiplePeopleCount = 0;\n        this.cameraHiddenCount = 0;\n        this.warningShown = false;  // Prevent repeated warnings\n        \n        // Enhanced Audio Environment Analysis with Speech Detection\n        this.audioStream = null;\n        this.audioContext = null;\n        this.analyser = null;\n        this.dataArray = null;\n        this.audioMonitoringActive = false;\n        this.baselineNoiseLevel = null;\n        this.voiceDetectionCount = 0;\n        this.suspiciousSoundCount = 0;\n        this.conversationDetected = false;\n        this.sustainedSpeechCount = 0;\n        this.environmentAnalysis = {\n            isQuiet: true,\n            hasConversation: false,\n            noiseLevelHistory: [],\n            lastVoiceActivity: 0,\n            speechSegments: [],\n            conversationStartTime: null,\n            baselineCalibrated: false\n        };\n        \n        // Tab/App monitoring\n        this.tabSwitchCount = 0;\n        this.backgroundAppsDetected = [];\n        this.isFullscreenLocked = false;\n        this.preventStart = false;\n        \n        // Strong Security Enforcement\n        this.enforcementActive = false;\n        this.blockingActive = false;\n        this.blockedEvents = [];\n        this.keyboardBlocker = null;\n        this.screenshotAttempts = 0;\n        this.minimizeAttempts = 0;\n        this.lastFocusTime = Date.now();\n        \n        // Security configuration - Balanced for better user experience\n        this.config = {\n            maxLookAwayTime: 10000,       // 10 seconds (as requested)\n            maxMultiplePeople: 8,         // 8 detections (very lenient)\n            maxCameraHidden: 8,           // 8 detections (very forgiving) \n            maxTabSwitches: 3,            // 3 switches = warning\n            terminateOnViolations: 7,     // 7 violations = terminate (more lenient)\n            realTimeAnalysis: true,       // Live analysis only\n            noImageStorage: true,         // Never store images\n            strictMode: false,            // Balanced for UX\n            lookAwayThreshold: 0.6        // Less sensitive look-away detection\n        };\n        \n        // Violation tracking\n        this.violationLog = [];\n        this.warningCount = 0;\n        this.criticalViolations = 0;\n        this.isTerminated = false;\n        \n        // Enhanced Mobile/Desktop detection with blocking\n        this.isMobile = this.detectMobileDevice();\n        this.isTablet = this.detectTabletDevice();\n        this.deviceInfo = this.getDeviceInfo();\n        \n        this.init();\n    }\n    \n    preventCheating() {\n        // Enhanced cheating prevention setup\n        console.log('[INFO] Setting up enhanced cheating prevention');\n        \n        // Activate strong security enforcement\n        this.activateStrongEnforcement();\n        \n        // Disable text selection\n        document.body.style.userSelect = 'none';\n        document.body.style.webkitUserSelect = 'none';\n        document.body.style.mozUserSelect = 'none';\n        document.body.style.msUserSelect = 'none';\n        \n        // Disable drag and drop\n        document.addEventListener('dragstart', (e) => e.preventDefault());\n        document.addEventListener('drop', (e) => e.preventDefault());\n        \n        // Disable image saving\n        document.addEventListener('contextmenu', (e) => {\n            if (e.target.tagName === 'IMG') {\n                e.preventDefault();\n                this.recordViolation('image_save_attempt', 'medium', 'Attempted to save image');\n            }\n        });\n        \n        // Block screenshot attempts\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'PrintScreen') {\n                e.preventDefault();\n                this.recordViolation('screenshot_attempt', 'high', 'Screenshot attempt detected');\n                this.showSingleWarning('?? Screenshots are not allowed during the quiz');\n            }\n        });\n        \n        // Detect zoom changes\n        let lastZoom = window.devicePixelRatio;\n        setInterval(() => {\n            if (this.isActive && Math.abs(window.devicePixelRatio - lastZoom) > 0.1) {\n                this.recordViolation('zoom_change', 'low', 'Browser zoom level changed');\n                lastZoom = window.devicePixelRatio;\n            }\n        }, 2000);\n        \n        // DISABLED: Mouse movement monitoring (was causing too many false positives)\n        // Only log for debugging, no violations recorded\n        let mouseEvents = [];\n        document.addEventListener('mousemove', (e) => {\n            if (this.isActive) {\n                mouseEvents.push({x: e.clientX, y: e.clientY, time: Date.now()});\n                if (mouseEvents.length > 20) mouseEvents.shift(); // Keep more history\n                \n                // Only check for extremely obvious bot patterns (much less sensitive)\n                if (mouseEvents.length >= 15) {\n                    const isLinear = this.checkLinearMovement(mouseEvents.slice(-10));\n                    if (isLinear) {\n                        // Just log, don't record violation\n                        console.log('[DEBUG] Unusual mouse pattern detected (logged only)');\n                    }\n                }\n            }\n        });\n        \n        // Disable common cheating shortcuts\n        document.addEventListener('keydown', (e) => {\n            if (this.isActive) {\n                const blockedCombos = [\n                    {ctrl: true, shift: true, key: 'i'},  // Dev tools\n                    {ctrl: true, shift: true, key: 'j'},  // Console\n                    {ctrl: true, shift: true, key: 'c'},  // Inspect\n                    {ctrl: true, key: 'u'},               // View source\n                    {ctrl: true, key: 'p'},               // Print\n                    {ctrl: true, key: 'h'},               // History\n                    {f12: true},                          // Dev tools\n                ];\n                \n                for (const combo of blockedCombos) {\n                    if (this.matchesCombo(e, combo)) {\n                        e.preventDefault();\n                        this.recordViolation('blocked_shortcut', 'medium', `Blocked shortcut: ${this.getKeyCombo(e)}`);\n                        return false;\n                    }\n                }\n            }\n        });\n        \n        // Smart page refresh prevention (no auto-reload)\n        this.preventAutoRefresh();\n        \n        // Mobile device blocking\n        if (this.isMobile || this.isTablet) {\n            this.blockMobileAccess();\n            return;\n        }\n    }\n    \n    checkLinearMovement(points) {\n        if (points.length < 3) return false;\n        \n        // Calculate if points form a straight line (bot-like behavior)\n        const tolerance = 5; // pixels\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const point = points[i];\n            const expected = {\n                x: first.x + (last.x - first.x) * (i / (points.length - 1)),\n                y: first.y + (last.y - first.y) * (i / (points.length - 1))\n            };\n            \n            const distance = Math.sqrt(\n                Math.pow(point.x - expected.x, 2) + Math.pow(point.y - expected.y, 2)\n            );\n            \n            if (distance > tolerance) return false;\n        }\n        \n        return true;\n    }\n    \n    matchesCombo(event, combo) {\n        if (combo.f12 && event.key === 'F12') return true;\n        if (combo.ctrl && !event.ctrlKey) return false;\n        if (combo.shift && !event.shiftKey) return false;\n        if (combo.alt && !event.altKey) return false;\n        if (combo.key && event.key.toLowerCase() !== combo.key.toLowerCase()) return false;\n        return true;\n    }\n    \n    getKeyCombo(event) {\n        let combo = '';\n        if (event.ctrlKey) combo += 'Ctrl+';\n        if (event.shiftKey) combo += 'Shift+';\n        if (event.altKey) combo += 'Alt+';\n        combo += event.key;\n        return combo;\n    }\n    \n    async init() {\n        console.log('[INFO] Initializing Enhanced Proctoring System');\n        await this.checkSystemRequirements();\n        this.setupEventListeners();\n        this.preventCheating();\n    }\n    \n    async checkSystemRequirements() {\n        // Check if HTTPS (required for camera)\n        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {\n            this.showCriticalError('?? HTTPS required for camera access. Please use the secure URL.');\n            return false;\n        }\n        \n        // Check for other tabs/apps before starting\n        await this.scanForBackgroundActivities();\n        \n        // Check camera availability\n        try {\n            const devices = await navigator.mediaDevices.enumerateDevices();\n            const cameras = devices.filter(device => device.kind === 'videoinput');\n            if (cameras.length === 0) {\n                this.showCriticalError('? No camera detected. Camera is required for this quiz.');\n                return false;\n            }\n        } catch (error) {\n            this.showCriticalError('? Camera access denied. Please allow camera access.');\n            return false;\n        }\n        \n        return true;\n    }\n    \n    async scanForBackgroundActivities() {\n        // Check for multiple tabs (Chrome API when available)\n        if ('serviceWorker' in navigator) {\n            try {\n                const registration = await navigator.serviceWorker.getRegistration();\n                if (registration) {\n                    // Send message to service worker to check tabs\n                    registration.active?.postMessage({action: 'checkTabs'});\n                }\n            } catch (error) {\n                console.warn('Could not check for multiple tabs');\n            }\n        }\n        \n        // Check window focus\n        if (!document.hasFocus()) {\n            this.preventStart = true;\n            this.showWarning('?? Please focus on this window and close all other applications before starting.');\n        }\n        \n        // Check for developer tools\n        if (this.isDevToolsOpen()) {\n            this.preventStart = true;\n            this.showCriticalError('?? Developer tools detected. Please close developer tools.');\n        }\n    }\n    \n    async startLiveCameraMonitoring() {\n        if (this.isActive) return;\n        \n        try {\n            console.log('[INFO] Starting live camera monitoring (no storage)');\n            \n            // Get camera stream only\n            this.mediaStream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: { ideal: 640 },\n                    height: { ideal: 480 },\n                    frameRate: { ideal: 15 }  // Lower frame rate for performance\n                }\n            });\n            \n            // Audio monitoring removed per user request\n            \n            // Create video element for live analysis\n            this.videoElement = document.createElement('video');\n            this.videoElement.srcObject = this.mediaStream;\n            this.videoElement.autoplay = true;\n            this.videoElement.muted = true;\n            this.videoElement.style.display = 'none'; // Hidden - for analysis only\n            document.body.appendChild(this.videoElement);\n            \n            // Create canvas for real-time analysis (NO STORAGE)\n            this.canvas = document.createElement('canvas');\n            this.context = this.canvas.getContext('2d');\n            this.canvas.style.display = 'none'; // Hidden\n            document.body.appendChild(this.canvas);\n            \n            // Show live camera preview to user\n            this.showLiveCameraPreview();\n            \n            // Start real-time analysis\n            this.videoElement.onloadedmetadata = () => {\n                this.canvas.width = this.videoElement.videoWidth;\n                this.canvas.height = this.videoElement.videoHeight;\n                this.startRealTimeAnalysis();\n            };\n            \n            this.isActive = true;\n            this.showNotification('? Live camera monitoring active', 'success');\n            \n        } catch (error) {\n            console.error('Camera initialization failed:', error);\n            this.showCriticalError('? Camera access failed. Please allow camera access and refresh.');\n            throw error;\n        }\n    }\n    \n    showLiveCameraPreview() {\n        // Create live camera preview for user\n        const previewContainer = document.createElement('div');\n        previewContainer.id = 'live-camera-preview';\n        previewContainer.style.cssText = `\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            width: 200px;\n            height: 150px;\n            border: 2px solid #28a745;\n            border-radius: 8px;\n            background: #000;\n            z-index: 1000;\n            overflow: hidden;\n        `;\n        \n        const previewVideo = document.createElement('video');\n        previewVideo.srcObject = this.mediaStream;\n        previewVideo.autoplay = true;\n        previewVideo.muted = true;\n        previewVideo.style.cssText = `\n            width: 100%;\n            height: 100%;\n            object-fit: cover;\n        `;\n        \n        const statusIndicator = document.createElement('div');\n        statusIndicator.id = 'camera-status';\n        statusIndicator.style.cssText = `\n            position: absolute;\n            bottom: 5px;\n            left: 5px;\n            background: rgba(40, 167, 69, 0.9);\n            color: white;\n            padding: 2px 6px;\n            border-radius: 3px;\n            font-size: 12px;\n            font-weight: bold;\n        `;\n        statusIndicator.textContent = '? LIVE';\n        \n        previewContainer.appendChild(previewVideo);\n        previewContainer.appendChild(statusIndicator);\n        document.body.appendChild(previewContainer);\n    }\n    \n    startRealTimeAnalysis() {\n        console.log('[INFO] Starting real-time behavioral analysis');\n        \n        // Real-time face detection (NO STORAGE) - Less frequent\n        this.faceDetectionInterval = setInterval(() => {\n            this.analyzeLiveFrame();\n        }, 3000); // Analyze every 3 seconds (reduced frequency)\n        \n        // Monitor camera stream status\n        setInterval(() => {\n            this.checkCameraStatus();\n        }, 500);\n    }\n    \n    analyzeLiveFrame() {\n        if (!this.videoElement || this.videoElement.videoWidth === 0) return;\n        \n        try {\n            // Draw current frame to canvas for analysis ONLY\n            this.context.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);\n            \n            // Get image data for analysis (NOT STORED)\n            const imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n            \n            // Perform real-time analysis\n            this.detectFacesInFrame(imageData);\n            this.detectMovementPatterns(imageData);\n            this.detectLookDirection(imageData);\n            \n            // Clear canvas immediately (NO STORAGE)\n            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            \n        } catch (error) {\n            console.error('Frame analysis failed:', error);\n        }\n    }\n    \n    detectFacesInFrame(imageData) {\n        // Simple face detection using brightness and color analysis\n        const data = imageData.data;\n        let facePixelCount = 0;\n        let skinTonePixels = 0;\n        \n        // Scan for skin-tone colored pixels (simple face detection)\n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];\n            const g = data[i + 1];\n            const b = data[i + 2];\n            \n            // Detect skin tones (rough approximation)\n            if (r > 95 && g > 40 && b > 20 && \n                r > g && r > b && \n                Math.abs(r - g) > 15) {\n                skinTonePixels++;\n            }\n        }\n        \n        const skinToneRatio = skinTonePixels / (data.length / 4);\n        \n        // Determine face count based on skin tone distribution (LESS SENSITIVE)\n        let detectedFaces = 1; // Default: assume single person present\n        if (skinToneRatio > 0.15) detectedFaces = 2;  // Multiple people (much higher threshold)\n        if (skinToneRatio < 0.001) detectedFaces = 0; // No face/camera covered (very low threshold)\n        \n        this.processFaceDetection(detectedFaces);\n    }\n    \n    processFaceDetection(faceCount) {\n        const statusIndicator = document.getElementById('camera-status');\n        \n        if (faceCount === 0) {\n            // No face detected or camera covered\n            this.cameraHiddenCount++;\n            this.updateCameraStatus('?? CHECK CAMERA', '#ffc107');\n            \n            if (this.cameraHiddenCount > this.config.maxCameraHidden && !this.warningShown) {\n                this.warningShown = true;\n                this.showSingleWarning('?? Please ensure your camera shows your face clearly');\n                // Reset counter to give user time to adjust\n                this.cameraHiddenCount = 0;\n            }\n        } else if (faceCount === 1) {\n            // Normal - single person (reset all counters)\n            this.cameraHiddenCount = 0;\n            this.multiplePeopleCount = 0;\n            this.warningShown = false; // Allow new warnings after normal detection\n            this.updateCameraStatus('? LIVE', '#28a745');\n        } else if (faceCount >= 2) {\n            // Multiple people detected\n            this.multiplePeopleCount++;\n            this.updateCameraStatus('?? MULTIPLE PEOPLE', '#dc3545');\n            \n            if (this.multiplePeopleCount > this.config.maxMultiplePeople && !this.warningShown) {\n                this.warningShown = true;\n                this.showSingleWarning('?? Multiple people detected. Please ensure you are alone during the quiz.');\n                // Give user time to address the issue\n                this.multiplePeopleCount = 0;\n            }\n        }\n        \n        this.lastFaceCount = faceCount;\n    }\n    \n    updateCameraStatus(text, color) {\n        const statusIndicator = document.getElementById('camera-status');\n        if (statusIndicator) {\n            statusIndicator.textContent = text;\n            statusIndicator.style.backgroundColor = color;\n        }\n    }\n    \n    detectMovementPatterns(imageData) {\n        // Detect if user is looking away from screen\n        // This is a simplified version - in practice you'd use more sophisticated eye tracking\n        const data = imageData.data;\n        let centralBrightness = 0;\n        let edgeBrightness = 0;\n        \n        const centerX = imageData.width / 2;\n        const centerY = imageData.height / 2;\n        const centerRegion = imageData.width / 6;\n        \n        // Sample center region and edge regions\n        for (let y = 0; y < imageData.height; y++) {\n            for (let x = 0; x < imageData.width; x++) {\n                const index = (y * imageData.width + x) * 4;\n                const brightness = (data[index] + data[index + 1] + data[index + 2]) / 3;\n                \n                const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n                \n                if (distFromCenter < centerRegion) {\n                    centralBrightness += brightness;\n                } else if (distFromCenter > centerRegion * 2) {\n                    edgeBrightness += brightness;\n                }\n            }\n        }\n        \n        // Less sensitive look-away detection\n        const lookAwayThreshold = this.config.lookAwayThreshold || 0.6;\n        if (edgeBrightness > centralBrightness * (1 + lookAwayThreshold)) {\n            this.lookAwayCount++;\n            if (this.lookAwayCount > 10) { // More forgiving - need 10 consecutive detections\n                this.recordViolation('looking_away', 'low', 'Extended time looking away from screen');\n                this.lookAwayCount = 0;\n            }\n        } else {\n            this.lookAwayCount = Math.max(0, this.lookAwayCount - 2); // Faster reset\n        }\n    }\n    \n    detectLookDirection(imageData) {\n        // Additional look direction analysis\n        // This would typically use more advanced computer vision\n        // For now, we'll use motion detection\n        \n        if (this.previousFrameData) {\n            const currentData = imageData.data;\n            const prevData = this.previousFrameData;\n            let motionScore = 0;\n            \n            for (let i = 0; i < currentData.length; i += 16) { // Sample every 4th pixel\n                const diff = Math.abs(currentData[i] - prevData[i]);\n                if (diff > 30) motionScore++;\n            }\n            \n            // Too much motion might indicate looking around\n            if (motionScore > 1000) {\n                this.recordViolation('excessive_movement', 'low', 'Excessive movement detected');\n            }\n        }\n        \n        // Store current frame data for next comparison (NOT SAVED TO DISK)\n        this.previousFrameData = new Uint8ClampedArray(imageData.data);\n    }\n    \n    checkCameraStatus() {\n        if (!this.mediaStream) return;\n        \n        const videoTrack = this.mediaStream.getVideoTracks()[0];\n        if (videoTrack && !videoTrack.enabled) {\n            this.recordViolation('camera_disabled', 'critical', 'Camera was disabled');\n        }\n        \n        if (videoTrack && videoTrack.readyState === 'ended') {\n            this.recordViolation('camera_disconnected', 'critical', 'Camera was disconnected');\n        }\n    }\n    \n    setupEventListeners() {\n        // Tab switch detection\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden && this.isActive) {\n                this.tabSwitchCount++;\n                this.recordViolation('tab_switch', 'high', `Tab switched away (${this.tabSwitchCount} times)`);\n                \n                if (this.tabSwitchCount >= this.config.maxTabSwitches) {\n                    this.showCriticalWarning('?? TAB SWITCHING DETECTED! Return to quiz immediately or it will be terminated.');\n                }\n            }\n        });\n        \n        // REDUCED: Window focus detection (less sensitive)\n        let focusLossCount = 0;\n        window.addEventListener('blur', () => {\n            if (this.isActive) {\n                focusLossCount++;\n                // Only record if user loses focus multiple times quickly\n                if (focusLossCount > 3) {\n                    this.recordViolation('frequent_focus_loss', 'low', 'Frequent window focus changes');\n                    focusLossCount = 0; // Reset counter\n                }\n            }\n        });\n        \n        // Reset focus loss count when user returns\n        window.addEventListener('focus', () => {\n            setTimeout(() => {\n                focusLossCount = Math.max(0, focusLossCount - 1);\n            }, 2000);\n        });\n        \n        // Fullscreen exit detection\n        document.addEventListener('fullscreenchange', () => {\n            if (!document.fullscreenElement && this.isActive && this.isFullscreenLocked) {\n                this.recordViolation('fullscreen_exit', 'high', 'Exited fullscreen mode');\n                this.enforceFullscreen();\n            }\n        });\n        \n        // Keyboard shortcuts blocking\n        document.addEventListener('keydown', (e) => {\n            if (this.isActive) {\n                this.blockKeyboardShortcuts(e);\n            }\n        });\n        \n        // Right-click blocking\n        document.addEventListener('contextmenu', (e) => {\n            if (this.isActive) {\n                e.preventDefault();\n                this.recordViolation('right_click', 'low', 'Right-click attempted');\n                return false;\n            }\n        });\n        \n        // Copy/paste blocking\n        document.addEventListener('copy', (e) => {\n            if (this.isActive) {\n                e.preventDefault();\n                this.recordViolation('copy_attempt', 'medium', 'Copy operation attempted');\n            }\n        });\n        \n        document.addEventListener('paste', (e) => {\n            if (this.isActive) {\n                e.preventDefault();\n                this.recordViolation('paste_attempt', 'medium', 'Paste operation attempted');\n            }\n        });\n        \n        // Mobile specific - prevent home button\n        if (this.isMobile || this.isTablet) {\n            this.setupMobileLockdown();\n        }\n    }\n    \n    blockKeyboardShortcuts(event) {\n        const blockedKeys = [\n            'F12',           // Developer tools\n            'F11',           // Fullscreen toggle\n            'PrintScreen',   // Screenshot\n            'Meta',          // Windows/Cmd key\n        ];\n        \n        const blockedCombinations = [\n            {ctrl: true, key: 'c'},          // Copy\n            {ctrl: true, key: 'v'},          // Paste\n            {ctrl: true, key: 'x'},          // Cut\n            {ctrl: true, key: 'a'},          // Select all\n            {ctrl: true, key: 's'},          // Save\n            {ctrl: true, key: 'r'},          // Refresh\n            {ctrl: true, key: 'w'},          // Close tab\n            {ctrl: true, key: 't'},          // New tab\n            {ctrl: true, key: 'n'},          // New window\n            {ctrl: true, shift: true, key: 'i'}, // Dev tools\n            {ctrl: true, shift: true, key: 'j'}, // Console\n            {ctrl: true, shift: true, key: 'c'}, // Inspect\n            {alt: true, key: 'Tab'},         // Alt+Tab\n            {alt: true, key: 'F4'},          // Alt+F4\n            {meta: true, key: 'Tab'},        // Cmd+Tab (Mac)\n        ];\n        \n        // Check single keys\n        if (blockedKeys.includes(event.key)) {\n            event.preventDefault();\n            this.recordViolation('blocked_shortcut', 'medium', `Blocked shortcut: ${event.key}`);\n            return false;\n        }\n        \n        // Check key combinations\n        for (const combo of blockedCombinations) {\n            let match = true;\n            if (combo.ctrl && !event.ctrlKey) match = false;\n            if (combo.alt && !event.altKey) match = false;\n            if (combo.shift && !event.shiftKey) match = false;\n            if (combo.meta && !event.metaKey) match = false;\n            if (combo.key && event.key.toLowerCase() !== combo.key.toLowerCase()) match = false;\n            \n            if (match) {\n                event.preventDefault();\n                this.recordViolation('blocked_shortcut', 'medium', `Blocked combination: ${JSON.stringify(combo)}`);\n                return false;\n            }\n        }\n    }\n    \n    setupMobileLockdown() {\n        // Prevent mobile app switching\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden && this.isActive) {\n                setTimeout(() => {\n                    if (document.hidden) {\n                        this.recordViolation('mobile_app_switch', 'critical', 'Switched to another app on mobile');\n                    }\n                }, 1000);\n            }\n        });\n        \n        // Prevent pinch zoom\n        document.addEventListener('touchstart', (e) => {\n            if (e.touches.length > 1) {\n                e.preventDefault();\n                this.recordViolation('pinch_zoom', 'low', 'Pinch zoom attempted');\n            }\n        }, {passive: false});\n        \n        // Prevent pull-to-refresh\n        document.addEventListener('touchmove', (e) => {\n            if (e.touches.length === 1 && window.scrollY === 0) {\n                e.preventDefault();\n            }\n        }, {passive: false});\n    }\n    \n    enforceFullscreen() {\n        if (!document.fullscreenElement) {\n            document.documentElement.requestFullscreen().catch(err => {\n                console.warn('Cannot enforce fullscreen:', err);\n            });\n        }\n        this.isFullscreenLocked = true;\n    }\n    \n    activateDoNotDisturbMode() {\n        console.log('[INFO] Activating Do Not Disturb Mode');\n        \n        // Hide all other UI elements\n        const elementsToHide = ['nav', 'header', 'footer', '.sidebar', '.notification'];\n        elementsToHide.forEach(selector => {\n            const elements = document.querySelectorAll(selector);\n            elements.forEach(el => {\n                el.style.display = 'none';\n            });\n        });\n        \n        // Create lockdown overlay\n        const lockdownOverlay = document.createElement('div');\n        lockdownOverlay.id = 'proctoring-lockdown';\n        lockdownOverlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.95);\n            z-index: 999999;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: white;\n            font-family: Arial, sans-serif;\n        `;\n        \n        lockdownOverlay.innerHTML = `\n            <div style=\"text-align: center;\">\n                <h2>? PROCTORED QUIZ MODE</h2>\n                <p>Quiz is locked in secure mode</p>\n                <p>Do not attempt to exit or switch applications</p>\n                <div id=\"lockdown-status\">Waiting for quiz to start...</div>\n            </div>\n        `;\n        \n        document.body.appendChild(lockdownOverlay);\n        \n        // Enforce fullscreen\n        this.enforceFullscreen();\n        \n        // Disable browser notifications\n        if ('Notification' in window) {\n            Notification.requestPermission().then(permission => {\n                if (permission === 'granted') {\n                    // Block notifications during quiz\n                    this.originalNotification = window.Notification;\n                    window.Notification = function() { return null; };\n                }\n            });\n        }\n    }\n    \n    recordViolation(type, severity, description) {\n        const violation = {\n            timestamp: new Date().toISOString(),\n            type: type,\n            severity: severity,\n            description: description,\n            attemptId: this.attemptId\n        };\n        \n        this.violations.push(violation);\n        this.violationLog.push(violation);\n        \n        console.warn(`? VIOLATION [${severity.toUpperCase()}]: ${description}`);\n        \n        // Count violations by severity\n        if (severity === 'critical') {\n            this.criticalViolations++;\n        } else if (severity === 'high') {\n            this.warningCount++;\n        }\n        \n        // Send to server in real-time\n        this.sendViolationToServer(violation);\n        \n        // Show appropriate response\n        this.handleViolationResponse(violation);\n        \n        // Check for termination\n        if (this.shouldTerminateQuiz()) {\n            this.terminateQuiz();\n        }\n    }\n    \n    handleViolationResponse(violation) {\n        // Only show one warning per violation type\n        if (this.warningShown) return;\n        \n        switch (violation.severity) {\n            case 'critical':\n                this.showCriticalWarning(`? CRITICAL: ${violation.description}`);\n                break;\n            case 'high':\n                this.showSingleWarning(`?? WARNING: ${violation.description}`);\n                break;\n            case 'medium':\n                this.showNotification(`?? ${violation.description}`, 'warning');\n                break;\n            case 'low':\n                console.log(`[DEBUG] ${violation.description}`);\n                break;\n        }\n    }\n    \n    showSingleWarning(message) {\n        // REDUCED: Only show warning for important issues, no spam\n        console.warn(message);\n        \n        // Only show visual warning for critical issues\n        if (message.includes('CRITICAL') || message.includes('multiple people')) {\n            const toast = document.createElement('div');\n            toast.style.cssText = `\n                position: fixed;\n                top: 100px;\n                right: 20px;\n                background: #ffc107;\n                color: #000;\n                padding: 8px 15px;\n                border-radius: 6px;\n                z-index: 10000;\n                font-weight: bold;\n                max-width: 250px;\n                border: 1px solid #ff9800;\n                font-size: 14px;\n            `;\n            toast.textContent = message;\n            document.body.appendChild(toast);\n            \n            // Remove toast after 3 seconds (shorter)\n            setTimeout(() => {\n                if (toast.parentNode) toast.remove();\n            }, 3000);\n        }\n    }\n    \n    shouldTerminateQuiz() {\n        return this.criticalViolations >= 1 || \n               (this.warningCount + this.criticalViolations) >= this.config.terminateOnViolations ||\n               this.tabSwitchCount >= 3 ||\n               this.multiplePeopleCount >= 3;\n    }\n    \n    terminateQuiz() {\n        if (this.isTerminated) return;\n        \n        this.isTerminated = true;\n        console.error('[ERROR] QUIZ TERMINATED DUE TO VIOLATIONS');\n        \n        // Stop all monitoring\n        this.stopMonitoring();\n        \n        // Show termination screen\n        this.showTerminationScreen();\n        \n        // Submit quiz automatically\n        if (typeof submitQuizAutomatically === 'function') {\n            submitQuizAutomatically('terminated_violations');\n        }\n        \n        // Redirect after delay\n        setTimeout(() => {\n            window.location.href = '/dashboard';\n        }, 5000);\n    }\n    \n    showTerminationScreen() {\n        const terminationScreen = document.createElement('div');\n        terminationScreen.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(135deg, #dc3545, #6f1319);\n            color: white;\n            z-index: 999999;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-family: Arial, sans-serif;\n            text-align: center;\n        `;\n        \n        terminationScreen.innerHTML = `\n            <div>\n                <h1>? QUIZ TERMINATED</h1>\n                <h3>Multiple violations detected</h3>\n                <p>Your quiz session has been terminated due to:</p>\n                <ul style=\"text-align: left; margin: 20px 0;\">\n                    ${this.violationLog.map(v => `<li>${v.description}</li>`).join('')}\n                </ul>\n                <p>This incident has been reported to your instructor.</p>\n                <p>Redirecting in 5 seconds...</p>\n            </div>\n        `;\n        \n        document.body.appendChild(terminationScreen);\n    }\n    \n    async sendViolationToServer(violation) {\n        // Enhanced violation server communication with immediate malpractice handling\n        try {\n            const violationData = {\n                attemptId: this.attemptId,\n                type: violation.type,\n                severity: violation.severity,\n                description: violation.description,\n                timestamp: new Date().toISOString(),\n                details: {\n                    ...violation.details,\n                    userAgent: navigator.userAgent,\n                    isMobile: this.isMobile,\n                    isTablet: this.isTablet\n                }\n            };\n\n            const response = await fetch('/api/proctoring/violation', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRFToken': this.getCSRFToken()\n                },\n                body: JSON.stringify(violationData)\n            });\n\n            if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n\n            const result = await response.json();\n            \n            // Handle immediate malpractice termination\n            if (result.should_terminate || this.shouldTriggerImmediateMalpractice(violation)) {\n                await this.handleImmediateMalpractice(violation, result);\n            }\n\n            return result;\n        } catch (error) {\n            console.error('Failed to send violation to server:', error);\n            \n            // Store violation locally if server fails (for recovery)\n            this.storeViolationLocally(violation);\n            \n            // Still trigger immediate malpractice for critical violations\n            if (this.shouldTriggerImmediateMalpractice(violation)) {\n                await this.handleImmediateMalpractice(violation, null);\n            }\n        }\n    }\n    \n    stopMonitoring() {\n        console.log('[INFO] Stopping all monitoring systems');\n        this.isActive = false;\n        \n        // Deactivate strong enforcement\n        this.deactivateStrongEnforcement();\n        \n        // Stop video monitoring\n        if (this.faceDetectionInterval) {\n            clearInterval(this.faceDetectionInterval);\n            this.faceDetectionInterval = null;\n        }\n        \n        // Audio monitoring removed per user request\n        \n        // Stop all media tracks\n        if (this.mediaStream) {\n            this.mediaStream.getTracks().forEach(track => {\n                try {\n                    track.stop();\n                    console.log(`[INFO] Stopped ${track.kind} track`);\n                } catch (error) {\n                    console.warn(`Failed to stop ${track.kind} track:`, error);\n                }\n            });\n            this.mediaStream = null;\n        }\n        \n        // Clear audio analysis data\n        this.analyser = null;\n        this.dataArray = null;\n        this.baselineNoiseLevel = null;\n        this.environmentAnalysis = {\n            isQuiet: true,\n            hasConversation: false,\n            noiseLevelHistory: [],\n            lastVoiceActivity: 0\n        };\n        \n        // Remove UI elements\n        this.removeMonitoringUI();\n        \n        // Remove hidden elements\n        if (this.videoElement) {\n            this.videoElement.remove();\n            this.videoElement = null;\n        }\n        if (this.canvas) {\n            this.canvas.remove();\n            this.canvas = null;\n        }\n        \n        console.log('[INFO] All monitoring systems stopped and cleaned up');\n    }\n    \n    removeMonitoringUI() {\n        // Remove camera preview\n        const preview = document.getElementById('live-camera-preview');\n        if (preview) {\n            preview.remove();\n            console.log('Removed camera preview');\n        }\n        \n        // Audio monitoring removed per user request\n        \n        // Remove privacy notice if still visible\n        const privacyNotice = document.getElementById('audio-privacy-notice');\n        if (privacyNotice) {\n            privacyNotice.remove();\n            console.log('Removed privacy notice');\n        }\n        \n        // Reset proctoring status\n        const statusAlert = document.getElementById('proctoring-status-alert');\n        if (statusAlert) {\n            statusAlert.className = 'alert alert-secondary';\n            statusAlert.innerHTML = '<i class=\"fas fa-shield\"></i> <strong>MONITORING STOPPED</strong><br><small>All monitoring systems have been disabled</small>';\n        }\n    }\n    \n    async startAudioEnvironmentAnalysis() {\n        // Audio monitoring removed per user request\n        console.log('Audio monitoring has been disabled');\n        return;\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    analyzeEnvironmentQuality() {\n        // Overall environment quality assessment\n        const history = this.environmentAnalysis.noiseLevelHistory;\n        if (history.length < 10) return;\n        \n        const recentSamples = history.slice(-10);\n        const averageRecent = recentSamples.reduce((sum, val) => sum + val, 0) / recentSamples.length;\n        const variability = this.calculateVariability(recentSamples);\n        \n        // Environment is considered good if:\n        // 1. Noise level is consistent (low variability)\n        // 2. Average level is close to baseline\n        // 3. No recent voice activity\n        \n        const isEnvironmentGood = (\n            variability < 15 && // Low variability\n            this.baselineNoiseLevel && \n            averageRecent < this.baselineNoiseLevel * 1.3 && // Close to baseline\n            !this.environmentAnalysis.hasConversation\n        );\n        \n        // Update proctoring status based on environment quality\n        const statusAlert = document.getElementById('proctoring-status-alert');\n        if (statusAlert && this.audioMonitoringActive) {\n            if (isEnvironmentGood) {\n                statusAlert.className = 'alert alert-success';\n                statusAlert.innerHTML = '<i class=\"fas fa-shield-check\"></i> <strong>SECURE ENVIRONMENT</strong><br><small>Camera ? Audio ? Quiet environment detected</small>';\n            } else if (this.environmentAnalysis.hasConversation) {\n                statusAlert.className = 'alert alert-warning';\n                statusAlert.innerHTML = '<i class=\"fas fa-exclamation-triangle\"></i> <strong>VOICE DETECTED</strong><br><small>Conversation or voice activity in background</small>';\n            } else if (!this.environmentAnalysis.isQuiet) {\n                statusAlert.className = 'alert alert-warning';\n                statusAlert.innerHTML = '<i class=\"fas fa-volume-up\"></i> <strong>NOISY ENVIRONMENT</strong><br><small>Background noise above acceptable levels</small>';\n            }\n        }\n    }\n    \n    calculateVariability(samples) {\n        if (samples.length < 2) return 0;\n        \n        const mean = samples.reduce((sum, val) => sum + val, 0) / samples.length;\n        const variance = samples.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / samples.length;\n        return Math.sqrt(variance);\n    }\n    \n    showAudioPrivacyNotice() {\n        // Show privacy notice\n        const notice = document.createElement('div');\n        notice.id = 'audio-privacy-notice';\n        notice.style.cssText = `\n            position: fixed;\n            bottom: 20px;\n            left: 20px;\n            max-width: 280px;\n            background: rgba(23, 162, 184, 0.95);\n            color: white;\n            padding: 12px;\n            border-radius: 8px;\n            font-size: 11px;\n            z-index: 1002;\n            border: 1px solid #17a2b8;\n        `;\n        \n        notice.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 6px;\">? Audio Privacy Notice</div>\n            <div style=\"margin-bottom: 8px;\">Audio is being analyzed in real-time for:</div>\n            <ul style=\"margin: 0; padding-left: 16px; font-size: 10px;\">\n                <li>Background noise levels</li>\n                <li>Voice activity detection</li>\n                <li>Environment quality</li>\n            </ul>\n            <div style=\"margin-top: 8px; font-weight: bold; font-size: 10px;\">NO AUDIO IS RECORDED OR STORED</div>\n            <button onclick=\"this.parentElement.remove()\" style=\"\n                background: #fff;\n                border: none;\n                color: #17a2b8;\n                padding: 4px 8px;\n                border-radius: 4px;\n                font-size: 10px;\n                cursor: pointer;\n                margin-top: 8px;\n            \">Got it</button>\n        `;\n        \n        document.body.appendChild(notice);\n        \n        // Auto-remove after 10 seconds\n        setTimeout(() => {\n            if (notice.parentElement) notice.remove();\n        }, 10000);\n    }\n    \n    handleAudioSetupFailure(error) {\n        console.error('Audio monitoring setup failed:', error);\n        \n        // Determine error type and provide appropriate feedback\n        let userMessage = '?? Audio monitoring setup failed.';\n        let severity = 'medium';\n        \n        if (error.message.includes('denied') || error.message.includes('not supported')) {\n            userMessage = '? Microphone access denied. Audio monitoring disabled.';\n            severity = 'high';\n        } else if (error.message.includes('in use')) {\n            userMessage = '? Microphone is in use by another application.';\n            severity = 'high';\n        } else if (error.message.includes('context')) {\n            userMessage = '? Audio context failed. Please refresh and try again.';\n            severity = 'medium';\n        }\n        \n        // Record violation with appropriate severity\n        this.recordViolation('audio_setup_failed', severity, error.message);\n        \n        // Show user-friendly message\n        this.showSingleWarning(userMessage);\n        \n        // Set audio monitoring as failed but don't block the quiz\n        this.audioMonitoringActive = false;\n        this.audioSetupFailed = true;\n        \n        // Show fallback indicator\n        this.showAudioFailureIndicator();\n        \n        // Continue with visual monitoring only\n        console.warn('Continuing with visual monitoring only');\n    }\n    \n    showAudioFailureIndicator() {\n        const indicator = document.createElement('div');\n        indicator.id = 'monitoring-indicator';\n        indicator.style.cssText = `\n            position: fixed;\n            top: 20px;\n            left: 20px;\n            width: 120px;\n            height: 40px;\n            background: rgba(220, 53, 69, 0.9);\n            color: white;\n            border-radius: 8px;\n            padding: 8px;\n            z-index: 1001;\n            font-size: 11px;\n            text-align: center;\n            border: 2px solid #dc3545;\n        `;\n        \n        indicator.innerHTML = `\n            <div>? AUDIO DISABLED</div>\n            <div style=\"font-size: 9px; margin-top: 4px;\">Visual only</div>\n        `;\n        \n        document.body.appendChild(indicator);\n    }\n    \n    // Utility methods\n    isDevToolsOpen() {\n        const threshold = 160;\n        return window.outerHeight - window.innerHeight > threshold ||\n               window.outerWidth - window.innerWidth > threshold;\n    }\n    \n    getCSRFToken() {\n        const token = document.querySelector('meta[name=\"csrf-token\"]');\n        return token ? token.getAttribute('content') : '';\n    }\n\n    // ============== MOBILE DETECTION & BLOCKING ==============\n    \n    detectMobileDevice() {\n        // Comprehensive mobile detection\n        const userAgent = navigator.userAgent.toLowerCase();\n        const mobileKeywords = ['mobile', 'android', 'iphone', 'ipod', 'blackberry', 'windows phone'];\n        \n        // Check user agent\n        const isMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));\n        \n        // Check touch capabilities\n        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        \n        // Check screen size\n        const smallScreen = window.screen.width <= 768 || window.screen.height <= 768;\n        \n        // Check CSS media queries\n        const isMobileMedia = window.matchMedia('(pointer: coarse)').matches;\n        \n        return isMobileUA || (hasTouch && smallScreen) || isMobileMedia;\n    }\n\n    detectTabletDevice() {\n        const userAgent = navigator.userAgent.toLowerCase();\n        const tabletKeywords = ['tablet', 'ipad'];\n        \n        const isTabletUA = tabletKeywords.some(keyword => userAgent.includes(keyword));\n        const largeTouch = 'ontouchstart' in window && window.screen.width > 768;\n        \n        return isTabletUA || largeTouch;\n    }\n\n    getDeviceInfo() {\n        return {\n            userAgent: navigator.userAgent,\n            screenWidth: window.screen.width,\n            screenHeight: window.screen.height,\n            maxTouchPoints: navigator.maxTouchPoints || 0,\n            orientation: screen.orientation?.type || 'unknown',\n            pixelRatio: window.devicePixelRatio || 1\n        };\n    }\n\n    blockMobileAccess() {\n        console.error('? Mobile device detected - Quiz access blocked');\n        \n        // Create blocking overlay\n        const blockingOverlay = document.createElement('div');\n        blockingOverlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(135deg, #dc3545, #6f1319);\n            color: white;\n            z-index: 999999;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-family: Arial, sans-serif;\n            text-align: center;\n        `;\n        \n        blockingOverlay.innerHTML = `\n            <div style=\"max-width: 400px; padding: 20px;\">\n                <h1>? Mobile Access Blocked</h1>\n                <h3>Quiz access restricted to desktop computers only</h3>\n                <p>For security and proctoring requirements, this quiz must be taken on a desktop or laptop computer.</p>\n                <p><strong>Device detected:</strong> ${this.isMobile ? 'Mobile Phone' : 'Tablet'}</p>\n                <hr style=\"margin: 20px 0; opacity: 0.3;\">\n                <p style=\"font-size: 14px;\">Please use a desktop computer and try again.</p>\n                <p style=\"font-size: 12px; opacity: 0.7;\">This restriction ensures exam integrity and proper proctoring.</p>\n            </div>\n        `;\n        \n        document.body.appendChild(blockingOverlay);\n        \n        // Record device violation\n        this.recordViolation('mobile_device_blocked', 'critical', \n            `Mobile device access blocked: ${this.deviceInfo.userAgent}`);\n        \n        // Prevent any further initialization\n        this.preventStart = true;\n        return;\n    }\n\n    // ============== AUTO-REFRESH PREVENTION ==============\n    \n    preventAutoRefresh() {\n        // Add reload-loop protection\n        const reloadAttempts = parseInt(sessionStorage.getItem('quiz_reload_attempts') || '0');\n        \n        if (reloadAttempts >= 3) {\n            console.error('? Multiple reload attempts detected - blocking further reloads');\n            this.showCriticalError('Too many page reload attempts detected. Please contact your instructor.');\n            return;\n        }\n        \n        // Increment reload counter\n        sessionStorage.setItem('quiz_reload_attempts', (reloadAttempts + 1).toString());\n        \n        // Smart beforeunload handling\n        window.addEventListener('beforeunload', (e) => {\n            if (this.isActive && !this.isTerminated) {\n                // Record the attempt but don't auto-refresh\n                this.recordViolation('page_unload_attempt', 'medium', 'User attempted to leave quiz page');\n                \n                // Show warning but allow user choice\n                const message = 'Are you sure you want to leave the quiz? This may be recorded as a violation.';\n                e.returnValue = message;\n                return message;\n            }\n        });\n        \n        // Clear reload counter on successful quiz completion\n        window.addEventListener('quiz:completed', () => {\n            sessionStorage.removeItem('quiz_reload_attempts');\n        });\n    }\n\n    // ============== IMMEDIATE MALPRACTICE HANDLING ==============\n    \n    shouldTriggerImmediateMalpractice(violation) {\n        // Define immediate malpractice triggers\n        const criticalViolations = [\n            'mobile_device_blocked',\n            'multiple_people_detected',\n            'camera_disabled',\n            'sustained_conversation',\n            'cheating_software_detected',\n            'identity_verification_failed'\n        ];\n        \n        // Immediate triggers\n        if (criticalViolations.includes(violation.type)) {\n            return true;\n        }\n        \n        // Count-based triggers\n        const highSeverityCount = this.violationLog.filter(v => v.severity === 'high' || v.severity === 'critical').length;\n        const tabSwitchCount = this.violationLog.filter(v => v.type.includes('tab_switch')).length;\n        const lookAwayCount = this.violationLog.filter(v => v.type.includes('look_away')).length;\n        \n        return (\n            highSeverityCount >= 2 ||          // 2 high/critical violations\n            tabSwitchCount >= 3 ||             // 3 tab switches\n            lookAwayCount >= 5 ||              // 5 look-away instances\n            this.violationLog.length >= 8      // 8 total violations\n        );\n    }\n\n    async handleImmediateMalpractice(violation, serverResponse) {\n        console.error('? IMMEDIATE MALPRACTICE DETECTED:', violation);\n        \n        this.isTerminated = true;\n        this.criticalViolations++;\n        \n        // Mark user as malpractice immediately\n        try {\n            await this.markAsMalpractice(violation);\n            await this.notifyHostAndParticipants(violation);\n        } catch (error) {\n            console.error('Failed to send immediate malpractice notifications:', error);\n        }\n        \n        // Show immediate termination screen\n        this.showMalpracticeTerminationScreen(violation);\n        \n        // Auto-submit quiz if possible\n        setTimeout(() => {\n            this.forceQuizSubmission();\n        }, 3000);\n    }\n\n    async markAsMalpractice(violation) {\n        const malpracticeData = {\n            attemptId: this.attemptId,\n            quizId: this.quizId,\n            violation: violation,\n            timestamp: new Date().toISOString(),\n            action: 'immediate_termination',\n            severity: 'critical'\n        };\n\n        await fetch('/api/proctoring/mark-malpractice', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': this.getCSRFToken()\n            },\n            body: JSON.stringify(malpracticeData)\n        });\n    }\n\n    async notifyHostAndParticipants(violation) {\n        // Notify host immediately\n        const hostNotification = {\n            type: 'immediate_malpractice',\n            attemptId: this.attemptId,\n            quizId: this.quizId,\n            violation: violation,\n            message: `? IMMEDIATE MALPRACTICE: ${violation.description}`,\n            severity: 'critical',\n            student: {\n                name: document.querySelector('[data-username]')?.dataset.username || 'Unknown',\n                email: document.querySelector('[data-email]')?.dataset.email || 'Unknown'\n            }\n        };\n\n        await fetch('/api/proctoring/notify-violation', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': this.getCSRFToken()\n            },\n            body: JSON.stringify(hostNotification)\n        });\n\n        // Notify other participants if required\n        const participantNotification = {\n            type: 'malpractice_alert',\n            quizId: this.quizId,\n            message: '?? A participant has been terminated for malpractice during this quiz session.'\n        };\n\n        await fetch('/api/proctoring/notify-participants', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': this.getCSRFToken()\n            },\n            body: JSON.stringify(participantNotification)\n        });\n    }\n\n    showMalpracticeTerminationScreen(violation) {\n        const terminationScreen = document.createElement('div');\n        terminationScreen.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(135deg, #dc3545, #6f1319);\n            color: white;\n            z-index: 999999;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-family: Arial, sans-serif;\n            text-align: center;\n        `;\n        \n        terminationScreen.innerHTML = `\n            <div style=\"max-width: 500px; padding: 30px;\">\n                <h1>? MALPRACTICE DETECTED</h1>\n                <h2>Quiz Terminated Immediately</h2>\n                <div style=\"background: rgba(255,255,255,0.1); padding: 20px; border-radius: 8px; margin: 20px 0;\">\n                    <h3>Violation: ${violation.description}</h3>\n                    <p><strong>Severity:</strong> ${violation.severity.toUpperCase()}</p>\n                    <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>\n                </div>\n                <p><strong>Actions Taken:</strong></p>\n                <ul style=\"text-align: left; margin: 20px 0;\">\n                    <li>? Host notified immediately</li>\n                    <li>? Incident logged in system</li>\n                    <li>? Quiz attempt marked as malpractice</li>\n                    <li>? Academic integrity office alerted</li>\n                </ul>\n                <p style=\"color: #ffcccc;\"><strong>This incident will be reviewed by your instructor and academic integrity committee.</strong></p>\n                <p>Redirecting to dashboard in <span id=\"countdown\">10</span> seconds...</p>\n            </div>\n        `;\n        \n        document.body.appendChild(terminationScreen);\n        \n        // Countdown timer\n        let seconds = 10;\n        const countdownElement = terminationScreen.querySelector('#countdown');\n        const timer = setInterval(() => {\n            seconds--;\n            countdownElement.textContent = seconds;\n            if (seconds <= 0) {\n                clearInterval(timer);\n                window.location.href = '/dashboard';\n            }\n        }, 1000);\n    }\n\n    forceQuizSubmission() {\n        // Force submit the quiz with malpractice flag\n        const submitData = {\n            action: 'force_submit',\n            reason: 'malpractice_detected',\n            timestamp: new Date().toISOString()\n        };\n\n        fetch('/api/quiz/force-submit', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-CSRFToken': this.getCSRFToken()\n            },\n            body: JSON.stringify(submitData)\n        }).catch(error => {\n            console.error('Failed to force submit quiz:', error);\n        });\n    }\n\n    storeViolationLocally(violation) {\n        // Store violation locally for recovery if server fails\n        const localViolations = JSON.parse(localStorage.getItem('quiz_violations') || '[]');\n        localViolations.push({\n            ...violation,\n            timestamp: new Date().toISOString(),\n            attemptId: this.attemptId,\n            stored_locally: true\n        });\n        localStorage.setItem('quiz_violations', JSON.stringify(localViolations));\n    }\n\n    // ============== ENHANCED BACKGROUND NOISE & SPEECH DETECTION ==============\n    \n    async setupEnhancedAudioMonitoring() {\n        console.log('[INFO] Audio monitoring disabled per user request');\n        \n        try {\n            // Request enhanced audio permissions\n            this.audioStream = await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    echoCancellation: false,      // Disable to detect background voices\n                    noiseSuppression: false,      // Disable to catch all sounds\n                    autoGainControl: false,       // Disable to get raw levels\n                    sampleRate: 44100,           // High quality for speech analysis\n                    channelCount: 1              // Mono for processing efficiency\n                }\n            });\n\n            // Create enhanced audio context for analysis\n            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\n                sampleRate: 44100\n            });\n\n            const source = this.audioContext.createMediaStreamSource(this.audioStream);\n            this.analyser = this.audioContext.createAnalyser();\n            \n            // Enhanced analyzer settings for speech detection\n            this.analyser.fftSize = 2048;\n            this.analyser.smoothingTimeConstant = 0.3;\n            this.analyser.minDecibels = -90;\n            this.analyser.maxDecibels = -10;\n            \n            source.connect(this.analyser);\n\n            this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\n            this.audioMonitoringActive = true;\n\n            // Calibrate baseline environment for 8 seconds\n            await this.calibrateEnvironmentBaseline();\n            \n            // Start continuous enhanced audio analysis\n            this.startEnhancedAudioAnalysis();\n            \n            console.log('[INFO] Camera monitoring activated (audio disabled)');\n            this.showAudioMonitoringIndicator();\n\n        } catch (error) {\n            console.error('Monitoring setup failed:', error);\n            this.handleAudioSetupFailure(error);\n        }\n    }\n\n    async calibrateEnvironmentBaseline() {\n        console.log('[INFO] Calibrating environment baseline for speech detection...');\n        \n        const calibrationSamples = [];\n        const calibrationDuration = 8000; // 8 seconds\n        const sampleInterval = 100; // Sample every 100ms\n        \n        return new Promise((resolve) => {\n            const startTime = Date.now();\n            \n            const calibrationInterval = setInterval(() => {\n                if (!this.audioMonitoringActive) {\n                    clearInterval(calibrationInterval);\n                    resolve();\n                    return;\n                }\n                \n                this.analyser.getByteFrequencyData(this.dataArray);\n                \n                // Calculate multiple audio metrics for baseline\n                const rms = this.calculateRMS(this.dataArray);\n                const spectralCentroid = this.calculateSpectralCentroid(this.dataArray);\n                const spectralRolloff = this.calculateSpectralRolloff(this.dataArray);\n                \n                calibrationSamples.push({\n                    rms,\n                    spectralCentroid,\n                    spectralRolloff,\n                    timestamp: Date.now()\n                });\n                \n                if (Date.now() - startTime >= calibrationDuration) {\n                    clearInterval(calibrationInterval);\n                    \n                    // Calculate baseline metrics\n                    this.baselineNoiseLevel = this.calculateBaselineMetrics(calibrationSamples);\n                    this.environmentAnalysis.baselineCalibrated = true;\n                    \n                    console.log('[INFO] Environment baseline calibrated:', this.baselineNoiseLevel);\n                    resolve();\n                }\n            }, sampleInterval);\n        });\n    }\n\n    calculateBaselineMetrics(samples) {\n        const rmsValues = samples.map(s => s.rms);\n        const centroidValues = samples.map(s => s.spectralCentroid);\n        const rolloffValues = samples.map(s => s.spectralRolloff);\n        \n        return {\n            avgRMS: rmsValues.reduce((a, b) => a + b, 0) / rmsValues.length,\n            maxRMS: Math.max(...rmsValues),\n            avgSpectralCentroid: centroidValues.reduce((a, b) => a + b, 0) / centroidValues.length,\n            avgSpectralRolloff: rolloffValues.reduce((a, b) => a + b, 0) / rolloffValues.length,\n            variabilityRMS: this.calculateVariance(rmsValues)\n        };\n    }\n\n    calculateVariance(values) {\n        const mean = values.reduce((a, b) => a + b, 0) / values.length;\n        return values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;\n    }\n\n    startEnhancedAudioAnalysis() {\n        const analysisInterval = 250; // Analyze every 250ms for speech detection\n        \n        this.audioAnalysisInterval = setInterval(() => {\n            if (!this.audioMonitoringActive || !this.environmentAnalysis.baselineCalibrated) return;\n            \n            this.analyser.getByteFrequencyData(this.dataArray);\n            \n            // Calculate current audio metrics\n            const currentMetrics = {\n                rms: this.calculateRMS(this.dataArray),\n                spectralCentroid: this.calculateSpectralCentroid(this.dataArray),\n                spectralRolloff: this.calculateSpectralRolloff(this.dataArray),\n                timestamp: Date.now()\n            };\n            \n            // Analyze for speech patterns\n            this.analyzeForSpeechPatterns(currentMetrics);\n            \n            // Check for conversation detection\n            this.checkForConversation(currentMetrics);\n            \n            // Update environment analysis\n            this.updateEnvironmentAnalysis(currentMetrics);\n            \n        }, analysisInterval);\n    }\n\n    calculateRMS(dataArray) {\n        let sum = 0;\n        for (let i = 0; i < dataArray.length; i++) {\n            sum += dataArray[i] * dataArray[i];\n        }\n        return Math.sqrt(sum / dataArray.length);\n    }\n\n    calculateSpectralCentroid(dataArray) {\n        let numerator = 0;\n        let denominator = 0;\n        \n        for (let i = 0; i < dataArray.length; i++) {\n            numerator += i * dataArray[i];\n            denominator += dataArray[i];\n        }\n        \n        return denominator > 0 ? numerator / denominator : 0;\n    }\n\n    calculateSpectralRolloff(dataArray) {\n        const totalEnergy = dataArray.reduce((sum, val) => sum + val, 0);\n        const threshold = totalEnergy * 0.85; // 85% energy threshold\n        \n        let cumulativeEnergy = 0;\n        for (let i = 0; i < dataArray.length; i++) {\n            cumulativeEnergy += dataArray[i];\n            if (cumulativeEnergy >= threshold) {\n                return i;\n            }\n        }\n        return dataArray.length - 1;\n    }\n\n    analyzeForSpeechPatterns(currentMetrics) {\n        if (!this.baselineNoiseLevel) return;\n        \n        const baseline = this.baselineNoiseLevel;\n        \n        // Speech detection criteria\n        const rmsThreshold = baseline.avgRMS + (baseline.variabilityRMS * 2.5);\n        const centroidThreshold = baseline.avgSpectralCentroid * 1.3; // Human speech increases centroid\n        \n        const isSpeechLikely = \n            currentMetrics.rms > rmsThreshold &&\n            currentMetrics.spectralCentroid > centroidThreshold &&\n            currentMetrics.spectralRolloff > baseline.avgSpectralRolloff * 1.2;\n        \n        if (isSpeechLikely) {\n            this.detectSpeechActivity(currentMetrics);\n        } else {\n            this.resetSpeechDetection();\n        }\n    }\n\n    detectSpeechActivity(metrics) {\n        const now = Date.now();\n        \n        // Add to speech segments\n        this.environmentAnalysis.speechSegments.push({\n            timestamp: now,\n            rms: metrics.rms,\n            spectralCentroid: metrics.spectralCentroid,\n            confidence: this.calculateSpeechConfidence(metrics)\n        });\n        \n        // Keep only recent speech segments (last 10 seconds)\n        this.environmentAnalysis.speechSegments = this.environmentAnalysis.speechSegments\n            .filter(segment => now - segment.timestamp < 10000);\n        \n        this.voiceDetectionCount++;\n        this.environmentAnalysis.lastVoiceActivity = now;\n        \n        // Check for sustained speech (potential conversation)\n        const recentSpeech = this.environmentAnalysis.speechSegments\n            .filter(segment => now - segment.timestamp < 3000); // Last 3 seconds\n        \n        if (recentSpeech.length >= 8) { // 8 detections in 3 seconds = sustained speech\n            this.sustainedSpeechCount++;\n            \n            if (this.sustainedSpeechCount >= 3) { // 3 sustained periods = conversation\n                this.handleConversationDetection();\n            }\n            \n            console.log('[WARN] Sustained speech pattern detected');\n            this.recordViolation('sustained_speech', 'medium', \n                `Sustained speech detected (${recentSpeech.length} segments in 3s)`);\n        }\n        \n        // Log regular voice activity\n        if (this.voiceDetectionCount % 5 === 0) {\n            console.log(`?? Voice activity detected (${this.voiceDetectionCount} times)`);\n            this.recordViolation('voice_activity', 'low', \n                `Voice activity detected (count: ${this.voiceDetectionCount})`);\n        }\n    }\n\n    calculateSpeechConfidence(metrics) {\n        if (!this.baselineNoiseLevel) return 0;\n        \n        const baseline = this.baselineNoiseLevel;\n        \n        // Calculate confidence based on how much the signal deviates from baseline\n        const rmsScore = Math.min((metrics.rms / (baseline.avgRMS + baseline.variabilityRMS)) - 1, 1);\n        const centroidScore = Math.min((metrics.spectralCentroid / baseline.avgSpectralCentroid) - 1, 1);\n        const rolloffScore = Math.min((metrics.spectralRolloff / baseline.avgSpectralRolloff) - 1, 1);\n        \n        return (rmsScore + centroidScore + rolloffScore) / 3;\n    }\n\n    handleConversationDetection() {\n        if (this.conversationDetected) return; // Already detected\n        \n        this.conversationDetected = true;\n        this.environmentAnalysis.hasConversation = true;\n        this.environmentAnalysis.conversationStartTime = Date.now();\n        \n        console.error('? CONVERSATION DETECTED - Potential malpractice');\n        \n        // Record as critical violation for immediate malpractice handling\n        this.recordViolation('sustained_conversation', 'critical', \n            'Sustained conversation detected - multiple speech patterns identified');\n        \n        // Show immediate warning\n        this.showCriticalWarning('?? CONVERSATION DETECTED: Sustained speech patterns indicate possible conversation during the quiz');\n    }\n\n    resetSpeechDetection() {\n        // Reset speech detection if no activity for 2 seconds\n        const now = Date.now();\n        if (now - this.environmentAnalysis.lastVoiceActivity > 2000) {\n            this.sustainedSpeechCount = 0;\n        }\n    }\n\n    checkForConversation(currentMetrics) {\n        // Additional conversation detection logic\n        const recentSegments = this.environmentAnalysis.speechSegments\n            .filter(segment => Date.now() - segment.timestamp < 5000);\n        \n        if (recentSegments.length >= 15) { // Many speech segments in 5 seconds\n            const avgConfidence = recentSegments.reduce((sum, seg) => sum + seg.confidence, 0) / recentSegments.length;\n            \n            if (avgConfidence > 0.6) { // High confidence speech\n                this.handleConversationDetection();\n            }\n        }\n    }\n\n    updateEnvironmentAnalysis(currentMetrics) {\n        // Update noise level history\n        this.environmentAnalysis.noiseLevelHistory.push({\n            level: currentMetrics.rms,\n            timestamp: Date.now()\n        });\n        \n        // Keep only recent history (last 30 seconds)\n        this.environmentAnalysis.noiseLevelHistory = this.environmentAnalysis.noiseLevelHistory\n            .filter(entry => Date.now() - entry.timestamp < 30000);\n        \n        // Update quiet status\n        const recentLevels = this.environmentAnalysis.noiseLevelHistory.slice(-10);\n        const avgRecentLevel = recentLevels.reduce((sum, entry) => sum + entry.level, 0) / recentLevels.length;\n        \n        this.environmentAnalysis.isQuiet = avgRecentLevel <= (this.baselineNoiseLevel?.avgRMS * 1.5 || 20);\n    }\n\n    showAudioMonitoringIndicator() {\n        const indicator = document.createElement('div');\n        indicator.id = 'enhanced-audio-indicator';\n        indicator.style.cssText = `\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            width: 140px;\n            height: 50px;\n            background: rgba(40, 167, 69, 0.9);\n            color: white;\n            border-radius: 8px;\n            padding: 8px;\n            z-index: 1001;\n            font-size: 11px;\n            text-align: center;\n            border: 2px solid #28a745;\n        `;\n        \n        indicator.innerHTML = `\n            <div style=\"display: flex; align-items: center; justify-content: center; height: 100%;\">\n                <div>\n                    <div>? ENHANCED AUDIO</div>\n                    <div style=\"font-size: 9px; margin-top: 2px;\">Speech Detection Active</div>\n                </div>\n            </div>\n        `;\n        \n        document.body.appendChild(indicator);\n        \n        // Update indicator based on audio activity\n        setInterval(() => {\n            if (this.conversationDetected) {\n                indicator.style.background = 'rgba(220, 53, 69, 0.9)';\n                indicator.style.borderColor = '#dc3545';\n                indicator.innerHTML = `\n                    <div style=\"display: flex; align-items: center; justify-content: center; height: 100%;\">\n                        <div>\n                            <div>? CONVERSATION</div>\n                            <div style=\"font-size: 9px; margin-top: 2px;\">Multiple Voices</div>\n                        </div>\n                    </div>\n                `;\n            } else if (this.voiceDetectionCount > 0) {\n                indicator.style.background = 'rgba(255, 193, 7, 0.9)';\n                indicator.style.borderColor = '#ffc107';\n                indicator.innerHTML = `\n                    <div style=\"display: flex; align-items: center; justify-content: center; height: 100%;\">\n                        <div>\n                            <div>? VOICE DETECTED</div>\n                            <div style=\"font-size: 9px; margin-top: 2px;\">Count: ${this.voiceDetectionCount}</div>\n                        </div>\n                    </div>\n                `;\n            }\n        }, 1000);\n    }\n    \n    showNotification(message, type = 'info') {\n        console.log(`[${type.toUpperCase()}] ${message}`);\n        // You can implement toast notifications here\n    }\n    \n    showWarning(message) {\n        console.warn(message);\n        // You can implement warning modals here\n    }\n    \n    showCriticalWarning(message) {\n        console.error(message);\n        // REMOVED: No alert popups, only console logging\n        this.showSingleWarning(message);\n    }\n    \n    showCriticalError(message) {\n        console.error(message);\n        // REMOVED: No alert popups, only console logging\n        this.showSingleWarning(message);\n    }\n    \n    // ============== SMART SECURITY MONITORING ==============\n    \n    activateStrongEnforcement() {\n        console.log('[INFO] Activating smart security monitoring');\n        this.enforcementActive = true;\n        \n        try {\n            // Request fullscreen with graceful fallback\n            this.requestFullscreenGracefully();\n            \n            // Monitor tab switching and focus changes\n            this.monitorTabSwitching();\n            \n            // Detect screenshot attempts (what's detectable)\n            this.detectScreenshotAttempts();\n            \n            // Monitor window state changes\n            this.monitorWindowState();\n            \n            // Monitor system shortcuts\n            this.monitorSystemShortcuts();\n            \n            // Essential keyboard monitoring (not blocking normal use)\n            this.setupEssentialKeyboardMonitoring();\n            \n            // Smart focus monitoring\n            this.startSmartFocusMonitoring();\n            \n            console.log('[INFO] Smart security monitoring activated');\n        } catch (error) {\n            console.error('Security monitoring setup failed:', error);\n            this.handleSecuritySetupFailure(error);\n        }\n    }\n    \n    deactivateStrongEnforcement() {\n        if (!this.enforcementActive) return;\n        \n        console.log('[INFO] Deactivating security monitoring');\n        this.enforcementActive = false;\n        this.blockingActive = false;\n        \n        try {\n            // Remove event listeners with error handling\n            this.blockedEvents.forEach(({ element, event, handler }) => {\n                try {\n                    element.removeEventListener(event, handler);\n                } catch (error) {\n                    console.warn('Failed to remove event listener:', error);\n                }\n            });\n            this.blockedEvents = [];\n            \n            // Remove keyboard monitor\n            if (this.keyboardBlocker) {\n                try {\n                    document.removeEventListener('keydown', this.keyboardBlocker);\n                    this.keyboardBlocker = null;\n                } catch (error) {\n                    console.warn('Failed to remove keyboard monitor:', error);\n                }\n            }\n            \n            // Exit fullscreen gracefully\n            if (document.fullscreenElement) {\n                document.exitFullscreen().catch(error => {\n                    console.warn('Failed to exit fullscreen:', error);\n                });\n            }\n            \n            console.log('[INFO] Security monitoring deactivated');\n        } catch (error) {\n            console.error('Error during security monitoring deactivation:', error);\n        }\n    }\n    \n    requestFullscreenGracefully() {\n        // Request fullscreen with proper error handling\n        if (!document.fullscreenElement) {\n            document.documentElement.requestFullscreen().catch(err => {\n                console.warn('Fullscreen request failed:', err);\n                this.showSingleWarning('?? Fullscreen mode recommended for enhanced security');\n                // Don't record as violation - user may have legitimate reasons\n            });\n        }\n        \n        // Monitor fullscreen changes (detection only)\n        const fullscreenMonitor = () => {\n            if (this.enforcementActive && !document.fullscreenElement) {\n                console.log('[WARN] Fullscreen exited - monitoring only');\n                this.recordViolation('fullscreen_exited', 'medium', 'Exited fullscreen mode');\n                // Don't try to force back - just detect and record\n            }\n        };\n        \n        document.addEventListener('fullscreenchange', fullscreenMonitor);\n        this.blockedEvents.push({ element: document, event: 'fullscreenchange', handler: fullscreenMonitor });\n        \n        // Monitor escape key usage (for awareness, not blocking)\n        const escapeMonitor = (e) => {\n            if (e.key === 'Escape' && this.enforcementActive && document.fullscreenElement) {\n                // Just record the attempt, don't block it\n                this.recordViolation('escape_pressed', 'low', 'Escape key pressed in fullscreen mode');\n                console.log('[WARN] Escape key usage detected');\n            }\n        };\n        \n        document.addEventListener('keydown', escapeMonitor);\n        this.blockedEvents.push({ element: document, event: 'keydown', handler: escapeMonitor });\n    }\n    \n    monitorTabSwitching() {\n        // Monitor tab switching (detection, not blocking)\n        const tabSwitchMonitor = (e) => {\n            if (!this.enforcementActive) return;\n            \n            // Monitor certain key combinations (but don't block normal browser use)\n            if (e.altKey && e.key === 'Tab') {\n                this.tabSwitchCount++;\n                this.recordViolation('alt_tab_detected', 'medium', 'Alt+Tab key combination detected');\n                console.log('[WARN] Alt+Tab detected');\n                // Don't prevent - OS handles this, we just detect\n            }\n        };\n        \n        // Smart visibility change detection\n        const visibilityHandler = () => {\n            if (document.hidden && this.enforcementActive) {\n                this.tabSwitchCount++;\n                this.recordViolation('tab_switch_detected', 'high', `Tab/window switched away (${this.tabSwitchCount} times)`);\n                \n                // Show warning but don't try to force focus (can be annoying)\n                if (this.tabSwitchCount === 1) {\n                    this.showSingleWarning('?? Please stay focused on the quiz window');\n                } else if (this.tabSwitchCount === 5) {\n                    this.showSingleWarning('?? Multiple tab switches detected - please remain focused');\n                } else if (this.tabSwitchCount >= 10) {\n                    this.showCriticalWarning('?? Excessive tab switching detected - quiz integrity at risk');\n                }\n            }\n        };\n        \n        // Focus monitoring (less aggressive)\n        const focusHandler = () => {\n            if (this.enforcementActive) {\n                this.lastFocusTime = Date.now();\n                // Don't automatically try to regain focus - let user control their browser\n            }\n        };\n        \n        document.addEventListener('keydown', tabSwitchMonitor);\n        document.addEventListener('visibilitychange', visibilityHandler);\n        window.addEventListener('blur', focusHandler);\n        \n        this.blockedEvents.push(\n            { element: document, event: 'keydown', handler: tabSwitchMonitor },\n            { element: document, event: 'visibilitychange', handler: visibilityHandler },\n            { element: window, event: 'blur', handler: focusHandler }\n        );\n    }\n    \n    detectScreenshotAttempts() {\n        const screenshotDetector = (e) => {\n            if (!this.enforcementActive) return;\n            \n            // Detect screenshot-related key presses (what we can reasonably detect)\n            const suspiciousKeys = [\n                'PrintScreen',\n                'F12', // Dev tools (can interfere with screenshots)\n            ];\n            \n            // Detect some browser-level screenshot shortcuts\n            if (suspiciousKeys.includes(e.key) || \n                (e.ctrlKey && e.shiftKey && e.key === 'S')) { // Browser screenshot tools\n                \n                this.screenshotAttempts++;\n                \n                this.recordViolation('screenshot_attempt_detected', 'medium', `Screenshot key detected: ${e.key}`);\n                console.log('[WARN] Screenshot-related key detected:', e.key);\n                \n                if (this.screenshotAttempts === 1) {\n                    this.showSingleWarning('?? Screenshot attempts are monitored and logged');\n                } else if (this.screenshotAttempts >= 5) {\n                    this.showSingleWarning('?? Multiple screenshot attempts detected');\n                }\n                \n                // Note: We don't preventDefault() because browsers can't actually block OS-level screenshots\n                // We just detect and log for policy enforcement\n            }\n        };\n        \n        // Monitor right-click (but allow it - just log for awareness)\n        const contextMonitor = (e) => {\n            if (this.enforcementActive) {\n                this.recordViolation('right_click_detected', 'low', 'Right-click menu accessed');\n                console.log('[WARN] Right-click detected');\n                // Don't block - just monitor\n            }\n        };\n        \n        document.addEventListener('keydown', screenshotDetector);\n        document.addEventListener('contextmenu', contextMonitor);\n        \n        this.blockedEvents.push(\n            { element: document, event: 'keydown', handler: screenshotDetector },\n            { element: document, event: 'contextmenu', handler: contextMonitor }\n        );\n    }\n    \n    monitorWindowState() {\n        // Monitor window state changes (detection only)\n        const windowStateMonitor = () => {\n            if (this.enforcementActive) {\n                // Detect very small windows (might indicate minimization or hiding)\n                if (window.outerHeight <= 100 || window.outerWidth <= 100) {\n                    this.minimizeAttempts++;\n                    this.recordViolation('window_resized_small', 'medium', `Window resized very small (${this.minimizeAttempts} times)`);\n                    console.log('[WARN] Small window size detected');\n                }\n                \n                // Detect if window is hidden (visibility API)\n                if (document.visibilityState === 'hidden') {\n                    this.recordViolation('window_hidden', 'medium', 'Window became hidden');\n                    console.log('[WARN] Window hidden detected');\n                }\n            }\n        };\n        \n        // Monitor window state periodically\n        setInterval(windowStateMonitor, 1000); // Less frequent monitoring\n        \n        // Monitor minimize-related shortcuts (detect, not block)\n        const minimizeShortcutMonitor = (e) => {\n            if (!this.enforcementActive) return;\n            \n            // Monitor Windows+D (show desktop), Windows+M (minimize all)\n            if (e.metaKey && (e.key === 'd' || e.key === 'm')) {\n                this.recordViolation('minimize_shortcut_detected', 'low', `Minimize shortcut detected: ${this.getKeyCombo(e)}`);\n                console.log('[WARN] Minimize shortcut detected:', this.getKeyCombo(e));\n                // Don't block - just detect and log\n            }\n        };\n        \n        document.addEventListener('keydown', minimizeShortcutMonitor);\n        this.blockedEvents.push({ element: document, event: 'keydown', handler: minimizeShortcutMonitor });\n    }\n    \n    monitorSystemShortcuts() {\n        // Monitor system-level shortcuts (realistic detection)\n        const systemShortcutMonitor = (e) => {\n            if (!this.enforcementActive) return;\n            \n            // Monitor common system shortcuts (we can detect the key press, but can't block OS handling)\n            const systemShortcuts = [\n                { ctrl: true, shift: true, key: 'Escape' }, // Task Manager\n                { ctrl: true, alt: true, key: 'Delete' }, // Ctrl+Alt+Del\n                { meta: true, key: 'r' },         // Windows + R (Run)\n                { meta: true, key: 'l' },         // Windows + L (Lock)\n            ];\n            \n            for (const combo of systemShortcuts) {\n                if (this.matchesKeyCombo(e, combo)) {\n                    this.recordViolation('system_shortcut_detected', 'high', `System shortcut detected: ${this.getKeyCombo(e)}`);\n                    console.log('[WARN] System shortcut detected:', this.getKeyCombo(e));\n                    \n                    // Note: We can't actually block these at OS level, just detect and log\n                    this.showSingleWarning('?? System shortcut detected and logged');\n                }\n            }\n        };\n        \n        document.addEventListener('keydown', systemShortcutMonitor);\n        this.blockedEvents.push({ element: document, event: 'keydown', handler: systemShortcutMonitor });\n    }\n    \n    setupEssentialKeyboardMonitoring() {\n        this.keyboardBlocker = (e) => {\n            if (!this.enforcementActive) return;\n            \n            // Only block truly suspicious shortcuts that clearly indicate cheating attempts\n            const suspiciousShortcuts = [\n                // Developer tools (these can enable cheating)\n                { ctrl: true, shift: true, key: 'I' },\n                { ctrl: true, shift: true, key: 'J' },\n                { ctrl: true, shift: true, key: 'C' },\n                { ctrl: true, key: 'U' },\n                { key: 'F12' },\n                \n                // Navigation that clearly violates quiz rules\n                { ctrl: true, key: 'T' },         // New tab\n                { ctrl: true, key: 'N' },         // New window\n                { ctrl: true, key: 'W' },         // Close tab\n                { ctrl: true, shift: true, key: 'T' }, // Reopen tab\n                \n                // Print (to prevent printing questions)\n                { ctrl: true, key: 'P' },\n            ];\n            \n            // Monitor but don't block normal usage shortcuts\n            const monitoredShortcuts = [\n                { ctrl: true, key: 'A' },         // Select all\n                { ctrl: true, key: 'C' },         // Copy\n                { ctrl: true, key: 'V' },         // Paste\n                { ctrl: true, key: 'X' },         // Cut\n                { ctrl: true, key: 'S' },         // Save\n                { ctrl: true, key: 'R' },         // Refresh\n                { key: 'F5' },                    // Refresh\n            ];\n            \n            // Block only the truly suspicious ones\n            for (const combo of suspiciousShortcuts) {\n                if (this.matchesKeyCombo(e, combo)) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.recordViolation('suspicious_shortcut_blocked', 'high', `Blocked: ${this.getKeyCombo(e)}`);\n                    console.log('[WARN] Blocked suspicious shortcut:', this.getKeyCombo(e));\n                    return false;\n                }\n            }\n            \n            // Just monitor normal shortcuts (don't block them)\n            for (const combo of monitoredShortcuts) {\n                if (this.matchesKeyCombo(e, combo)) {\n                    this.recordViolation('shortcut_used', 'low', `Used: ${this.getKeyCombo(e)}`);\n                    console.log('[INFO] Monitored shortcut used:', this.getKeyCombo(e));\n                    // Don't prevent - just log for awareness\n                }\n            }\n        };\n        \n        document.addEventListener('keydown', this.keyboardBlocker);\n    }\n    \n    startSmartFocusMonitoring() {\n        // Smart focus monitoring (less aggressive)\n        setInterval(() => {\n            if (this.enforcementActive) {\n                const timeSinceLastFocus = Date.now() - this.lastFocusTime;\n                \n                // More reasonable focus loss detection\n                if (timeSinceLastFocus > 30000 && document.hidden) { // 30 seconds instead of 2\n                    this.recordViolation('extended_focus_loss', 'medium', 'Window out of focus for extended period');\n                    console.log('[WARN] Extended focus loss detected');\n                    \n                    // Don't automatically try to regain focus - let user control their browser\n                    \n                    // Show gentle reminder instead of aggressive warning\n                    if (timeSinceLastFocus > 60000) { // 1 minute\n                        this.showSingleWarning('?? Please return to the quiz window when ready');\n                    }\n                }\n            }\n        }, 5000); // Check every 5 seconds instead of every second\n        \n        // Update focus time on user interaction\n        const updateFocus = () => {\n            if (this.enforcementActive) {\n                this.lastFocusTime = Date.now();\n            }\n        };\n        \n        // Monitor focus-related events\n        ['focus', 'click', 'keydown'].forEach(event => {\n            document.addEventListener(event, updateFocus);\n            this.blockedEvents.push({ element: document, event, handler: updateFocus });\n        });\n        \n        // Monitor visibility changes\n        const visibilityFocusMonitor = () => {\n            if (this.enforcementActive && !document.hidden) {\n                this.lastFocusTime = Date.now(); // Reset timer when window becomes visible\n            }\n        };\n        \n        document.addEventListener('visibilitychange', visibilityFocusMonitor);\n        this.blockedEvents.push({ element: document, event: 'visibilitychange', handler: visibilityFocusMonitor });\n    }\n    \n    matchesKeyCombo(event, combo) {\n        return (\n            (combo.ctrl === undefined || event.ctrlKey === combo.ctrl) &&\n            (combo.alt === undefined || event.altKey === combo.alt) &&\n            (combo.shift === undefined || event.shiftKey === combo.shift) &&\n            (combo.meta === undefined || event.metaKey === combo.meta) &&\n            (combo.key === undefined || event.key.toLowerCase() === combo.key.toLowerCase())\n        );\n    }\n    \n    getKeyCombo(event) {\n        const parts = [];\n        if (event.ctrlKey) parts.push('Ctrl');\n        if (event.altKey) parts.push('Alt');\n        if (event.shiftKey) parts.push('Shift');\n        if (event.metaKey) parts.push('Meta');\n        if (event.key) parts.push(event.key);\n        return parts.join('+');\n    }\n    \n    handleSecuritySetupFailure(error) {\n        console.error('Security monitoring setup failed:', error);\n        \n        // Determine appropriate user feedback based on error type\n        let userMessage = '?? Some security monitoring features could not be enabled.';\n        \n        if (error.message && error.message.includes('fullscreen')) {\n            userMessage = '?? Fullscreen mode could not be activated. Please enable manually if needed.';\n        } else if (error.message && error.message.includes('permission')) {\n            userMessage = '?? Some monitoring features require additional permissions.';\n        } else if (error.message && error.message.includes('not supported')) {\n            userMessage = '?? Your browser has limited security monitoring support.';\n        }\n        \n        // Show user-friendly message\n        this.showSingleWarning(userMessage);\n        \n        // Record the failure for administrative review\n        this.recordViolation('security_setup_failed', 'medium', `Security setup error: ${error.message}`);\n        \n        // Continue with basic monitoring even if some features fail\n        console.log('Continuing with available security monitoring features...');\n    }\n}\n\n// Global instance\nwindow.EnhancedProctoringSystem = EnhancedProctoringSystem;","size_bytes":94561},"static/js/mobile-proctoring.js":{"content":"// Mobile Proctoring.js - Enhanced mobile-specific proctoring for secure quiz taking\n// Features: Camera enforcement, screenshot prevention, do-not-disturb mode, background app monitoring\n\nclass MobileProctoringManager {\n    constructor(attemptId, deviceType) {\n        this.attemptId = attemptId;\n        this.deviceType = deviceType; // 'mobile' or 'tablet'\n        this.isActive = false;\n        this.violations = [];\n        this.mediaStream = null;\n        this.videoElement = null;\n        this.canvas = null;\n        this.context = null;\n        this.detectionInterval = null;\n        \n        // Mobile-specific features\n        this.isScreenBlocked = false;\n        this.screenshotAttempts = 0;\n        this.backgroundDetectionCount = 0;\n        this.phoneCallDetected = false;\n        this.doNotDisturbActive = false;\n        this.visibilityChangeCount = 0;\n        this.lastVisibilityTime = null;\n        \n        // Configuration for mobile devices\n        this.config = {\n            // Core mobile proctoring features\n            enforceCamera: true,\n            blockScreenshots: true,\n            preventBackground: true,\n            detectPhoneCalls: true,\n            doNotDisturbMode: true,\n            fullscreenRequired: true,\n            orientationLock: true,\n            \n            // Detection thresholds\n            maxScreenshotAttempts: 3,\n            maxBackgroundSwitches: 5,\n            maxVisibilityChanges: 10,\n            \n            // Monitoring intervals\n            cameraCheckInterval: 5000,  // 5 seconds\n            backgroundCheckInterval: 2000,  // 2 seconds\n            phoneCallCheckInterval: 3000  // 3 seconds\n        };\n        \n        this.init();\n    }\n    \n    async init() {\n        console.log(`Initializing Mobile Proctoring for ${this.deviceType} device`);\n        \n        // Initialize mobile-specific proctoring features\n        await this.initializeMobileSecurityFeatures();\n        \n        // Start monitoring systems\n        if (this.config.enforceCamera) {\n            await this.initializeCamera();\n        }\n        \n        if (this.config.blockScreenshots) {\n            this.setupScreenshotPrevention();\n        }\n        \n        if (this.config.preventBackground) {\n            this.setupBackgroundAppMonitoring();\n        }\n        \n        if (this.config.detectPhoneCalls) {\n            this.setupPhoneCallDetection();\n        }\n        \n        if (this.config.doNotDisturbMode) {\n            this.activateDoNotDisturbMode();\n        }\n        \n        if (this.config.fullscreenRequired) {\n            this.enforceFullscreen();\n        }\n        \n        if (this.config.orientationLock) {\n            this.lockOrientation();\n        }\n        \n        this.startMonitoring();\n        \n        console.log('Mobile proctoring initialized successfully');\n    }\n    \n    async initializeMobileSecurityFeatures() {\n        // Create mobile-specific UI elements\n        this.createMobileSecurityOverlay();\n        \n        // Set up mobile-specific event listeners\n        this.setupMobileEventListeners();\n        \n        // Configure mobile browser settings\n        this.configureMobileBrowser();\n    }\n    \n    createMobileSecurityOverlay() {\n        // Create security overlay for mobile devices\n        const overlay = document.createElement('div');\n        overlay.id = 'mobile-security-overlay';\n        overlay.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.9);\n            z-index: 9999;\n            display: none;\n            color: white;\n            text-align: center;\n            padding: 20px;\n            box-sizing: border-box;\n        `;\n        \n        overlay.innerHTML = `\n            <div style=\"margin-top: 20%;\">\n                <i class=\"fas fa-shield-alt\" style=\"font-size: 4rem; color: #dc3545; margin-bottom: 20px;\"></i>\n                <h2>Security Violation Detected</h2>\n                <p id=\"violation-message\">Please return to the quiz immediately</p>\n                <button onclick=\"mobileProctoringManager.returnToQuiz()\" style=\"\n                    background: #007bff; \n                    color: white; \n                    border: none; \n                    padding: 15px 30px; \n                    font-size: 1.2rem; \n                    border-radius: 5px; \n                    cursor: pointer;\n                    margin-top: 20px;\n                \">Return to Quiz</button>\n            </div>\n        `;\n        \n        document.body.appendChild(overlay);\n        this.securityOverlay = overlay;\n    }\n    \n    setupMobileEventListeners() {\n        // Page visibility API for background app detection\n        document.addEventListener('visibilitychange', () => {\n            this.handleVisibilityChange();\n        });\n        \n        // Page focus/blur for additional security\n        window.addEventListener('focus', () => {\n            this.handleWindowFocus();\n        });\n        \n        window.addEventListener('blur', () => {\n            this.handleWindowBlur();\n        });\n        \n        // Screen orientation changes\n        if (screen.orientation) {\n            screen.orientation.addEventListener('change', () => {\n                this.handleOrientationChange();\n            });\n        }\n        \n        // Touch events for interaction monitoring\n        document.addEventListener('touchstart', (e) => {\n            this.handleTouchStart(e);\n        });\n        \n        // Prevent context menu (right-click equivalent on mobile)\n        document.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n            this.logViolation('context_menu_blocked', 'Context menu access blocked', 'medium');\n        });\n        \n        // Prevent text selection\n        document.addEventListener('selectstart', (e) => {\n            e.preventDefault();\n        });\n        \n        // Detect screenshot attempts (volume down + power button on many devices)\n        this.setupScreenshotDetection();\n    }\n    \n    configureMobileBrowser() {\n        // Prevent zoom\n        const viewport = document.querySelector('meta[name=\"viewport\"]');\n        if (viewport) {\n            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');\n        }\n        \n        // Disable text selection\n        document.body.style.webkitUserSelect = 'none';\n        document.body.style.mozUserSelect = 'none';\n        document.body.style.msUserSelect = 'none';\n        document.body.style.userSelect = 'none';\n        \n        // Disable drag\n        document.body.style.webkitUserDrag = 'none';\n        document.body.style.mozUserDrag = 'none';\n        document.body.style.userDrag = 'none';\n        \n        // Prevent copy/paste\n        document.addEventListener('copy', (e) => {\n            e.preventDefault();\n            this.logViolation('copy_attempt', 'Copy attempt blocked', 'medium');\n        });\n        \n        document.addEventListener('paste', (e) => {\n            e.preventDefault();\n            this.logViolation('paste_attempt', 'Paste attempt blocked', 'medium');\n        });\n    }\n    \n    async initializeCamera() {\n        try {\n            console.log('Requesting camera access for mobile proctoring...');\n            \n            this.mediaStream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    facingMode: 'user', // Front-facing camera\n                    width: { ideal: 640 },\n                    height: { ideal: 480 }\n                },\n                audio: false // No audio recording for mobile\n            });\n            \n            // Create video element for mobile\n            this.videoElement = document.createElement('video');\n            this.videoElement.srcObject = this.mediaStream;\n            this.videoElement.autoplay = true;\n            this.videoElement.muted = true;\n            this.videoElement.style.cssText = `\n                position: fixed;\n                top: 10px;\n                right: 10px;\n                width: 120px;\n                height: 90px;\n                border: 2px solid #007bff;\n                border-radius: 8px;\n                z-index: 1000;\n                background: black;\n            `;\n            \n            document.body.appendChild(this.videoElement);\n            \n            console.log('Mobile camera initialized successfully');\n            this.logViolation('camera_initialized', 'Mobile camera access granted', 'info');\n            \n        } catch (error) {\n            console.error('Failed to initialize camera:', error);\n            this.handleCameraError();\n        }\n    }\n    \n    handleCameraError() {\n        this.showSecurityOverlay('Camera access is required for this quiz. Please grant camera permission and refresh the page.');\n        this.logViolation('camera_access_denied', 'Camera access denied on mobile device', 'critical');\n    }\n    \n    setupScreenshotPrevention() {\n        // Multiple layers of screenshot prevention for mobile devices\n        \n        // Method 1: Detect keyboard shortcuts (though limited on mobile)\n        document.addEventListener('keydown', (e) => {\n            // Common screenshot key combinations\n            if ((e.ctrlKey || e.metaKey) && (e.key === 's' || e.key === 'p')) {\n                e.preventDefault();\n                this.handleScreenshotAttempt();\n            }\n        });\n        \n        // Method 2: Detect volume button combinations (Android)\n        let volumeDownPressed = false;\n        let powerButtonPressed = false;\n        \n        // This is limited due to browser security, but we try to detect patterns\n        document.addEventListener('keydown', (e) => {\n            if (e.code === 'VolumeDown') {\n                volumeDownPressed = true;\n                setTimeout(() => { volumeDownPressed = false; }, 500);\n            }\n        });\n        \n        // Method 3: Page visibility changes that might indicate screenshot apps\n        this.setupVisibilityScreenshotDetection();\n        \n        // Method 4: Disable print screen and similar\n        document.addEventListener('keyup', (e) => {\n            if (e.keyCode === 44) { // Print Screen key\n                this.handleScreenshotAttempt();\n            }\n        });\n    }\n    \n    setupVisibilityScreenshotDetection() {\n        let rapidVisibilityChanges = 0;\n        let lastVisibilityChange = Date.now();\n        \n        document.addEventListener('visibilitychange', () => {\n            const now = Date.now();\n            if (now - lastVisibilityChange < 1000) { // Less than 1 second\n                rapidVisibilityChanges++;\n                if (rapidVisibilityChanges > 3) {\n                    this.handleScreenshotAttempt();\n                    rapidVisibilityChanges = 0;\n                }\n            } else {\n                rapidVisibilityChanges = 0;\n            }\n            lastVisibilityChange = now;\n        });\n    }\n    \n    handleScreenshotAttempt() {\n        this.screenshotAttempts++;\n        console.warn(`Screenshot attempt detected (${this.screenshotAttempts})`);\n        \n        this.logViolation('screenshot_attempt', `Screenshot attempt detected on ${this.deviceType} device (attempt ${this.screenshotAttempts})`, 'high');\n        \n        if (this.screenshotAttempts >= this.config.maxScreenshotAttempts) {\n            this.terminateQuizForViolation('Multiple screenshot attempts detected');\n        } else {\n            this.showWarning(`Screenshot attempt detected! ${this.config.maxScreenshotAttempts - this.screenshotAttempts} attempts remaining before quiz termination.`);\n        }\n    }\n    \n    setupBackgroundAppMonitoring() {\n        // Monitor for background apps and multitasking\n        setInterval(() => {\n            this.checkBackgroundApps();\n        }, this.config.backgroundCheckInterval);\n    }\n    \n    checkBackgroundApps() {\n        // Check if the page is in background\n        if (document.hidden) {\n            this.backgroundDetectionCount++;\n            \n            if (this.backgroundDetectionCount === 1) {\n                this.showSecurityOverlay('Please return to the quiz. Background apps are not allowed during the exam.');\n            }\n            \n            this.logViolation('background_app_detected', \n                `Page moved to background on ${this.deviceType} device (count: ${this.backgroundDetectionCount})`, \n                'high');\n            \n            if (this.backgroundDetectionCount >= this.config.maxBackgroundSwitches) {\n                this.terminateQuizForViolation('Too many background app switches detected');\n            }\n        } else if (this.backgroundDetectionCount > 0 && !document.hidden) {\n            // User returned to the quiz\n            this.hideSecurityOverlay();\n        }\n    }\n    \n    setupPhoneCallDetection() {\n        // Detect phone calls and other interruptions\n        setInterval(() => {\n            this.checkForPhoneCalls();\n        }, this.config.phoneCallCheckInterval);\n    }\n    \n    checkForPhoneCalls() {\n        // Check if audio context is suspended (might indicate phone call)\n        if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {\n            const AudioContextClass = window.AudioContext || window.webkitAudioContext;\n            \n            if (!this.audioContext) {\n                this.audioContext = new AudioContextClass();\n            }\n            \n            if (this.audioContext.state === 'suspended') {\n                if (!this.phoneCallDetected) {\n                    this.phoneCallDetected = true;\n                    this.handlePhoneCallDetected();\n                }\n            } else {\n                if (this.phoneCallDetected) {\n                    this.phoneCallDetected = false;\n                    this.handlePhoneCallEnded();\n                }\n            }\n        }\n        \n        // Additional method: Check for connection type changes\n        if (navigator.connection) {\n            if (navigator.connection.type === 'cellular' && this.lastConnectionType !== 'cellular') {\n                this.logViolation('connection_change', 'Connection changed to cellular during quiz', 'medium');\n            }\n            this.lastConnectionType = navigator.connection.type;\n        }\n    }\n    \n    handlePhoneCallDetected() {\n        console.warn('Phone call detected during quiz');\n        this.showSecurityOverlay('Phone call detected. Please end the call and return to the quiz.');\n        this.logViolation('phone_call_detected', 'Phone call detected during quiz on mobile device', 'critical');\n    }\n    \n    handlePhoneCallEnded() {\n        console.log('Phone call ended, returning to quiz');\n        this.hideSecurityOverlay();\n        this.logViolation('phone_call_ended', 'Phone call ended, user returned to quiz', 'info');\n    }\n    \n    activateDoNotDisturbMode() {\n        // Request notification permissions to prevent interruptions\n        if ('Notification' in window && Notification.permission === 'default') {\n            Notification.requestPermission();\n        }\n        \n        // Try to prevent wake lock interruptions\n        if ('wakeLock' in navigator) {\n            this.requestWakeLock();\n        }\n        \n        // Hide system UI on supported browsers\n        this.hideSystemUI();\n        \n        this.doNotDisturbActive = true;\n        this.logViolation('do_not_disturb_activated', 'Do not disturb mode activated for mobile quiz', 'info');\n    }\n    \n    async requestWakeLock() {\n        try {\n            this.wakeLock = await navigator.wakeLock.request('screen');\n            console.log('Wake lock acquired');\n        } catch (err) {\n            console.warn('Could not acquire wake lock:', err);\n        }\n    }\n    \n    hideSystemUI() {\n        // Request fullscreen with system UI hidden\n        if (document.documentElement.requestFullscreen) {\n            document.documentElement.requestFullscreen({ navigationUI: 'hide' });\n        }\n    }\n    \n    enforceFullscreen() {\n        // Force fullscreen mode for mobile devices\n        if (!document.fullscreenElement) {\n            this.enterFullscreen();\n        }\n        \n        // Monitor fullscreen changes\n        document.addEventListener('fullscreenchange', () => {\n            if (!document.fullscreenElement) {\n                this.handleFullscreenExit();\n            }\n        });\n    }\n    \n    enterFullscreen() {\n        const element = document.documentElement;\n        if (element.requestFullscreen) {\n            element.requestFullscreen();\n        } else if (element.mozRequestFullScreen) {\n            element.mozRequestFullScreen();\n        } else if (element.webkitRequestFullscreen) {\n            element.webkitRequestFullscreen();\n        } else if (element.msRequestFullscreen) {\n            element.msRequestFullscreen();\n        }\n    }\n    \n    handleFullscreenExit() {\n        console.warn('Fullscreen mode exited');\n        this.showWarning('Please return to fullscreen mode');\n        this.logViolation('fullscreen_exit', 'User exited fullscreen mode on mobile device', 'high');\n        \n        // Try to re-enter fullscreen after a short delay\n        setTimeout(() => {\n            this.enterFullscreen();\n        }, 2000);\n    }\n    \n    lockOrientation() {\n        // Lock orientation to portrait or landscape as appropriate\n        if (screen.orientation && screen.orientation.lock) {\n            const orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';\n            screen.orientation.lock(orientation).catch(err => {\n                console.warn('Could not lock orientation:', err);\n            });\n        }\n    }\n    \n    handleOrientationChange() {\n        this.logViolation('orientation_change', 'Device orientation changed during quiz', 'medium');\n        \n        // Warn user about orientation changes\n        this.showWarning('Please maintain consistent device orientation during the quiz');\n    }\n    \n    handleVisibilityChange() {\n        if (document.hidden) {\n            this.visibilityChangeCount++;\n            this.lastVisibilityTime = Date.now();\n            \n            this.logViolation('visibility_hidden', \n                `Quiz hidden on ${this.deviceType} device (count: ${this.visibilityChangeCount})`, \n                'medium');\n            \n            if (this.visibilityChangeCount >= this.config.maxVisibilityChanges) {\n                this.terminateQuizForViolation('Too many app switches detected');\n            }\n        } else {\n            // User returned to quiz\n            if (this.lastVisibilityTime) {\n                const hiddenDuration = Date.now() - this.lastVisibilityTime;\n                this.logViolation('visibility_restored', \n                    `Quiz restored after ${hiddenDuration}ms on ${this.deviceType} device`, \n                    'info');\n            }\n        }\n    }\n    \n    handleWindowFocus() {\n        // Quiz regained focus\n        this.hideSecurityOverlay();\n    }\n    \n    handleWindowBlur() {\n        // Quiz lost focus\n        this.showWarning('Please keep the quiz in focus');\n    }\n    \n    handleTouchStart(e) {\n        // Monitor touch patterns for suspicious behavior\n        if (e.touches.length > 2) {\n            this.logViolation('multi_touch', 'Multiple touch points detected', 'low');\n        }\n    }\n    \n    setupScreenshotDetection() {\n        // Advanced screenshot detection methods for mobile\n        \n        // Method 1: Monitor for rapid screen captures via media queries\n        if (window.matchMedia) {\n            const mediaQuery = window.matchMedia('(orientation: portrait)');\n            mediaQuery.addListener(() => {\n                // Rapid orientation changes might indicate screenshot tools\n                this.checkForRapidScreenChanges();\n            });\n        }\n        \n        // Method 2: Monitor for specific key combinations\n        document.addEventListener('keydown', (e) => {\n            // iOS screenshot: Power + Home or Power + Volume Up\n            // Android screenshot: Power + Volume Down\n            if (e.key === 'PrintScreen' || \n                (e.key === 'Power' && (e.key === 'VolumeDown' || e.key === 'Home'))) {\n                this.handleScreenshotAttempt();\n            }\n        });\n    }\n    \n    checkForRapidScreenChanges() {\n        // Implementation for detecting rapid screen changes\n        const now = Date.now();\n        if (this.lastScreenChange && (now - this.lastScreenChange) < 500) {\n            this.handleScreenshotAttempt();\n        }\n        this.lastScreenChange = now;\n    }\n    \n    startMonitoring() {\n        // Start all monitoring systems\n        this.detectionInterval = setInterval(() => {\n            this.performSecurityChecks();\n        }, 5000); // Check every 5 seconds\n        \n        this.isActive = true;\n        console.log('Mobile proctoring monitoring started');\n    }\n    \n    performSecurityChecks() {\n        // Perform comprehensive security checks\n        this.checkCameraStatus();\n        this.checkConnectionStatus();\n        this.checkDeviceStatus();\n    }\n    \n    checkCameraStatus() {\n        if (this.mediaStream && this.config.enforceCamera) {\n            const videoTrack = this.mediaStream.getVideoTracks()[0];\n            if (!videoTrack || !videoTrack.enabled) {\n                this.handleCameraDisabled();\n            }\n        }\n    }\n    \n    handleCameraDisabled() {\n        console.warn('Camera disabled during quiz');\n        this.showSecurityOverlay('Camera must remain enabled during the quiz');\n        this.logViolation('camera_disabled', 'Camera disabled during mobile quiz', 'critical');\n    }\n    \n    checkConnectionStatus() {\n        if (!navigator.onLine) {\n            this.handleConnectionLost();\n        }\n    }\n    \n    handleConnectionLost() {\n        this.showSecurityOverlay('Internet connection lost. Please restore connection to continue.');\n        this.logViolation('connection_lost', 'Internet connection lost during quiz', 'high');\n    }\n    \n    checkDeviceStatus() {\n        // Check battery level if available\n        if (navigator.getBattery) {\n            navigator.getBattery().then(battery => {\n                if (battery.level < 0.1) { // Less than 10%\n                    this.showWarning('Low battery detected. Please charge your device.');\n                    this.logViolation('low_battery', `Low battery level: ${Math.round(battery.level * 100)}%`, 'medium');\n                }\n            });\n        }\n    }\n    \n    showSecurityOverlay(message) {\n        if (this.securityOverlay) {\n            const messageElement = this.securityOverlay.querySelector('#violation-message');\n            if (messageElement) {\n                messageElement.textContent = message;\n            }\n            this.securityOverlay.style.display = 'block';\n            this.isScreenBlocked = true;\n        }\n    }\n    \n    hideSecurityOverlay() {\n        if (this.securityOverlay) {\n            this.securityOverlay.style.display = 'none';\n            this.isScreenBlocked = false;\n        }\n    }\n    \n    returnToQuiz() {\n        this.hideSecurityOverlay();\n        this.enterFullscreen();\n        \n        // Reset some counters with a warning\n        if (this.backgroundDetectionCount > 0) {\n            this.backgroundDetectionCount = Math.max(0, this.backgroundDetectionCount - 1);\n        }\n    }\n    \n    showWarning(message) {\n        // Show temporary warning message\n        const warning = document.createElement('div');\n        warning.style.cssText = `\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: #ff6b6b;\n            color: white;\n            padding: 20px;\n            border-radius: 10px;\n            z-index: 9998;\n            text-align: center;\n            box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n        `;\n        warning.innerHTML = `\n            <i class=\"fas fa-exclamation-triangle\" style=\"margin-right: 10px;\"></i>\n            ${message}\n        `;\n        \n        document.body.appendChild(warning);\n        \n        setTimeout(() => {\n            if (warning.parentNode) {\n                warning.parentNode.removeChild(warning);\n            }\n        }, 5000);\n    }\n    \n    logViolation(type, message, severity = 'medium') {\n        const violation = {\n            type,\n            message,\n            severity,\n            timestamp: new Date().toISOString(),\n            deviceType: this.deviceType,\n            userAgent: navigator.userAgent\n        };\n        \n        this.violations.push(violation);\n        console.log(`Mobile Proctoring Violation [${severity}]:`, violation);\n        \n        // Send to server\n        this.sendViolationToServer(violation);\n    }\n    \n    sendViolationToServer(violation) {\n        fetch('/api/log_violation', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                attempt_id: this.attemptId,\n                ...violation\n            })\n        }).catch(err => {\n            console.error('Failed to send violation to server:', err);\n        });\n    }\n    \n    terminateQuizForViolation(reason) {\n        console.error('Terminating quiz due to violation:', reason);\n        \n        this.showSecurityOverlay(`Quiz terminated due to security violations: ${reason}`);\n        \n        this.logViolation('quiz_terminated', `Quiz terminated: ${reason}`, 'critical');\n        \n        // Disable all form inputs\n        const inputs = document.querySelectorAll('input, textarea, select, button');\n        inputs.forEach(input => {\n            input.disabled = true;\n        });\n        \n        // Auto-submit the quiz\n        setTimeout(() => {\n            if (typeof quizManager !== 'undefined' && quizManager.autoSubmitQuiz) {\n                quizManager.autoSubmitQuiz();\n            }\n        }, 5000);\n    }\n    \n    cleanup() {\n        // Clean up all resources\n        if (this.detectionInterval) {\n            clearInterval(this.detectionInterval);\n        }\n        \n        if (this.mediaStream) {\n            this.mediaStream.getTracks().forEach(track => track.stop());\n        }\n        \n        if (this.videoElement && this.videoElement.parentNode) {\n            this.videoElement.parentNode.removeChild(this.videoElement);\n        }\n        \n        if (this.securityOverlay && this.securityOverlay.parentNode) {\n            this.securityOverlay.parentNode.removeChild(this.securityOverlay);\n        }\n        \n        if (this.wakeLock) {\n            this.wakeLock.release();\n        }\n        \n        this.isActive = false;\n        console.log('Mobile proctoring cleanup completed');\n    }\n}\n\n// Global instance\nlet mobileProctoringManager;\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function() {\n    // This will be initialized from the template with device type\n    console.log('Mobile proctoring script loaded');\n});","size_bytes":27142},"collaboration_detection.py":{"content":"\"\"\"\nReal-time collaboration detection service for quiz proctoring.\nDetects suspicious patterns indicating possible collaboration between participants.\n\"\"\"\n\nimport json\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Tuple, Optional, Set\nfrom collections import defaultdict\nimport math\n\nfrom app import db, redis_client, socketio\nfrom models import (\n    CollaborationSignal, AttemptSimilarity, QuizAttempt, \n    Answer, User, DeviceLog, SecurityAlert\n)\n\n\nclass CollaborationDetector:\n    \"\"\"Main collaboration detection engine.\"\"\"\n    \n    def __init__(self):\n        self.answer_cache = {}  # In-memory fallback if Redis unavailable\n        self.timing_cache = {}\n        self.ip_cache = {}\n        \n        # Detection thresholds\n        self.SIMILARITY_THRESHOLD = 0.8\n        self.SIMULTANEOUS_THRESHOLD = 3  # seconds\n        self.TIMING_CORRELATION_THRESHOLD = 0.9\n        self.MIN_QUESTIONS_FOR_DETECTION = 3\n        \n    def get_cache_key(self, quiz_id: int, cache_type: str) -> str:\n        \"\"\"Generate Redis cache key.\"\"\"\n        return f\"collab:{cache_type}:{quiz_id}\"\n    \n    def cache_get(self, key: str) -> Optional[str]:\n        \"\"\"Get from Redis or fallback cache.\"\"\"\n        if redis_client:\n            try:\n                return redis_client.get(key)\n            except:\n                pass\n        return self.answer_cache.get(key)\n    \n    def cache_set(self, key: str, value: str, expire: int = 3600):\n        \"\"\"Set in Redis or fallback cache.\"\"\"\n        if redis_client:\n            try:\n                redis_client.setex(key, expire, value)\n                return\n            except:\n                pass\n        self.answer_cache[key] = value\n    \n    def cache_hget(self, key: str, field: str) -> Optional[str]:\n        \"\"\"Get hash field from Redis or fallback.\"\"\"\n        if redis_client:\n            try:\n                return redis_client.hget(key, field)\n            except:\n                pass\n        cache_dict = self.answer_cache.get(key, {})\n        return cache_dict.get(field) if isinstance(cache_dict, dict) else None\n    \n    def cache_hset(self, key: str, field: str, value: str):\n        \"\"\"Set hash field in Redis or fallback.\"\"\"\n        if redis_client:\n            try:\n                redis_client.hset(key, field, value)\n                return\n            except:\n                pass\n        if key not in self.answer_cache:\n            self.answer_cache[key] = {}\n        if isinstance(self.answer_cache[key], dict):\n            self.answer_cache[key][field] = value\n    \n    def detect_answer_similarity(self, quiz_id: int, new_answer) -> List[CollaborationSignal]:\n        \"\"\"Detect similar answer patterns between participants.\"\"\"\n        signals = []\n        \n        try:\n            # Get recent answers for this quiz\n            recent_answers = Answer.query.filter(\n                Answer.quiz_id == quiz_id,\n                Answer.created_at >= datetime.utcnow() - timedelta(hours=2)\n            ).all()\n            \n            # Group answers by question and participant\n            answers_by_question = defaultdict(list)\n            for answer in recent_answers:\n                answers_by_question[answer.question_id].append(answer)\n            \n            # Calculate similarity for participants who answered the same question\n            question_answers = answers_by_question.get(new_answer.question_id, [])\n            \n            for other_answer in question_answers:\n                if (other_answer.attempt_id != new_answer.attempt_id and \n                    other_answer.id != new_answer.id):\n                    \n                    similarity_score = self.calculate_answer_similarity(\n                        new_answer, other_answer\n                    )\n                    \n                    if similarity_score >= self.SIMILARITY_THRESHOLD:\n                        # Check if these participants have multiple similar answers\n                        total_similarity = self.get_total_similarity_score(\n                            new_answer.attempt_id, other_answer.attempt_id, quiz_id\n                        )\n                        \n                        if total_similarity >= self.SIMILARITY_THRESHOLD:\n                            signal = self.create_collaboration_signal(\n                                quiz_id=quiz_id,\n                                signal_type='answer_similarity',\n                                score=total_similarity,\n                                severity=self.get_severity_from_score(total_similarity),\n                                participants=[\n                                    self.get_user_id_from_attempt(new_answer.attempt_id),\n                                    self.get_user_id_from_attempt(other_answer.attempt_id)\n                                ],\n                                details={\n                                    'question_id': new_answer.question_id,\n                                    'similarity_score': similarity_score,\n                                    'total_questions_compared': self.get_question_count(quiz_id),\n                                    'similar_answers_count': self.count_similar_answers(\n                                        new_answer.attempt_id, other_answer.attempt_id\n                                    )\n                                }\n                            )\n                            signals.append(signal)\n            \n        except Exception as e:\n            print(f\"Error in answer similarity detection: {e}\")\n        \n        return signals\n    \n    def detect_simultaneous_answers(self, quiz_id: int, new_answer) -> List[CollaborationSignal]:\n        \"\"\"Detect participants answering questions simultaneously.\"\"\"\n        signals = []\n        \n        try:\n            # Get recent answers within time threshold\n            time_window = datetime.utcnow() - timedelta(seconds=self.SIMULTANEOUS_THRESHOLD)\n            simultaneous_answers = Answer.query.filter(\n                Answer.quiz_id == quiz_id,\n                Answer.question_id == new_answer.question_id,\n                Answer.created_at >= time_window,\n                Answer.attempt_id != new_answer.attempt_id\n            ).all()\n            \n            if simultaneous_answers:\n                participant_ids = [self.get_user_id_from_attempt(new_answer.attempt_id)]\n                participant_ids.extend([\n                    self.get_user_id_from_attempt(ans.attempt_id) \n                    for ans in simultaneous_answers\n                ])\n                \n                # Remove duplicates\n                participant_ids = list(set(participant_ids))\n                \n                if len(participant_ids) >= 2:\n                    # Check if this is a pattern (multiple simultaneous answers)\n                    pattern_score = self.check_simultaneous_pattern(\n                        quiz_id, participant_ids\n                    )\n                    \n                    signal = self.create_collaboration_signal(\n                        quiz_id=quiz_id,\n                        signal_type='simultaneous_answers',\n                        score=pattern_score,\n                        severity=self.get_severity_from_score(pattern_score),\n                        participants=participant_ids,\n                        details={\n                            'question_id': new_answer.question_id,\n                            'time_difference_seconds': self.SIMULTANEOUS_THRESHOLD,\n                            'participants_count': len(participant_ids),\n                            'answer_times': [ans.created_at.isoformat() for ans in simultaneous_answers] + [new_answer.created_at.isoformat()]\n                        }\n                    )\n                    signals.append(signal)\n        \n        except Exception as e:\n            print(f\"Error in simultaneous answer detection: {e}\")\n        \n        return signals\n    \n    def detect_timing_correlation(self, quiz_id: int, new_answer) -> List[CollaborationSignal]:\n        \"\"\"Detect correlated timing patterns between participants.\"\"\"\n        signals = []\n        \n        try:\n            # Get timing data for active attempts\n            cache_key = self.get_cache_key(quiz_id, \"timing\")\n            attempt_id = new_answer.attempt_id\n            \n            # Store timing for this answer\n            timing_data = {\n                'timestamp': new_answer.created_at.timestamp(),\n                'question_id': new_answer.question_id,\n                'user_id': self.get_user_id_from_attempt(attempt_id)\n            }\n            \n            self.cache_hset(cache_key, str(attempt_id), json.dumps(timing_data))\n            \n            # Get all timing data for correlation analysis\n            all_timings = self.get_all_attempt_timings(quiz_id)\n            \n            # Calculate correlations between attempts\n            correlations = self.calculate_timing_correlations(all_timings, attempt_id)\n            \n            for other_attempt_id, correlation in correlations.items():\n                if correlation >= self.TIMING_CORRELATION_THRESHOLD:\n                    signal = self.create_collaboration_signal(\n                        quiz_id=quiz_id,\n                        signal_type='timing_correlation',\n                        score=correlation,\n                        severity=self.get_severity_from_score(correlation),\n                        participants=[\n                            self.get_user_id_from_attempt(attempt_id),\n                            self.get_user_id_from_attempt(other_attempt_id)\n                        ],\n                        details={\n                            'correlation_coefficient': correlation,\n                            'questions_analyzed': len(all_timings.get(attempt_id, [])),\n                            'time_window_hours': 2\n                        }\n                    )\n                    signals.append(signal)\n        \n        except Exception as e:\n            print(f\"Error in timing correlation detection: {e}\")\n        \n        return signals\n    \n    def detect_shared_ip(self, quiz_id: int, user_id: int) -> List[CollaborationSignal]:\n        \"\"\"Detect participants using same IP address.\"\"\"\n        signals = []\n        \n        try:\n            # Get recent device logs for this quiz\n            recent_logs = DeviceLog.query.filter(\n                DeviceLog.quiz_id == quiz_id,\n                DeviceLog.logged_in_at >= datetime.utcnow() - timedelta(hours=2)\n            ).all()\n            \n            # Group by IP address\n            ip_groups = defaultdict(list)\n            for log in recent_logs:\n                if log.ip_address:\n                    ip_groups[log.ip_address].append(log)\n            \n            # Check for multiple users on same IP\n            for ip_address, logs in ip_groups.items():\n                user_ids = list(set([log.user_id for log in logs]))\n                \n                if len(user_ids) >= 2 and user_id in user_ids:\n                    # Calculate suspicion score based on timing and behavior\n                    suspicion_score = self.calculate_ip_suspicion_score(logs)\n                    \n                    if suspicion_score >= 0.5:  # Lower threshold for IP sharing\n                        signal = self.create_collaboration_signal(\n                            quiz_id=quiz_id,\n                            signal_type='shared_ip',\n                            score=suspicion_score,\n                            severity=self.get_severity_from_score(suspicion_score),\n                            participants=user_ids,\n                            details={\n                                'ip_address': ip_address[:8] + \"***\",  # Anonymized\n                                'concurrent_users': len(user_ids),\n                                'time_overlap_minutes': self.calculate_time_overlap(logs)\n                            }\n                        )\n                        signals.append(signal)\n        \n        except Exception as e:\n            print(f\"Error in shared IP detection: {e}\")\n        \n        return signals\n    \n    def process_new_answer(self, answer) -> List[CollaborationSignal]:\n        \"\"\"Main entry point for processing new answers.\"\"\"\n        all_signals = []\n        \n        # Run all detection algorithms\n        all_signals.extend(self.detect_answer_similarity(answer.quiz_id, answer))\n        all_signals.extend(self.detect_simultaneous_answers(answer.quiz_id, answer))\n        all_signals.extend(self.detect_timing_correlation(answer.quiz_id, answer))\n        \n        # Also check for shared IP when user submits answer\n        user_id = self.get_user_id_from_attempt(answer.attempt_id)\n        all_signals.extend(self.detect_shared_ip(answer.quiz_id, user_id))\n        \n        # Save signals to database and emit real-time updates\n        for signal in all_signals:\n            db.session.add(signal)\n            db.session.commit()\n            \n            # Emit real-time update to proctors\n            self.emit_collaboration_update(signal)\n        \n        return all_signals\n    \n    def create_collaboration_signal(self, quiz_id: int, signal_type: str, score: float, \n                                  severity: str, participants: List[int], details: dict) -> CollaborationSignal:\n        \"\"\"Create a new collaboration signal.\"\"\"\n        return CollaborationSignal(\n            quiz_id=quiz_id,\n            signal_type=signal_type,\n            score=score,\n            severity=severity,\n            participants=participants,\n            window_start=datetime.utcnow() - timedelta(minutes=5),\n            window_end=datetime.utcnow(),\n            details=details\n        )\n    \n    def emit_collaboration_update(self, signal: CollaborationSignal):\n        \"\"\"Emit real-time update to proctor dashboard.\"\"\"\n        try:\n            room = f\"quiz:{signal.quiz_id}\"\n            update_data = {\n                'signal_id': signal.id,\n                'type': signal.signal_type,\n                'severity': signal.severity,\n                'score': signal.score,\n                'participants': signal.participants,\n                'created_at': signal.created_at.isoformat(),\n                'details': signal.details\n            }\n            \n            socketio.emit('collaboration_signal', update_data, room=room, namespace='/collab')\n            \n        except Exception as e:\n            print(f\"Error emitting collaboration update: {e}\")\n    \n    # Helper methods\n    \n    def calculate_answer_similarity(self, answer1, answer2) -> float:\n        \"\"\"Calculate similarity score between two answers.\"\"\"\n        if not answer1.selected_option_id or not answer2.selected_option_id:\n            return 0.0\n        \n        # For multiple choice - exact match gives high score\n        if answer1.selected_option_id == answer2.selected_option_id:\n            return 1.0\n        \n        # For text answers, calculate text similarity\n        if answer1.text_answer and answer2.text_answer:\n            return self.calculate_text_similarity(answer1.text_answer, answer2.text_answer)\n        \n        return 0.0\n    \n    def calculate_text_similarity(self, text1: str, text2: str) -> float:\n        \"\"\"Calculate text similarity using simple metrics.\"\"\"\n        if not text1 or not text2:\n            return 0.0\n        \n        # Simple Jaccard similarity for text\n        words1 = set(text1.lower().split())\n        words2 = set(text2.lower().split())\n        \n        if not words1 and not words2:\n            return 1.0\n        \n        intersection = len(words1.intersection(words2))\n        union = len(words1.union(words2))\n        \n        return intersection / union if union > 0 else 0.0\n    \n    def get_severity_from_score(self, score: float) -> str:\n        \"\"\"Convert score to severity level.\"\"\"\n        if score >= 0.9:\n            return 'high'\n        elif score >= 0.7:\n            return 'warn'\n        else:\n            return 'info'\n    \n    def get_user_id_from_attempt(self, attempt_id: int) -> int:\n        \"\"\"Get user ID from attempt ID.\"\"\"\n        attempt = QuizAttempt.query.get(attempt_id)\n        return attempt.participant_id if attempt else 0\n    \n    def get_total_similarity_score(self, attempt1_id: int, attempt2_id: int, quiz_id: int) -> float:\n        \"\"\"Calculate total similarity score between two attempts.\"\"\"\n        # Check if similarity record exists\n        similarity_record = AttemptSimilarity.query.filter_by(\n            quiz_id=quiz_id,\n            attempt_a_id=min(attempt1_id, attempt2_id),\n            attempt_b_id=max(attempt1_id, attempt2_id)\n        ).first()\n        \n        if similarity_record:\n            return similarity_record.jaccard_score\n        \n        # Calculate similarity from scratch\n        answers1 = Answer.query.filter_by(attempt_id=attempt1_id).all()\n        answers2 = Answer.query.filter_by(attempt_id=attempt2_id).all()\n        \n        # Group by question\n        q1_answers = {a.question_id: a for a in answers1}\n        q2_answers = {a.question_id: a for a in answers2}\n        \n        common_questions = set(q1_answers.keys()) & set(q2_answers.keys())\n        \n        if len(common_questions) < self.MIN_QUESTIONS_FOR_DETECTION:\n            return 0.0\n        \n        similar_count = 0\n        for question_id in common_questions:\n            if self.calculate_answer_similarity(q1_answers[question_id], q2_answers[question_id]) >= 0.9:\n                similar_count += 1\n        \n        jaccard_score = similar_count / len(common_questions)\n        \n        # Store the result\n        similarity_record = AttemptSimilarity(\n            quiz_id=quiz_id,\n            attempt_a_id=min(attempt1_id, attempt2_id),\n            attempt_b_id=max(attempt1_id, attempt2_id),\n            jaccard_score=jaccard_score,\n            coanswer_count=similar_count,\n            last_updated=datetime.utcnow()\n        )\n        \n        try:\n            db.session.merge(similarity_record)\n            db.session.commit()\n        except:\n            db.session.rollback()\n        \n        return jaccard_score\n    \n    def get_question_count(self, quiz_id: int) -> int:\n        \"\"\"Get total number of questions in quiz.\"\"\"\n        from models import Question\n        return Question.query.filter_by(quiz_id=quiz_id).count()\n    \n    def count_similar_answers(self, attempt1_id: int, attempt2_id: int) -> int:\n        \"\"\"Count similar answers between two attempts.\"\"\"\n        similarity = AttemptSimilarity.query.filter_by(\n            attempt_a_id=min(attempt1_id, attempt2_id),\n            attempt_b_id=max(attempt1_id, attempt2_id)\n        ).first()\n        \n        return similarity.coanswer_count if similarity else 0\n    \n    def check_simultaneous_pattern(self, quiz_id: int, participant_ids: List[int]) -> float:\n        \"\"\"Check for patterns of simultaneous answers.\"\"\"\n        # Count simultaneous events in recent history\n        cache_key = self.get_cache_key(quiz_id, \"simultaneous\")\n        \n        # Increment counter for this participant group\n        group_key = \"-\".join(sorted(map(str, participant_ids)))\n        current_count = self.cache_hget(cache_key, group_key)\n        new_count = int(current_count) + 1 if current_count else 1\n        \n        self.cache_hset(cache_key, group_key, str(new_count))\n        \n        # Score based on frequency of simultaneous answers\n        return min(1.0, new_count / 5.0)  # Max score after 5 simultaneous events\n    \n    def get_all_attempt_timings(self, quiz_id: int) -> Dict[int, List[Dict]]:\n        \"\"\"Get timing data for all attempts in quiz.\"\"\"\n        cache_key = self.get_cache_key(quiz_id, \"timing\")\n        timings = {}\n        \n        if redis_client:\n            try:\n                timing_data = redis_client.hgetall(cache_key)\n                for attempt_id, data_json in timing_data.items():\n                    data = json.loads(data_json)\n                    attempt_id = int(attempt_id)\n                    if attempt_id not in timings:\n                        timings[attempt_id] = []\n                    timings[attempt_id].append(data)\n            except:\n                pass\n        \n        return timings\n    \n    def calculate_timing_correlations(self, all_timings: Dict[int, List[Dict]], \n                                    current_attempt: int) -> Dict[int, float]:\n        \"\"\"Calculate timing correlations between attempts.\"\"\"\n        correlations = {}\n        \n        current_timings = all_timings.get(current_attempt, [])\n        if len(current_timings) < self.MIN_QUESTIONS_FOR_DETECTION:\n            return correlations\n        \n        for other_attempt, other_timings in all_timings.items():\n            if (other_attempt != current_attempt and \n                len(other_timings) >= self.MIN_QUESTIONS_FOR_DETECTION):\n                \n                correlation = self.calculate_pearson_correlation(\n                    current_timings, other_timings\n                )\n                if correlation >= self.TIMING_CORRELATION_THRESHOLD:\n                    correlations[other_attempt] = correlation\n        \n        return correlations\n    \n    def calculate_pearson_correlation(self, timings1: List[Dict], timings2: List[Dict]) -> float:\n        \"\"\"Calculate Pearson correlation coefficient for timing patterns.\"\"\"\n        # Simple implementation - could be enhanced\n        try:\n            if len(timings1) < 2 or len(timings2) < 2:\n                return 0.0\n            \n            # Calculate intervals between answers\n            intervals1 = []\n            intervals2 = []\n            \n            for i in range(1, len(timings1)):\n                intervals1.append(timings1[i]['timestamp'] - timings1[i-1]['timestamp'])\n            \n            for i in range(1, len(timings2)):\n                intervals2.append(timings2[i]['timestamp'] - timings2[i-1]['timestamp'])\n            \n            # Use minimum length for comparison\n            min_len = min(len(intervals1), len(intervals2))\n            if min_len < 2:\n                return 0.0\n            \n            intervals1 = intervals1[:min_len]\n            intervals2 = intervals2[:min_len]\n            \n            # Calculate Pearson correlation\n            mean1 = sum(intervals1) / len(intervals1)\n            mean2 = sum(intervals2) / len(intervals2)\n            \n            numerator = sum((x - mean1) * (y - mean2) for x, y in zip(intervals1, intervals2))\n            \n            sum_sq1 = sum((x - mean1) ** 2 for x in intervals1)\n            sum_sq2 = sum((y - mean2) ** 2 for y in intervals2)\n            \n            denominator = math.sqrt(sum_sq1 * sum_sq2)\n            \n            return numerator / denominator if denominator > 0 else 0.0\n            \n        except Exception as e:\n            print(f\"Error calculating correlation: {e}\")\n            return 0.0\n    \n    def calculate_ip_suspicion_score(self, logs: List) -> float:\n        \"\"\"Calculate suspicion score for shared IP usage.\"\"\"\n        # Simple heuristic based on timing overlap and user agent similarity\n        user_agents = [log.user_agent for log in logs if log.user_agent]\n        unique_agents = set(user_agents)\n        \n        # If too many different user agents, less suspicious (could be shared network)\n        if len(unique_agents) > len(logs) * 0.7:\n            return 0.3\n        \n        # If very similar user agents, more suspicious\n        if len(unique_agents) < len(logs) * 0.3:\n            return 0.9\n        \n        return 0.6  # Moderate suspicion for shared IP\n    \n    def calculate_time_overlap(self, logs: List) -> int:\n        \"\"\"Calculate time overlap in minutes for shared IP logs.\"\"\"\n        if len(logs) < 2:\n            return 0\n        \n        times = [log.logged_in_at for log in logs]\n        times.sort()\n        \n        # Calculate overlap between first and last login\n        overlap = (times[-1] - times[0]).total_seconds() / 60\n        return int(overlap)\n\n\n# Global detector instance\ndetector = CollaborationDetector()","size_bytes":24053},"heatmap_analysis.py":{"content":"\"\"\"\nReal-time Collaboration Heatmap Analysis Engine\nGenerates contextual insights from interaction data and quiz performance metrics\n\"\"\"\n\nimport json\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Tuple\nfrom sqlalchemy import func, and_\nfrom app import db\nfrom models import (\n    InteractionEvent, QuestionHeatmapData, CollaborationInsight, \n    QuizAttempt, Question, Answer, Quiz\n)\n\nclass HeatmapAnalysisEngine:\n    \"\"\"Engine for analyzing heatmap data and generating contextual insights\"\"\"\n    \n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n    \n    def analyze_quiz_performance(self, quiz_id: int) -> List[Dict[str, Any]]:\n        \"\"\"\n        Analyze overall quiz performance and generate insights\n        \n        Args:\n            quiz_id: ID of the quiz to analyze\n            \n        Returns:\n            List of generated insights\n        \"\"\"\n        insights = []\n        \n        try:\n            # Get quiz and basic metrics\n            quiz = Quiz.query.get(quiz_id)\n            if not quiz:\n                return insights\n            \n            # Analyze different aspects\n            insights.extend(self._analyze_difficulty_patterns(quiz_id))\n            insights.extend(self._analyze_engagement_patterns(quiz_id))\n            insights.extend(self._analyze_confusion_areas(quiz_id))\n            insights.extend(self._analyze_performance_trends(quiz_id))\n            insights.extend(self._analyze_interaction_hotspots(quiz_id))\n            \n            # Save insights to database\n            for insight_data in insights:\n                self._save_insight(quiz_id, insight_data)\n                \n        except Exception as e:\n            self.logger.error(f\"Error analyzing quiz {quiz_id}: {e}\")\n        \n        return insights\n    \n    def _analyze_difficulty_patterns(self, quiz_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Identify questions with difficulty patterns\"\"\"\n        insights = []\n        \n        try:\n            # Get heatmap data for all questions\n            heatmap_data = QuestionHeatmapData.query.filter_by(quiz_id=quiz_id).all()\n            \n            if not heatmap_data:\n                return insights\n            \n            # Identify difficult questions (low correct rate + high interaction time)\n            difficult_questions = []\n            for data in heatmap_data:\n                if (data.correct_answer_rate < 50 and \n                    data.average_time_spent > 0 and\n                    data.total_participants > 0):\n                    difficult_questions.append({\n                        'questionId': data.question_id,\n                        'correctRate': data.correct_answer_rate,\n                        'avgTime': data.average_time_spent,\n                        'participants': data.total_participants\n                    })\n            \n            if difficult_questions:\n                # Sort by difficulty (lowest correct rate first)\n                difficult_questions.sort(key=lambda x: x['correctRate'])\n                worst_questions = difficult_questions[:3]  # Top 3 most difficult\n                \n                severity = 'high' if len(difficult_questions) > 3 else 'medium'\n                \n                insights.append({\n                    'type': 'difficulty_pattern',\n                    'title': f'{len(difficult_questions)} Questions Show High Difficulty',\n                    'description': f'Multiple questions have low success rates (<50%) and high completion times. Students are struggling with specific content areas.',\n                    'severity': severity,\n                    'affected_questions': [q['questionId'] for q in difficult_questions],\n                    'metric_values': {\n                        'total_difficult': len(difficult_questions),\n                        'worst_questions': worst_questions,\n                        'avg_correct_rate': sum(q['correctRate'] for q in difficult_questions) / len(difficult_questions)\n                    },\n                    'suggested_actions': [\n                        'Review question wording for clarity',\n                        'Consider additional hints or examples',\n                        'Provide prerequisite materials',\n                        'Schedule review session for difficult topics'\n                    ]\n                })\n                \n        except Exception as e:\n            self.logger.error(f\"Error analyzing difficulty patterns: {e}\")\n        \n        return insights\n    \n    def _analyze_engagement_patterns(self, quiz_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Analyze participant engagement patterns\"\"\"\n        insights = []\n        \n        try:\n            # Get interaction events for engagement analysis\n            attempts = QuizAttempt.query.filter_by(quiz_id=quiz_id).all()\n            if not attempts:\n                return insights\n            \n            attempt_ids = [attempt.id for attempt in attempts]\n            \n            # Analyze engagement drops over time\n            events = db.session.query(InteractionEvent).filter(\n                InteractionEvent.attempt_id.in_(attempt_ids)\n            ).order_by(InteractionEvent.timestamp).all()\n            \n            if events:\n                # Group events by time windows (5-minute intervals)\n                time_windows = self._group_events_by_time_windows(events, minutes=5)\n                \n                # Look for significant engagement drops\n                engagement_drops = []\n                for i in range(1, len(time_windows)):\n                    current = len(time_windows[i])\n                    previous = len(time_windows[i-1])\n                    \n                    if previous > 0:\n                        drop_percentage = ((previous - current) / previous) * 100\n                        if drop_percentage > 30:  # 30% drop threshold\n                            engagement_drops.append({\n                                'window': i,\n                                'drop_percentage': drop_percentage,\n                                'events_before': previous,\n                                'events_after': current\n                            })\n                \n                if engagement_drops:\n                    worst_drop = max(engagement_drops, key=lambda x: x['drop_percentage'])\n                    \n                    insights.append({\n                        'type': 'engagement_drop',\n                        'title': f'Engagement Drop Detected ({worst_drop[\"drop_percentage\"]:.1f}%)',\n                        'description': f'Significant decrease in participant interactions detected during the quiz session.',\n                        'severity': 'medium' if worst_drop['drop_percentage'] < 50 else 'high',\n                        'affected_questions': [],  # Time-based, not question-specific\n                        'metric_values': {\n                            'total_drops': len(engagement_drops),\n                            'worst_drop': worst_drop,\n                            'total_events': len(events)\n                        },\n                        'suggested_actions': [\n                            'Check quiz length and pacing',\n                            'Consider adding breaks or checkpoints',\n                            'Review content difficulty progression',\n                            'Monitor participant fatigue indicators'\n                        ]\n                    })\n                    \n        except Exception as e:\n            self.logger.error(f\"Error analyzing engagement patterns: {e}\")\n        \n        return insights\n    \n    def _analyze_confusion_areas(self, quiz_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Identify areas where participants show confusion\"\"\"\n        insights = []\n        \n        try:\n            # Get questions with high interaction but low accuracy\n            heatmap_data = QuestionHeatmapData.query.filter_by(quiz_id=quiz_id).all()\n            \n            confusion_indicators = []\n            for data in heatmap_data:\n                if data.total_participants > 0:\n                    # High interaction density with low accuracy indicates confusion\n                    interaction_density = (data.total_clicks + data.total_hovers) / data.total_participants\n                    \n                    if (interaction_density > 10 and  # High interaction\n                        data.correct_answer_rate < 60 and  # Low accuracy\n                        data.average_time_spent > 0):\n                        \n                        confusion_score = interaction_density * (100 - data.correct_answer_rate) / 100\n                        confusion_indicators.append({\n                            'questionId': data.question_id,\n                            'confusion_score': confusion_score,\n                            'interaction_density': interaction_density,\n                            'correct_rate': data.correct_answer_rate,\n                            'avg_time': data.average_time_spent\n                        })\n            \n            if confusion_indicators:\n                # Sort by confusion score\n                confusion_indicators.sort(key=lambda x: x['confusion_score'], reverse=True)\n                top_confusion = confusion_indicators[:2]  # Top 2 most confusing\n                \n                insights.append({\n                    'type': 'confusion_area',\n                    'title': f'{len(confusion_indicators)} Questions Show Confusion Patterns',\n                    'description': 'High interaction activity combined with low accuracy suggests participant confusion.',\n                    'severity': 'medium',\n                    'affected_questions': [q['questionId'] for q in confusion_indicators],\n                    'metric_values': {\n                        'total_confused': len(confusion_indicators),\n                        'top_confusion': top_confusion,\n                        'avg_confusion_score': sum(q['confusion_score'] for q in confusion_indicators) / len(confusion_indicators)\n                    },\n                    'suggested_actions': [\n                        'Clarify question instructions',\n                        'Review answer option wording',\n                        'Add visual aids or examples',\n                        'Consider question redesign'\n                    ]\n                })\n                \n        except Exception as e:\n            self.logger.error(f\"Error analyzing confusion areas: {e}\")\n        \n        return insights\n    \n    def _analyze_performance_trends(self, quiz_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Analyze performance trends across the quiz\"\"\"\n        insights = []\n        \n        try:\n            # Get questions in order and their performance\n            questions = Question.query.filter_by(quiz_id=quiz_id).order_by(Question.id).all()\n            if len(questions) < 3:  # Need at least 3 questions for trends\n                return insights\n            \n            # Get performance data for each question\n            performance_data = []\n            for question in questions:\n                heatmap = QuestionHeatmapData.query.filter_by(\n                    quiz_id=quiz_id, \n                    question_id=question.id\n                ).first()\n                \n                if heatmap and heatmap.total_participants > 0:\n                    performance_data.append({\n                        'questionId': question.id,\n                        'position': len(performance_data) + 1,\n                        'correct_rate': heatmap.correct_answer_rate,\n                        'avg_time': heatmap.average_time_spent,\n                        'engagement': heatmap.engagement_score\n                    })\n            \n            if len(performance_data) >= 3:\n                # Analyze trends\n                trends = self._calculate_performance_trends(performance_data)\n                \n                for trend in trends:\n                    if trend['significant']:\n                        insights.append({\n                            'type': 'performance_trend',\n                            'title': f'{trend[\"type\"].title()} Performance Trend Detected',\n                            'description': trend['description'],\n                            'severity': 'low',\n                            'affected_questions': [q['questionId'] for q in performance_data],\n                            'metric_values': {\n                                'trend_type': trend['type'],\n                                'trend_strength': trend['strength'],\n                                'performance_data': performance_data\n                            },\n                            'suggested_actions': trend['suggestions']\n                        })\n                        \n        except Exception as e:\n            self.logger.error(f\"Error analyzing performance trends: {e}\")\n        \n        return insights\n    \n    def _analyze_interaction_hotspots(self, quiz_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Analyze interaction hotspots for UX insights\"\"\"\n        insights = []\n        \n        try:\n            # Get questions with hotspot data\n            heatmap_data = QuestionHeatmapData.query.filter_by(quiz_id=quiz_id).all()\n            \n            hotspot_insights = []\n            for data in heatmap_data:\n                if data.click_hotspots and data.total_participants > 5:  # Need sufficient data\n                    hotspots = json.loads(data.click_hotspots)\n                    \n                    if len(hotspots) > 0:\n                        # Analyze hotspot distribution\n                        hotspot_analysis = self._analyze_hotspot_distribution(hotspots)\n                        \n                        if hotspot_analysis['concentrated']:\n                            hotspot_insights.append({\n                                'questionId': data.question_id,\n                                'hotspot_analysis': hotspot_analysis,\n                                'total_clicks': data.total_clicks,\n                                'participants': data.total_participants\n                            })\n            \n            if hotspot_insights:\n                insights.append({\n                    'type': 'interaction_hotspot',\n                    'title': f'Interaction Hotspots Identified in {len(hotspot_insights)} Questions',\n                    'description': 'Concentrated click patterns suggest specific UI elements or content areas draw attention.',\n                    'severity': 'low',\n                    'affected_questions': [h['questionId'] for h in hotspot_insights],\n                    'metric_values': {\n                        'hotspot_questions': len(hotspot_insights),\n                        'hotspot_details': hotspot_insights\n                    },\n                    'suggested_actions': [\n                        'Review UI element placement',\n                        'Analyze content layout effectiveness',\n                        'Consider A/B testing different designs',\n                        'Monitor user experience patterns'\n                    ]\n                })\n                \n        except Exception as e:\n            self.logger.error(f\"Error analyzing interaction hotspots: {e}\")\n        \n        return insights\n    \n    def _group_events_by_time_windows(self, events: List[InteractionEvent], minutes: int = 5) -> List[List]:\n        \"\"\"Group events into time windows\"\"\"\n        if not events:\n            return []\n        \n        windows = []\n        current_window = []\n        window_start = events[0].timestamp\n        window_duration = timedelta(minutes=minutes)\n        \n        for event in events:\n            if event.timestamp - window_start <= window_duration:\n                current_window.append(event)\n            else:\n                windows.append(current_window)\n                current_window = [event]\n                window_start = event.timestamp\n        \n        if current_window:\n            windows.append(current_window)\n        \n        return windows\n    \n    def _calculate_performance_trends(self, performance_data: List[Dict]) -> List[Dict]:\n        \"\"\"Calculate performance trends across questions\"\"\"\n        trends = []\n        \n        if len(performance_data) < 3:\n            return trends\n        \n        # Analyze correct rate trend\n        correct_rates = [p['correct_rate'] for p in performance_data]\n        correct_trend = self._calculate_trend(correct_rates)\n        \n        if abs(correct_trend) > 0.3:  # Significant trend threshold\n            trend_type = 'declining' if correct_trend < 0 else 'improving'\n            trends.append({\n                'type': f'{trend_type}_accuracy',\n                'strength': abs(correct_trend),\n                'significant': True,\n                'description': f'Accuracy {trend_type} throughout the quiz (trend: {correct_trend:.2f})',\n                'suggestions': [\n                    'Review question ordering',\n                    'Consider difficulty progression',\n                    'Monitor fatigue effects'\n                ] if trend_type == 'declining' else [\n                    'Maintain current progression',\n                    'Use as template for future quizzes'\n                ]\n            })\n        \n        return trends\n    \n    def _calculate_trend(self, values: List[float]) -> float:\n        \"\"\"Calculate linear trend coefficient\"\"\"\n        n = len(values)\n        if n < 2:\n            return 0\n        \n        x_vals = list(range(n))\n        x_mean = sum(x_vals) / n\n        y_mean = sum(values) / n\n        \n        numerator = sum((x_vals[i] - x_mean) * (values[i] - y_mean) for i in range(n))\n        denominator = sum((x_vals[i] - x_mean) ** 2 for i in range(n))\n        \n        return numerator / denominator if denominator != 0 else 0\n    \n    def _analyze_hotspot_distribution(self, hotspots: List[Tuple[int, int]]) -> Dict[str, Any]:\n        \"\"\"Analyze if hotspots are concentrated or distributed\"\"\"\n        if len(hotspots) < 5:\n            return {'concentrated': False}\n        \n        # Calculate clustering (simplified approach)\n        x_coords = [h[0] for h in hotspots if h[0] is not None]\n        y_coords = [h[1] for h in hotspots if h[1] is not None]\n        \n        if not x_coords or not y_coords:\n            return {'concentrated': False}\n        \n        x_range = max(x_coords) - min(x_coords)\n        y_range = max(y_coords) - min(y_coords)\n        \n        # If most clicks are in a small area, consider it concentrated\n        x_concentrated = x_range < 200  # pixels\n        y_concentrated = y_range < 200  # pixels\n        \n        return {\n            'concentrated': x_concentrated and y_concentrated,\n            'x_range': x_range,\n            'y_range': y_range,\n            'total_hotspots': len(hotspots)\n        }\n    \n    def _save_insight(self, quiz_id: int, insight_data: Dict[str, Any]) -> None:\n        \"\"\"Save insight to database\"\"\"\n        try:\n            # Check if similar insight already exists\n            existing = CollaborationInsight.query.filter_by(\n                quiz_id=quiz_id,\n                insight_type=insight_data['type'],\n                is_active=True\n            ).first()\n            \n            if existing:\n                # Update existing insight\n                existing.title = insight_data['title']\n                existing.description = insight_data['description']\n                existing.severity = insight_data['severity']\n                existing.affected_questions = json.dumps(insight_data['affected_questions'])\n                existing.metric_values = json.dumps(insight_data['metric_values'])\n                existing.suggested_actions = json.dumps(insight_data['suggested_actions'])\n                existing.updated_at = datetime.utcnow()\n            else:\n                # Create new insight\n                insight = CollaborationInsight(\n                    quiz_id=quiz_id,\n                    insight_type=insight_data['type'],\n                    title=insight_data['title'],\n                    description=insight_data['description'],\n                    severity=insight_data['severity'],\n                    affected_questions=json.dumps(insight_data['affected_questions']),\n                    metric_values=json.dumps(insight_data['metric_values']),\n                    suggested_actions=json.dumps(insight_data['suggested_actions'])\n                )\n                db.session.add(insight)\n            \n            db.session.commit()\n            \n        except Exception as e:\n            self.logger.error(f\"Error saving insight: {e}\")\n            db.session.rollback()\n\n# Global analysis engine instance\nanalysis_engine = HeatmapAnalysisEngine()\n\ndef analyze_quiz_insights(quiz_id: int) -> List[Dict[str, Any]]:\n    \"\"\"\n    Public function to analyze quiz and generate insights\n    \n    Args:\n        quiz_id: ID of the quiz to analyze\n        \n    Returns:\n        List of generated insights\n    \"\"\"\n    return analysis_engine.analyze_quiz_performance(quiz_id)\n\ndef trigger_analysis_for_quiz(quiz_id: int) -> bool:\n    \"\"\"\n    Trigger analysis for a quiz (can be called periodically or on-demand)\n    \n    Args:\n        quiz_id: ID of the quiz to analyze\n        \n    Returns:\n        True if analysis completed successfully\n    \"\"\"\n    try:\n        insights = analyze_quiz_insights(quiz_id)\n        logging.info(f\"Generated {len(insights)} insights for quiz {quiz_id}\")\n        return True\n    except Exception as e:\n        logging.error(f\"Failed to analyze quiz {quiz_id}: {e}\")\n        return False","size_bytes":21704},"static/js/heatmap-dashboard.js":{"content":"/**\n * Heatmap Dashboard JavaScript\n * Interactive visualization and real-time updates for collaboration heatmap\n */\n\nclass HeatmapDashboard {\n    constructor() {\n        this.currentQuizId = null;\n        this.currentView = 'clicks';\n        this.refreshInterval = 10000; // 10 seconds\n        this.autoRefreshTimer = null;\n        this.engagementChart = null;\n        this.insights = [];\n        this.heatmapData = {};\n        \n        this.initializeEventListeners();\n    }\n    \n    initializeEventListeners() {\n        // Real-time updates\n        this.startAutoRefresh();\n        \n        // Window focus/blur events for pausing updates\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.pauseAutoRefresh();\n            } else {\n                this.resumeAutoRefresh();\n            }\n        });\n    }\n    \n    async loadQuizHeatmap() {\n        const quizSelect = document.getElementById('quizSelect');\n        const quizId = quizSelect.value;\n        \n        if (!quizId) {\n            document.getElementById('heatmapContent').classList.add('d-none');\n            return;\n        }\n        \n        this.currentQuizId = quizId;\n        document.getElementById('heatmapContent').classList.remove('d-none');\n        \n        // Show loading state\n        this.showLoadingState();\n        \n        try {\n            // Load heatmap data and insights simultaneously\n            const [heatmapResponse, insightsResponse] = await Promise.all([\n                fetch(`/api/heatmap/data/${quizId}`),\n                fetch(`/api/heatmap/insights/${quizId}`)\n            ]);\n            \n            const heatmapData = await heatmapResponse.json();\n            const insightsData = await insightsResponse.json();\n            \n            if (heatmapData.success) {\n                this.heatmapData = heatmapData;\n                this.renderHeatmapVisualization(heatmapData);\n                this.updateMetricsOverview(heatmapData);\n                this.renderQuestionAnalysisTable(heatmapData);\n                this.renderEngagementChart(heatmapData);\n            }\n            \n            if (insightsData.success) {\n                this.insights = insightsData.insights;\n                this.renderInsights(insightsData);\n            }\n            \n        } catch (error) {\n            console.error('Error loading heatmap data:', error);\n            this.showErrorState('Failed to load heatmap data. Please try again.');\n        }\n    }\n    \n    renderHeatmapVisualization(data) {\n        const container = document.getElementById('questionsHeatmap');\n        container.innerHTML = '';\n        \n        if (!data.questionsData || data.questionsData.length === 0) {\n            container.innerHTML = `\n                <div class=\"text-center text-white-50 py-5\">\n                    <i class=\"fas fa-chart-bar fa-3x mb-3\"></i>\n                    <p>No interaction data available yet</p>\n                    <small>Data will appear as participants interact with the quiz</small>\n                </div>\n            `;\n            return;\n        }\n        \n        data.questionsData.forEach((questionData, index) => {\n            const questionElement = this.createQuestionHeatmap(questionData, index + 1);\n            container.appendChild(questionElement);\n        });\n        \n        // Update view buttons\n        this.updateViewButtons();\n    }\n    \n    createQuestionHeatmap(questionData, questionNumber) {\n        const element = document.createElement('div');\n        element.className = 'heatmap-question';\n        \n        const difficulty = this.calculateDifficulty(questionData.correctAnswerRate);\n        const hotspots = this.currentView === 'clicks' ? questionData.clickHotspots : questionData.hoverHotspots;\n        \n        element.innerHTML = `\n            <div class=\"d-flex justify-content-between align-items-center mb-3\">\n                <div>\n                    <h6 class=\"text-white mb-1\">Question ${questionNumber}</h6>\n                    <span class=\"difficulty-indicator difficulty-${difficulty.level}\">\n                        ${difficulty.label}\n                    </span>\n                </div>\n                <div class=\"text-white-50 small\">\n                    <div><i class=\"fas fa-users me-1\"></i>${questionData.totalParticipants} participants</div>\n                    <div><i class=\"fas fa-clock me-1\"></i>${questionData.averageTimeSpent?.toFixed(1) || 0}s avg</div>\n                </div>\n            </div>\n            \n            <div class=\"heatmap-canvas\" id=\"heatmap-${questionData.questionId}\">\n                <div class=\"hotspot-overlay\" id=\"hotspots-${questionData.questionId}\">\n                    ${this.renderHotspots(hotspots)}\n                </div>\n                <div class=\"p-3 text-center\">\n                    <div class=\"row text-dark\">\n                        <div class=\"col-3\">\n                            <div class=\"h4 mb-1\">${questionData.totalClicks}</div>\n                            <small>Clicks</small>\n                        </div>\n                        <div class=\"col-3\">\n                            <div class=\"h4 mb-1\">${questionData.totalHovers}</div>\n                            <small>Hovers</small>\n                        </div>\n                        <div class=\"col-3\">\n                            <div class=\"h4 mb-1\">${questionData.correctAnswerRate?.toFixed(1) || 0}%</div>\n                            <small>Accuracy</small>\n                        </div>\n                        <div class=\"col-3\">\n                            <div class=\"h4 mb-1\">${questionData.engagementScore?.toFixed(1) || 0}</div>\n                            <small>Engagement</small>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"mt-2 d-flex justify-content-end\">\n                <button class=\"btn btn-sm btn-outline-light\" onclick=\"showQuestionDetails(${questionData.questionId})\">\n                    <i class=\"fas fa-eye me-1\"></i>View Details\n                </button>\n            </div>\n        `;\n        \n        return element;\n    }\n    \n    renderHotspots(hotspots) {\n        if (!hotspots || hotspots.length === 0) {\n            return '';\n        }\n        \n        return hotspots.slice(0, 20).map(([x, y]) => {\n            if (x === null || y === null) return '';\n            \n            const size = 20 + Math.random() * 15; // Varying sizes\n            const left = Math.max(0, Math.min(95, (x / 1000) * 100)); // Normalize to percentage\n            const top = Math.max(0, Math.min(95, (y / 600) * 100)); // Normalize to percentage\n            \n            return `\n                <div class=\"hotspot-point\" style=\"\n                    left: ${left}%; \n                    top: ${top}%; \n                    width: ${size}px; \n                    height: ${size}px;\n                    animation-delay: ${Math.random() * 2}s;\n                \"></div>\n            `;\n        }).join('');\n    }\n    \n    calculateDifficulty(correctRate) {\n        if (correctRate >= 80) return { level: 'easy', label: 'Easy' };\n        if (correctRate >= 60) return { level: 'medium', label: 'Medium' };\n        return { level: 'hard', label: 'Hard' };\n    }\n    \n    updateMetricsOverview(data) {\n        const totalParticipants = Math.max(...data.questionsData.map(q => q.totalParticipants || 0));\n        const avgEngagement = data.questionsData.length > 0 \n            ? data.questionsData.reduce((sum, q) => sum + (q.engagementScore || 0), 0) / data.questionsData.length \n            : 0;\n        const difficultQuestions = data.questionsData.filter(q => (q.correctAnswerRate || 0) < 60).length;\n        \n        document.getElementById('totalParticipants').textContent = totalParticipants;\n        document.getElementById('avgEngagement').textContent = `${avgEngagement.toFixed(1)}%`;\n        document.getElementById('difficultQuestions').textContent = difficultQuestions;\n        document.getElementById('activeInsights').textContent = this.insights.length;\n    }\n    \n    renderInsights(data) {\n        const container = document.getElementById('insightsContainer');\n        \n        if (!data.insights || data.insights.length === 0) {\n            container.innerHTML = `\n                <div class=\"text-center text-muted py-4\">\n                    <i class=\"fas fa-check-circle fa-2x mb-3 text-success\"></i>\n                    <p>No insights generated yet</p>\n                    <small>Insights will appear as more data becomes available</small>\n                </div>\n            `;\n            return;\n        }\n        \n        container.innerHTML = data.insights.map(insight => `\n            <div class=\"insight-card insight-${insight.severity} card mb-3\">\n                <div class=\"card-body\">\n                    <div class=\"d-flex justify-content-between align-items-start mb-2\">\n                        <h6 class=\"card-title mb-1\">\n                            <i class=\"fas fa-${this.getInsightIcon(insight.type)} me-2\"></i>\n                            ${insight.title}\n                        </h6>\n                        <span class=\"badge bg-${this.getSeverityColor(insight.severity)}\">${insight.severity.toUpperCase()}</span>\n                    </div>\n                    <p class=\"card-text small text-muted\">${insight.description}</p>\n                    ${insight.suggestedActions.length > 0 ? `\n                        <div class=\"mt-2\">\n                            <strong class=\"small\">Suggested Actions:</strong>\n                            <ul class=\"small mb-2\">\n                                ${insight.suggestedActions.slice(0, 2).map(action => `<li>${action}</li>`).join('')}\n                            </ul>\n                        </div>\n                    ` : ''}\n                    <div class=\"d-flex justify-content-between align-items-center\">\n                        <small class=\"text-muted\">\n                            <i class=\"fas fa-clock me-1\"></i>\n                            ${new Date(insight.createdAt).toLocaleString()}\n                        </small>\n                        ${!insight.isAcknowledged ? `\n                            <button class=\"btn btn-sm btn-outline-primary\" onclick=\"acknowledgeInsight(${insight.id})\">\n                                <i class=\"fas fa-check me-1\"></i>Acknowledge\n                            </button>\n                        ` : '<small class=\"text-success\"><i class=\"fas fa-check-circle me-1\"></i>Acknowledged</small>'}\n                    </div>\n                </div>\n            </div>\n        `).join('');\n    }\n    \n    renderQuestionAnalysisTable(data) {\n        const tbody = document.querySelector('#questionAnalysisTable tbody');\n        \n        if (!data.questionsData || data.questionsData.length === 0) {\n            tbody.innerHTML = `\n                <tr>\n                    <td colspan=\"7\" class=\"text-center text-muted py-4\">\n                        <i class=\"fas fa-table fa-2x mb-2\"></i><br>\n                        No question data available\n                    </td>\n                </tr>\n            `;\n            return;\n        }\n        \n        tbody.innerHTML = data.questionsData.map((q, index) => {\n            const difficulty = this.calculateDifficulty(q.correctAnswerRate || 0);\n            return `\n                <tr>\n                    <td>\n                        <strong>Question ${index + 1}</strong>\n                        <br><small class=\"text-muted\">ID: ${q.questionId}</small>\n                    </td>\n                    <td>\n                        <span class=\"difficulty-indicator difficulty-${difficulty.level}\">\n                            ${difficulty.label}\n                        </span>\n                    </td>\n                    <td>${q.totalParticipants || 0}</td>\n                    <td>${(q.averageTimeSpent || 0).toFixed(1)}s</td>\n                    <td>\n                        <div class=\"progress\" style=\"height: 8px;\">\n                            <div class=\"progress-bar bg-${(q.correctAnswerRate || 0) >= 80 ? 'success' : (q.correctAnswerRate || 0) >= 60 ? 'warning' : 'danger'}\" \n                                 style=\"width: ${q.correctAnswerRate || 0}%\"></div>\n                        </div>\n                        <small>${(q.correctAnswerRate || 0).toFixed(1)}%</small>\n                    </td>\n                    <td>${(q.engagementScore || 0).toFixed(1)}</td>\n                    <td>\n                        <button class=\"btn btn-sm btn-outline-primary\" onclick=\"showQuestionDetails(${q.questionId})\">\n                            <i class=\"fas fa-eye\"></i>\n                        </button>\n                    </td>\n                </tr>\n            `;\n        }).join('');\n    }\n    \n    renderEngagementChart(data) {\n        const ctx = document.getElementById('engagementChart');\n        \n        if (this.engagementChart) {\n            this.engagementChart.destroy();\n        }\n        \n        // Simulate engagement timeline data\n        const timeLabels = [];\n        const engagementValues = [];\n        \n        for (let i = 0; i < 20; i++) {\n            timeLabels.push(new Date(Date.now() - (19 - i) * 60000).toLocaleTimeString());\n            engagementValues.push(Math.random() * 100);\n        }\n        \n        this.engagementChart = new Chart(ctx, {\n            type: 'line',\n            data: {\n                labels: timeLabels,\n                datasets: [{\n                    label: 'Engagement Score',\n                    data: engagementValues,\n                    borderColor: '#3b82f6',\n                    backgroundColor: 'rgba(59, 130, 246, 0.1)',\n                    fill: true,\n                    tension: 0.4\n                }]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                plugins: {\n                    legend: {\n                        display: false\n                    }\n                },\n                scales: {\n                    y: {\n                        beginAtZero: true,\n                        max: 100\n                    }\n                }\n            }\n        });\n    }\n    \n    setHeatmapView(view) {\n        this.currentView = view;\n        this.updateViewButtons();\n        \n        if (this.currentQuizId) {\n            this.renderHeatmapVisualization(this.heatmapData);\n        }\n    }\n    \n    updateViewButtons() {\n        ['clicks', 'hovers', 'time'].forEach(view => {\n            const btn = document.getElementById(`${view}Btn`);\n            if (btn) {\n                btn.classList.toggle('active', view === this.currentView);\n            }\n        });\n    }\n    \n    getInsightIcon(type) {\n        const icons = {\n            'difficulty_pattern': 'exclamation-triangle',\n            'engagement_drop': 'arrow-down',\n            'confusion_area': 'question-circle',\n            'performance_trend': 'chart-line',\n            'interaction_hotspot': 'map-marker-alt'\n        };\n        return icons[type] || 'info-circle';\n    }\n    \n    getSeverityColor(severity) {\n        const colors = {\n            'critical': 'danger',\n            'high': 'warning',\n            'medium': 'info',\n            'low': 'success'\n        };\n        return colors[severity] || 'secondary';\n    }\n    \n    showLoadingState() {\n        document.getElementById('questionsHeatmap').innerHTML = `\n            <div class=\"text-center py-5\">\n                <div class=\"spinner-border text-light\" role=\"status\">\n                    <span class=\"visually-hidden\">Loading...</span>\n                </div>\n                <p class=\"text-white mt-3\">Loading heatmap data...</p>\n            </div>\n        `;\n        \n        document.getElementById('insightsContainer').innerHTML = `\n            <div class=\"text-center py-4\">\n                <div class=\"spinner-border text-primary\" role=\"status\">\n                    <span class=\"visually-hidden\">Loading...</span>\n                </div>\n                <p class=\"mt-3\">Analyzing insights...</p>\n            </div>\n        `;\n    }\n    \n    showErrorState(message) {\n        document.getElementById('questionsHeatmap').innerHTML = `\n            <div class=\"text-center py-5\">\n                <i class=\"fas fa-exclamation-triangle text-warning fa-3x mb-3\"></i>\n                <p class=\"text-white\">${message}</p>\n                <button class=\"btn btn-outline-light\" onclick=\"loadQuizHeatmap()\">\n                    <i class=\"fas fa-redo me-2\"></i>Retry\n                </button>\n            </div>\n        `;\n    }\n    \n    startAutoRefresh() {\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n        }\n        \n        this.autoRefreshTimer = setInterval(() => {\n            if (this.currentQuizId && !document.hidden) {\n                this.loadQuizHeatmap();\n            }\n        }, this.refreshInterval);\n    }\n    \n    pauseAutoRefresh() {\n        if (this.autoRefreshTimer) {\n            clearInterval(this.autoRefreshTimer);\n            this.autoRefreshTimer = null;\n        }\n    }\n    \n    resumeAutoRefresh() {\n        this.startAutoRefresh();\n    }\n    \n    refreshDashboard() {\n        if (this.currentQuizId) {\n            this.loadQuizHeatmap();\n        }\n    }\n}\n\n// Global functions for HTML event handlers\nlet heatmapDashboard;\n\nfunction initializeHeatmapDashboard() {\n    heatmapDashboard = new HeatmapDashboard();\n}\n\nfunction loadQuizHeatmap() {\n    heatmapDashboard.loadQuizHeatmap();\n}\n\nfunction setHeatmapView(view) {\n    heatmapDashboard.setHeatmapView(view);\n}\n\nfunction refreshDashboard() {\n    heatmapDashboard.refreshDashboard();\n}\n\nasync function acknowledgeInsight(insightId) {\n    try {\n        const response = await fetch(`/api/heatmap/insights/${insightId}/acknowledge`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        \n        const result = await response.json();\n        \n        if (result.success) {\n            // Refresh insights\n            loadQuizHeatmap();\n        } else {\n            alert('Failed to acknowledge insight');\n        }\n    } catch (error) {\n        console.error('Error acknowledging insight:', error);\n        alert('Failed to acknowledge insight');\n    }\n}\n\nfunction showQuestionDetails(questionId) {\n    // Show question detail modal\n    const modal = new bootstrap.Modal(document.getElementById('questionDetailModal'));\n    \n    document.getElementById('questionDetailContent').innerHTML = `\n        <div class=\"text-center py-4\">\n            <div class=\"spinner-border\" role=\"status\">\n                <span class=\"visually-hidden\">Loading...</span>\n            </div>\n            <p class=\"mt-3\">Loading question details...</p>\n        </div>\n    `;\n    \n    modal.show();\n    \n    // TODO: Load detailed question analysis\n    setTimeout(() => {\n        document.getElementById('questionDetailContent').innerHTML = `\n            <div class=\"alert alert-info\">\n                <i class=\"fas fa-info-circle me-2\"></i>\n                Detailed question analysis coming soon!\n            </div>\n        `;\n    }, 1000);\n}\n\nfunction showAnalysisSettings() {\n    const modal = new bootstrap.Modal(document.getElementById('analysisSettingsModal'));\n    modal.show();\n}\n\nfunction saveAnalysisSettings() {\n    const refreshInterval = document.getElementById('refreshInterval').value;\n    const enableRealTime = document.getElementById('enableRealTime').checked;\n    \n    heatmapDashboard.refreshInterval = parseInt(refreshInterval);\n    \n    if (enableRealTime) {\n        heatmapDashboard.startAutoRefresh();\n    } else {\n        heatmapDashboard.pauseAutoRefresh();\n    }\n    \n    // Close modal\n    bootstrap.Modal.getInstance(document.getElementById('analysisSettingsModal')).hide();\n}\n\nfunction exportHeatmapData() {\n    if (!heatmapDashboard.currentQuizId) {\n        alert('Please select a quiz first');\n        return;\n    }\n    \n    // TODO: Implement data export\n    alert('Export functionality coming soon!');\n}","size_bytes":20114},"static/js/drag-drop.js":{"content":"/**\n * Drag and Drop Interface for Course and Quiz Management\n * Provides intuitive drag-and-drop functionality for reordering courses and quizzes\n */\n\nclass DragDropManager {\n    constructor() {\n        this.draggedElement = null;\n        this.draggedIndex = null;\n        this.container = null;\n        this.onDropCallback = null;\n        this.init();\n    }\n\n    init() {\n        this.setupEventListeners();\n        this.addDragDropStyles();\n    }\n\n    /**\n     * Initialize drag-and-drop for a container\n     * @param {string} containerSelector - CSS selector for the container\n     * @param {string} itemSelector - CSS selector for draggable items\n     * @param {function} onDropCallback - Callback function when item is dropped\n     */\n    initializeDragDrop(containerSelector, itemSelector, onDropCallback) {\n        const container = document.querySelector(containerSelector);\n        if (!container) return;\n\n        // For table rows, use tbody as the actual drag container\n        this.container = container.querySelector('tbody') || container;\n        this.onDropCallback = onDropCallback;\n\n        // Make items draggable\n        const items = container.querySelectorAll(itemSelector);\n        items.forEach((item, index) => {\n            this.makeDraggable(item, index);\n        });\n\n        // Setup container drop zones\n        this.setupDropZones(this.container);\n    }\n\n    makeDraggable(element, index) {\n        element.draggable = true;\n        element.dataset.originalIndex = index;\n        \n        // Add drag handle if not present\n        if (!element.querySelector('.drag-handle')) {\n            const dragHandle = document.createElement('div');\n            dragHandle.className = 'drag-handle';\n            dragHandle.innerHTML = '<i class=\"fas fa-grip-vertical\"></i>';\n            dragHandle.title = 'Drag to reorder';\n            element.insertBefore(dragHandle, element.firstChild);\n        }\n\n        // Drag events\n        element.addEventListener('dragstart', (e) => this.handleDragStart(e));\n        element.addEventListener('dragend', (e) => this.handleDragEnd(e));\n    }\n\n    setupDropZones(container) {\n        container.addEventListener('dragover', (e) => this.handleDragOver(e));\n        container.addEventListener('drop', (e) => this.handleDrop(e));\n    }\n\n    handleDragStart(e) {\n        this.draggedElement = e.target;\n        this.draggedIndex = parseInt(e.target.dataset.originalIndex);\n        \n        e.target.classList.add('dragging');\n        e.dataTransfer.effectAllowed = 'move';\n        e.dataTransfer.setData('text/html', e.target.outerHTML);\n\n        // Add visual feedback\n        setTimeout(() => {\n            e.target.style.opacity = '0.5';\n        }, 0);\n\n        this.showDropIndicators();\n    }\n\n    handleDragEnd(e) {\n        e.target.classList.remove('dragging');\n        e.target.style.opacity = '';\n        this.hideDropIndicators();\n        \n        // Clean up\n        this.draggedElement = null;\n        this.draggedIndex = null;\n    }\n\n    handleDragOver(e) {\n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n\n        const afterElement = this.getDragAfterElement(e.clientY);\n        const draggingElement = document.querySelector('.dragging');\n        \n        if (afterElement == null) {\n            this.container.appendChild(draggingElement);\n        } else {\n            this.container.insertBefore(draggingElement, afterElement);\n        }\n    }\n\n    handleDrop(e) {\n        e.preventDefault();\n        \n        if (!this.draggedElement) return;\n\n        const newOrder = this.getNewOrder();\n        \n        if (this.onDropCallback) {\n            this.onDropCallback(newOrder);\n        }\n\n        this.updateVisualOrder();\n        this.showSuccessAnimation();\n    }\n\n    getDragAfterElement(y) {\n        const draggableElements = [...this.container.querySelectorAll('[draggable=\"true\"]:not(.dragging)')];\n        \n        return draggableElements.reduce((closest, child) => {\n            const box = child.getBoundingClientRect();\n            const offset = y - box.top - box.height / 2;\n            \n            if (offset < 0 && offset > closest.offset) {\n                return { offset: offset, element: child };\n            } else {\n                return closest;\n            }\n        }, { offset: Number.NEGATIVE_INFINITY }).element;\n    }\n\n    getNewOrder() {\n        const items = this.container.querySelectorAll('[draggable=\"true\"]');\n        return Array.from(items).map(item => {\n            return {\n                id: item.dataset.itemId,\n                element: item\n            };\n        });\n    }\n\n    updateVisualOrder() {\n        const items = this.container.querySelectorAll('[draggable=\"true\"]');\n        items.forEach((item, index) => {\n            item.dataset.originalIndex = index;\n        });\n    }\n\n    showDropIndicators() {\n        const items = this.container.querySelectorAll('[draggable=\"true\"]:not(.dragging)');\n        items.forEach(item => {\n            item.classList.add('drop-target');\n        });\n    }\n\n    hideDropIndicators() {\n        const items = this.container.querySelectorAll('[draggable=\"true\"]');\n        items.forEach(item => {\n            item.classList.remove('drop-target');\n        });\n    }\n\n    showSuccessAnimation() {\n        // Create success indicator\n        const indicator = document.createElement('div');\n        indicator.className = 'reorder-success';\n        indicator.innerHTML = '<i class=\"fas fa-check\"></i> Order updated!';\n        \n        document.body.appendChild(indicator);\n        \n        setTimeout(() => {\n            indicator.classList.add('show');\n        }, 100);\n        \n        setTimeout(() => {\n            indicator.classList.remove('show');\n            setTimeout(() => {\n                document.body.removeChild(indicator);\n            }, 300);\n        }, 2000);\n    }\n\n    addDragDropStyles() {\n        if (document.getElementById('drag-drop-styles')) return;\n\n        const styles = document.createElement('style');\n        styles.id = 'drag-drop-styles';\n        styles.textContent = `\n            /* Drag Handle Styles */\n            .drag-handle {\n                display: inline-flex;\n                align-items: center;\n                justify-content: center;\n                width: 20px;\n                height: 20px;\n                margin-right: 10px;\n                cursor: grab;\n                color: #6c757d;\n                border-radius: 3px;\n                transition: all 0.2s ease;\n            }\n\n            .drag-handle:hover {\n                background-color: #e9ecef;\n                color: #495057;\n            }\n\n            .drag-handle:active {\n                cursor: grabbing;\n            }\n\n            /* Dragging States */\n            [draggable=\"true\"].dragging {\n                opacity: 0.5 !important;\n                transform: rotate(2deg);\n                box-shadow: 0 5px 15px rgba(0,0,0,0.3);\n                z-index: 1000;\n                position: relative;\n            }\n\n            [draggable=\"true\"].drop-target {\n                border: 2px dashed #007bff;\n                background-color: rgba(0,123,255,0.1);\n                transition: all 0.2s ease;\n            }\n\n            [draggable=\"true\"] {\n                transition: all 0.2s ease;\n                position: relative;\n            }\n\n            [draggable=\"true\"]:hover .drag-handle {\n                background-color: #007bff;\n                color: white;\n            }\n\n            /* Success Animation */\n            .reorder-success {\n                position: fixed;\n                top: 20px;\n                right: 20px;\n                background: #28a745;\n                color: white;\n                padding: 12px 20px;\n                border-radius: 6px;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n                font-weight: 500;\n                z-index: 9999;\n                transform: translateX(100%);\n                opacity: 0;\n                transition: all 0.3s ease;\n            }\n\n            .reorder-success.show {\n                transform: translateX(0);\n                opacity: 1;\n            }\n\n            .reorder-success i {\n                margin-right: 8px;\n            }\n\n            /* Loading states */\n            .reordering {\n                pointer-events: none;\n                opacity: 0.6;\n            }\n\n            .reordering::before {\n                content: '';\n                position: absolute;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                background: rgba(255,255,255,0.8);\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                z-index: 10;\n            }\n\n            /* Responsive adjustments */\n            @media (max-width: 768px) {\n                .drag-handle {\n                    width: 24px;\n                    height: 24px;\n                }\n                \n                .reorder-success {\n                    top: 10px;\n                    right: 10px;\n                    left: 10px;\n                    text-align: center;\n                }\n            }\n        `;\n        \n        document.head.appendChild(styles);\n    }\n\n    setupEventListeners() {\n        // Prevent default drag behavior on images\n        document.addEventListener('dragstart', (e) => {\n            if (e.target.tagName === 'IMG') {\n                e.preventDefault();\n            }\n        });\n    }\n}\n\n// Course Management Drag-and-Drop\nclass CourseDragDrop extends DragDropManager {\n    constructor() {\n        super();\n        this.initializeCoursesDragDrop();\n    }\n\n    initializeCoursesDragDrop() {\n        this.initializeDragDrop(\n            '.courses-container, .course-list', \n            '.course-item, .course-card', \n            (newOrder) => this.updateCourseOrder(newOrder)\n        );\n    }\n\n    async updateCourseOrder(newOrder) {\n        const courseIds = newOrder.map(item => item.id);\n        \n        try {\n            this.showLoadingState();\n            \n            const response = await fetch('/api/reorder-courses', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    course_ids: courseIds\n                })\n            });\n\n            const result = await response.json();\n            \n            if (result.success) {\n                this.showSuccessAnimation();\n            } else {\n                this.showErrorMessage(result.message);\n                this.revertOrder();\n            }\n        } catch (error) {\n            console.error('Error updating course order:', error);\n            this.showErrorMessage('Failed to update course order');\n            this.revertOrder();\n        } finally {\n            this.hideLoadingState();\n        }\n    }\n\n    showLoadingState() {\n        if (this.container) {\n            this.container.classList.add('reordering');\n        }\n    }\n\n    hideLoadingState() {\n        if (this.container) {\n            this.container.classList.remove('reordering');\n        }\n    }\n\n    showErrorMessage(message) {\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'alert alert-danger';\n        errorDiv.textContent = message;\n        \n        if (this.container) {\n            this.container.insertBefore(errorDiv, this.container.firstChild);\n            setTimeout(() => {\n                errorDiv.remove();\n            }, 5000);\n        }\n    }\n\n    revertOrder() {\n        // Reload the page to revert changes\n        window.location.reload();\n    }\n}\n\n// Quiz Management Drag-and-Drop\nclass QuizDragDrop extends DragDropManager {\n    constructor(courseId = null) {\n        super();\n        this.courseId = courseId;\n        this.initializeQuizzesDragDrop();\n    }\n\n    initializeQuizzesDragDrop() {\n        this.initializeDragDrop(\n            '.quizzes-container, .quiz-list', \n            '.quiz-item, .quiz-card', \n            (newOrder) => this.updateQuizOrder(newOrder)\n        );\n    }\n\n    async updateQuizOrder(newOrder) {\n        const quizIds = newOrder.map(item => item.id);\n        \n        try {\n            this.showLoadingState();\n            \n            const response = await fetch('/api/reorder-quizzes', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    quiz_ids: quizIds,\n                    course_id: this.courseId\n                })\n            });\n\n            const result = await response.json();\n            \n            if (result.success) {\n                this.showSuccessAnimation();\n            } else {\n                this.showErrorMessage(result.message);\n                this.revertOrder();\n            }\n        } catch (error) {\n            console.error('Error updating quiz order:', error);\n            this.showErrorMessage('Failed to update quiz order');\n            this.revertOrder();\n        } finally {\n            this.hideLoadingState();\n        }\n    }\n\n    showLoadingState() {\n        if (this.container) {\n            this.container.classList.add('reordering');\n        }\n    }\n\n    hideLoadingState() {\n        if (this.container) {\n            this.container.classList.remove('reordering');\n        }\n    }\n\n    showErrorMessage(message) {\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'alert alert-danger';\n        errorDiv.textContent = message;\n        \n        if (this.container) {\n            this.container.insertBefore(errorDiv, this.container.firstChild);\n            setTimeout(() => {\n                errorDiv.remove();\n            }, 5000);\n        }\n    }\n\n    revertOrder() {\n        // Reload the page to revert changes\n        window.location.reload();\n    }\n}\n\n// Auto-initialize based on page context\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Initialize course drag-and-drop if course elements are present\n    if (document.querySelector('.courses-container, .course-list')) {\n        new CourseDragDrop();\n    }\n    \n    // Initialize quiz drag-and-drop if quiz elements are present\n    if (document.querySelector('.quizzes-container, .quiz-list')) {\n        const courseId = document.querySelector('[data-course-id]')?.dataset.courseId;\n        new QuizDragDrop(courseId);\n    }\n});\n\n// Export for external use\nwindow.DragDropManager = DragDropManager;\nwindow.CourseDragDrop = CourseDragDrop;\nwindow.QuizDragDrop = QuizDragDrop;","size_bytes":14678},"plagiarism_detector.py":{"content":"\"\"\"\nAI-Powered Plagiarism Detection Service for BigBossizzz Platform\n\nThis service uses multiple machine learning algorithms to detect plagiarism in text submissions:\n- TF-IDF Vectorization with Cosine Similarity\n- Jaccard Similarity for set-based comparison\n- Levenshtein Distance for string similarity  \n- N-gram analysis for structural patterns\n\"\"\"\n\nimport re\nimport string\nimport logging\nimport os\nfrom typing import List, Dict, Tuple, Optional\nfrom datetime import datetime\n\nimport nltk\nimport numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nimport textdistance\n\nfrom app import db\nfrom models import PlagiarismAnalysis, PlagiarismMatch, Answer\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass PlagiarismDetector:\n    \"\"\"Advanced AI-powered plagiarism detection system\"\"\"\n    \n    def __init__(self):\n        self.tfidf_vectorizer = TfidfVectorizer(\n            stop_words='english',\n            max_features=1000,\n            ngram_range=(1, 3),\n            lowercase=True,\n            strip_accents='unicode'\n        )\n        \n        # Configurable risk thresholds - Load from environment or use defaults\n        self.thresholds = {\n            'cosine_high': float(os.environ.get('PLAGIARISM_COSINE_HIGH', '0.8')),\n            'cosine_medium': float(os.environ.get('PLAGIARISM_COSINE_MEDIUM', '0.6')),\n            'cosine_low': float(os.environ.get('PLAGIARISM_COSINE_LOW', '0.4')),\n            'jaccard_high': float(os.environ.get('PLAGIARISM_JACCARD_HIGH', '0.7')),\n            'jaccard_medium': float(os.environ.get('PLAGIARISM_JACCARD_MEDIUM', '0.5')),\n            'jaccard_low': float(os.environ.get('PLAGIARISM_JACCARD_LOW', '0.3')),\n            'levenshtein_high': float(os.environ.get('PLAGIARISM_LEVENSHTEIN_HIGH', '0.85')),\n            'levenshtein_medium': float(os.environ.get('PLAGIARISM_LEVENSHTEIN_MEDIUM', '0.7')),\n            'levenshtein_low': float(os.environ.get('PLAGIARISM_LEVENSHTEIN_LOW', '0.5')),\n            'segment_threshold': float(os.environ.get('PLAGIARISM_SEGMENT_THRESHOLD', '0.6'))\n        }\n        \n        # Download required NLTK data - Fail fast if resources unavailable\n        try:\n            nltk.data.find('tokenizers/punkt')\n            nltk.data.find('corpora/stopwords')\n        except LookupError:\n            logger.error(\"NLTK data not available. Install with: python -m nltk.downloader punkt stopwords\")\n            raise RuntimeError(\"NLTK resources not available for plagiarism detection\")\n    \n    def preprocess_text(self, text: str) -> str:\n        \"\"\"Clean and normalize text for analysis\"\"\"\n        if not text:\n            return \"\"\n            \n        # Remove extra whitespace\n        text = re.sub(r'\\s+', ' ', text.strip())\n        \n        # Remove special characters but keep basic punctuation\n        text = re.sub(r'[^\\w\\s\\.\\,\\!\\?\\;\\:]', '', text)\n        \n        # Convert to lowercase\n        text = text.lower()\n        \n        return text\n    \n    def extract_ngrams(self, text: str, n: int = 3) -> set:\n        \"\"\"Extract n-grams from text for structural analysis\"\"\"\n        words = text.split()\n        ngrams = set()\n        \n        for i in range(len(words) - n + 1):\n            ngram = tuple(words[i:i+n])\n            ngrams.add(ngram)\n            \n        return ngrams\n    \n    def calculate_cosine_similarity(self, text1: str, text2: str) -> float:\n        \"\"\"Calculate cosine similarity using TF-IDF vectors\"\"\"\n        try:\n            corpus = [text1, text2]\n            tfidf_matrix = self.tfidf_vectorizer.fit_transform(corpus)\n            similarity = cosine_similarity(tfidf_matrix[0:1], tfidf_matrix[1:2])[0][0]\n            return float(similarity)\n        except Exception as e:\n            logger.error(f\"Error calculating cosine similarity: {e}\")\n            return 0.0\n    \n    def calculate_jaccard_similarity(self, text1: str, text2: str) -> float:\n        \"\"\"Calculate Jaccard similarity coefficient\"\"\"\n        try:\n            set1 = set(text1.split())\n            set2 = set(text2.split())\n            \n            intersection = len(set1.intersection(set2))\n            union = len(set1.union(set2))\n            \n            if union == 0:\n                return 0.0\n                \n            return intersection / union\n        except Exception as e:\n            logger.error(f\"Error calculating Jaccard similarity: {e}\")\n            return 0.0\n    \n    def calculate_levenshtein_similarity(self, text1: str, text2: str) -> float:\n        \"\"\"Calculate normalized Levenshtein similarity\"\"\"\n        try:\n            distance = textdistance.levenshtein(text1, text2)\n            max_len = max(len(text1), len(text2))\n            \n            if max_len == 0:\n                return 1.0\n                \n            similarity = 1 - (distance / max_len)\n            return max(0.0, similarity)\n        except Exception as e:\n            logger.error(f\"Error calculating Levenshtein similarity: {e}\")\n            return 0.0\n    \n    def calculate_semantic_similarity(self, text1: str, text2: str) -> float:\n        \"\"\"Calculate semantic similarity using n-gram overlap\"\"\"\n        try:\n            ngrams1 = self.extract_ngrams(text1)\n            ngrams2 = self.extract_ngrams(text2)\n            \n            if not ngrams1 or not ngrams2:\n                return 0.0\n                \n            intersection = len(ngrams1.intersection(ngrams2))\n            union = len(ngrams1.union(ngrams2))\n            \n            return intersection / union if union > 0 else 0.0\n        except Exception as e:\n            logger.error(f\"Error calculating semantic similarity: {e}\")\n            return 0.0\n    \n    def determine_risk_level(self, cosine: float, jaccard: float, levenshtein: float, semantic: float) -> Tuple[str, float, float]:\n        \"\"\"Determine overall risk level and confidence\"\"\"\n        \n        # Calculate weighted overall score\n        weights = {\n            'cosine': 0.4,      # Strongest indicator for academic plagiarism\n            'jaccard': 0.25,    # Good for exact word matches\n            'levenshtein': 0.2, # Character-level similarity\n            'semantic': 0.15    # Structural patterns\n        }\n        \n        overall_score = (\n            cosine * weights['cosine'] +\n            jaccard * weights['jaccard'] +\n            levenshtein * weights['levenshtein'] +\n            semantic * weights['semantic']\n        )\n        \n        # Determine risk level\n        if overall_score >= 0.75:\n            risk_level = 'critical'\n        elif overall_score >= 0.60:\n            risk_level = 'high'\n        elif overall_score >= 0.40:\n            risk_level = 'medium'\n        else:\n            risk_level = 'low'\n        \n        # Calculate confidence based on algorithm agreement\n        scores = [cosine, jaccard, levenshtein, semantic]\n        score_variance = float(np.var(scores))\n        confidence = 1.0 - min(score_variance, 1.0)  # Lower variance = higher confidence\n        \n        return risk_level, overall_score, confidence\n    \n    def find_matching_segments(self, text1: str, text2: str, threshold: float = None) -> List[Dict]:\n        \"\"\"Find specific text segments that match between two texts\"\"\"\n        if threshold is None:\n            threshold = self.thresholds['segment_threshold']\n        matches = []\n        \n        # Split into sentences for more granular analysis\n        sentences1 = nltk.sent_tokenize(text1)\n        sentences2 = nltk.sent_tokenize(text2)\n        \n        for i, sent1 in enumerate(sentences1):\n            for j, sent2 in enumerate(sentences2):\n                similarity = self.calculate_cosine_similarity(sent1, sent2)\n                \n                if similarity >= threshold:\n                    match = {\n                        'similarity': similarity,\n                        'text1_segment': sent1,\n                        'text2_segment': sent2,\n                        'text1_position': text1.find(sent1),\n                        'text2_position': text2.find(sent2),\n                        'match_type': self._classify_match_type(sent1, sent2, similarity)\n                    }\n                    matches.append(match)\n        \n        return matches\n    \n    def _classify_match_type(self, text1: str, text2: str, similarity: float) -> str:\n        \"\"\"Classify the type of match found\"\"\"\n        if similarity >= 0.95:\n            return 'exact'\n        elif similarity >= 0.8:\n            # Check if it's just paraphrasing\n            jaccard = self.calculate_jaccard_similarity(text1, text2)\n            if jaccard >= 0.7:\n                return 'paraphrase'\n            else:\n                return 'structural'\n        else:\n            return 'semantic'\n    \n    def analyze_text_for_plagiarism(self, target_text: str, comparison_texts: List[Tuple[int, str]], answer_id: int, quiz_attempt_id: int, question_id: int) -> PlagiarismAnalysis:\n        \"\"\"\n        Analyze target text against a corpus of comparison texts for plagiarism\n        \n        Args:\n            target_text: The text to analyze\n            comparison_texts: List of tuples (answer_id, text) to compare against\n            answer_id: ID of the answer being analyzed\n            quiz_attempt_id: ID of the quiz attempt\n            question_id: ID of the question\n            \n        Returns:\n            PlagiarismAnalysis object with results\n        \"\"\"\n        \n        logger.info(f\"Starting plagiarism analysis for answer {answer_id}\")\n        \n        # Preprocess target text\n        clean_target = self.preprocess_text(target_text)\n        \n        if not clean_target.strip():\n            logger.warning(f\"Empty text for answer {answer_id}\")\n            # Create analysis for empty text\n            analysis = PlagiarismAnalysis()\n            analysis.quiz_attempt_id = quiz_attempt_id\n            analysis.question_id = question_id\n            analysis.answer_id = answer_id\n            analysis.overall_similarity_score = 0.0\n            analysis.risk_level = 'low'\n            analysis.cosine_similarity = 0.0\n            analysis.jaccard_similarity = 0.0\n            analysis.levenshtein_similarity = 0.0\n            analysis.semantic_similarity = 0.0\n            analysis.analyzed_text = target_text\n            analysis.confidence_score = 1.0\n            analysis.is_flagged = False\n            analysis.requires_review = False\n            return analysis\n        \n        max_similarities = {\n            'cosine': 0.0,\n            'jaccard': 0.0,\n            'levenshtein': 0.0,\n            'semantic': 0.0\n        }\n        \n        all_matches = []\n        \n        # Compare against all provided texts\n        for comp_answer_id, comp_text in comparison_texts:\n            if comp_answer_id == answer_id:  # Skip self-comparison\n                continue\n                \n            clean_comp = self.preprocess_text(comp_text)\n            \n            if not clean_comp.strip():\n                continue\n            \n            # Calculate all similarity metrics\n            cosine_sim = self.calculate_cosine_similarity(clean_target, clean_comp)\n            jaccard_sim = self.calculate_jaccard_similarity(clean_target, clean_comp)\n            levenshtein_sim = self.calculate_levenshtein_similarity(clean_target, clean_comp)\n            semantic_sim = self.calculate_semantic_similarity(clean_target, clean_comp)\n            \n            # Track maximum similarities\n            max_similarities['cosine'] = max(max_similarities['cosine'], cosine_sim)\n            max_similarities['jaccard'] = max(max_similarities['jaccard'], jaccard_sim)\n            max_similarities['levenshtein'] = max(max_similarities['levenshtein'], levenshtein_sim)\n            max_similarities['semantic'] = max(max_similarities['semantic'], semantic_sim)\n            \n            # Find specific matching segments if similarity is high\n            segment_threshold = self.thresholds['segment_threshold']\n            if cosine_sim >= segment_threshold:  # Only store matches above threshold\n                segments = self.find_matching_segments(clean_target, clean_comp, threshold=segment_threshold)\n                \n                for segment in segments:\n                    match = PlagiarismMatch()\n                    match.matched_against_id = comp_answer_id\n                    match.similarity_score = segment['similarity']\n                    match.match_type = segment['match_type']\n                    match.matched_text_segment = segment['text1_segment']\n                    match.original_text_segment = segment['text2_segment']\n                    match.start_position = segment['text1_position']\n                    match.end_position = segment['text1_position'] + len(segment['text1_segment'])\n                    match.algorithm_used = 'tfidf_cosine'\n                    match.confidence = cosine_sim\n                    all_matches.append(match)\n        \n        # Determine overall risk and confidence\n        risk_level, overall_score, confidence = self.determine_risk_level(\n            max_similarities['cosine'],\n            max_similarities['jaccard'],\n            max_similarities['levenshtein'],\n            max_similarities['semantic']\n        )\n        \n        # Determine if flagging is needed\n        is_flagged = risk_level in ['high', 'critical']\n        requires_review = risk_level in ['medium', 'high', 'critical']\n        \n        # Create plagiarism analysis record\n        analysis = PlagiarismAnalysis()\n        analysis.quiz_attempt_id = quiz_attempt_id\n        analysis.question_id = question_id\n        analysis.answer_id = answer_id\n        analysis.overall_similarity_score = overall_score\n        analysis.risk_level = risk_level\n        analysis.cosine_similarity = max_similarities['cosine']\n        analysis.jaccard_similarity = max_similarities['jaccard']\n        analysis.levenshtein_similarity = max_similarities['levenshtein']\n        analysis.semantic_similarity = max_similarities['semantic']\n        analysis.analyzed_text = target_text\n        analysis.confidence_score = confidence\n        analysis.is_flagged = is_flagged\n        analysis.requires_review = requires_review\n        \n        # Save analysis first to get ID\n        db.session.add(analysis)\n        db.session.flush()\n        \n        # Add matches to analysis\n        for match in all_matches:\n            match.analysis_id = analysis.id\n            db.session.add(match)\n        \n        logger.info(f\"Plagiarism analysis completed for answer {answer_id}: {risk_level} risk ({overall_score:.3f} similarity)\")\n        \n        return analysis\n\n# Global instance for use throughout the application\nplagiarism_detector = PlagiarismDetector()","size_bytes":14776},"static/js/advanced-questions.js":{"content":"/**\n * Advanced Question Types JavaScript Module\n * Handles Code Submission, File Upload, and Drawing question types\n */\n\nclass AdvancedQuestionHandler {\n    constructor() {\n        this.codeEditors = new Map();\n        this.canvases = new Map();\n        this.uploadedFiles = new Map();\n        this.init();\n    }\n\n    init() {\n        this.setupQuestionTypeHandlers();\n        this.setupCodeEditors();\n        this.setupDrawingCanvases();\n        this.setupFileUploads();\n    }\n\n    setupQuestionTypeHandlers() {\n        // Handle question type changes in forms\n        const questionTypeSelects = document.querySelectorAll('select[name*=\"question_type\"]');\n        \n        questionTypeSelects.forEach(select => {\n            select.addEventListener('change', (e) => {\n                this.toggleAdvancedFields(e.target);\n            });\n            \n            // Initialize on page load\n            this.toggleAdvancedFields(select);\n        });\n    }\n\n    toggleAdvancedFields(selectElement) {\n        const questionType = selectElement.value;\n        const container = selectElement.closest('.question-container') || selectElement.closest('form');\n        \n        if (!container) return;\n\n        // Hide all advanced fields first\n        this.hideAllAdvancedFields(container);\n\n        // Show relevant fields based on question type\n        switch (questionType) {\n            case 'code_submission':\n                this.showCodeSubmissionFields(container);\n                break;\n            case 'file_upload':\n                this.showFileUploadFields(container);\n                break;\n            case 'drawing':\n                this.showDrawingFields(container);\n                break;\n        }\n    }\n\n    hideAllAdvancedFields(container) {\n        const advancedFields = [\n            '.code-submission-fields',\n            '.file-upload-fields', \n            '.drawing-fields',\n            '.multiple-choice-fields'\n        ];\n\n        advancedFields.forEach(selector => {\n            const field = container.querySelector(selector);\n            if (field) {\n                field.style.display = 'none';\n            }\n        });\n    }\n\n    showCodeSubmissionFields(container) {\n        const codeFields = container.querySelector('.code-submission-fields');\n        if (codeFields) {\n            codeFields.style.display = 'block';\n            this.initializeCodeEditor(container);\n        }\n    }\n\n    showFileUploadFields(container) {\n        const fileFields = container.querySelector('.file-upload-fields');\n        if (fileFields) {\n            fileFields.style.display = 'block';\n        }\n    }\n\n    showDrawingFields(container) {\n        const drawingFields = container.querySelector('.drawing-fields');\n        if (drawingFields) {\n            drawingFields.style.display = 'block';\n            this.initializeDrawingCanvas(container);\n        }\n    }\n\n    initializeCodeEditor(container) {\n        const codeTextarea = container.querySelector('textarea[name*=\"starter_code\"]');\n        if (!codeTextarea || this.codeEditors.has(codeTextarea.id)) return;\n\n        // Create a simple code editor with syntax highlighting\n        const editorWrapper = document.createElement('div');\n        editorWrapper.className = 'code-editor-wrapper';\n        editorWrapper.innerHTML = `\n            <div class=\"editor-toolbar\">\n                <select class=\"language-selector form-select form-select-sm\">\n                    <option value=\"python\">Python</option>\n                    <option value=\"javascript\">JavaScript</option>\n                    <option value=\"java\">Java</option>\n                    <option value=\"cpp\">C++</option>\n                    <option value=\"sql\">SQL</option>\n                </select>\n                <span class=\"editor-label\">Starter Code:</span>\n            </div>\n            <div class=\"code-editor\" contenteditable=\"true\" style=\"\n                font-family: 'Courier New', monospace;\n                background: #f8f9fa;\n                border: 1px solid #dee2e6;\n                border-radius: 4px;\n                padding: 10px;\n                min-height: 200px;\n                white-space: pre;\n                overflow-x: auto;\n            \"></div>\n        `;\n\n        codeTextarea.style.display = 'none';\n        codeTextarea.parentNode.insertBefore(editorWrapper, codeTextarea.nextSibling);\n\n        const editor = editorWrapper.querySelector('.code-editor');\n        const languageSelect = editorWrapper.querySelector('.language-selector');\n\n        // Sync content between editor and textarea\n        editor.addEventListener('input', () => {\n            codeTextarea.value = editor.textContent;\n        });\n\n        // Update language selection\n        languageSelect.addEventListener('change', () => {\n            const programmingLanguageSelect = container.querySelector('select[name*=\"programming_language\"]');\n            if (programmingLanguageSelect) {\n                programmingLanguageSelect.value = languageSelect.value;\n            }\n        });\n\n        // Store editor reference\n        this.codeEditors.set(codeTextarea.id, {\n            editor: editor,\n            textarea: codeTextarea,\n            languageSelect: languageSelect\n        });\n    }\n\n    initializeDrawingCanvas(container) {\n        const canvasContainer = container.querySelector('.drawing-canvas-container');\n        if (!canvasContainer) return;\n\n        const canvas = document.createElement('canvas');\n        canvas.width = 800;\n        canvas.height = 600;\n        canvas.style.border = '2px solid #dee2e6';\n        canvas.style.borderRadius = '4px';\n        canvas.style.backgroundColor = 'white';\n        canvas.style.cursor = 'crosshair';\n\n        const toolbar = document.createElement('div');\n        toolbar.className = 'drawing-toolbar mb-2';\n        toolbar.innerHTML = `\n            <div class=\"btn-group\" role=\"group\">\n                <button type=\"button\" class=\"btn btn-outline-primary tool-btn active\" data-tool=\"pen\">\n                    <i class=\"fas fa-pen\"></i> Pen\n                </button>\n                <button type=\"button\" class=\"btn btn-outline-primary tool-btn\" data-tool=\"eraser\">\n                    <i class=\"fas fa-eraser\"></i> Eraser\n                </button>\n                <button type=\"button\" class=\"btn btn-outline-primary tool-btn\" data-tool=\"line\">\n                    <i class=\"fas fa-minus\"></i> Line\n                </button>\n                <button type=\"button\" class=\"btn btn-outline-primary tool-btn\" data-tool=\"rectangle\">\n                    <i class=\"fas fa-square\"></i> Rectangle\n                </button>\n                <button type=\"button\" class=\"btn btn-outline-primary tool-btn\" data-tool=\"circle\">\n                    <i class=\"fas fa-circle\"></i> Circle\n                </button>\n            </div>\n            <div class=\"ms-3\">\n                <label>Color:</label>\n                <input type=\"color\" class=\"color-picker ms-1\" value=\"#000000\">\n                <label class=\"ms-2\">Size:</label>\n                <input type=\"range\" class=\"brush-size ms-1\" min=\"1\" max=\"20\" value=\"3\">\n            </div>\n            <button type=\"button\" class=\"btn btn-warning ms-3 clear-canvas\">\n                <i class=\"fas fa-trash\"></i> Clear\n            </button>\n        `;\n\n        canvasContainer.innerHTML = '';\n        canvasContainer.appendChild(toolbar);\n        canvasContainer.appendChild(canvas);\n\n        // Initialize drawing functionality\n        this.setupDrawingEvents(canvas, toolbar, container);\n        \n        // Store canvas reference\n        const questionId = container.dataset.questionId || 'new';\n        this.canvases.set(questionId, canvas);\n    }\n\n    setupDrawingEvents(canvas, toolbar, container) {\n        const ctx = canvas.getContext('2d');\n        let isDrawing = false;\n        let currentTool = 'pen';\n        let currentColor = '#000000';\n        let currentSize = 3;\n        let startX, startY;\n\n        // Tool selection\n        toolbar.querySelectorAll('.tool-btn').forEach(btn => {\n            btn.addEventListener('click', () => {\n                toolbar.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));\n                btn.classList.add('active');\n                currentTool = btn.dataset.tool;\n            });\n        });\n\n        // Color and size controls\n        const colorPicker = toolbar.querySelector('.color-picker');\n        const brushSize = toolbar.querySelector('.brush-size');\n        \n        colorPicker.addEventListener('change', (e) => {\n            currentColor = e.target.value;\n        });\n\n        brushSize.addEventListener('input', (e) => {\n            currentSize = parseInt(e.target.value);\n        });\n\n        // Clear canvas\n        toolbar.querySelector('.clear-canvas').addEventListener('click', () => {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            this.saveCanvasData(canvas, container);\n        });\n\n        // Drawing events\n        canvas.addEventListener('mousedown', (e) => {\n            isDrawing = true;\n            const rect = canvas.getBoundingClientRect();\n            startX = e.clientX - rect.left;\n            startY = e.clientY - rect.top;\n\n            ctx.beginPath();\n            ctx.strokeStyle = currentColor;\n            ctx.lineWidth = currentSize;\n            ctx.lineCap = 'round';\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            if (!isDrawing) return;\n\n            const rect = canvas.getBoundingClientRect();\n            const currentX = e.clientX - rect.left;\n            const currentY = e.clientY - rect.top;\n\n            switch (currentTool) {\n                case 'pen':\n                    ctx.lineTo(currentX, currentY);\n                    ctx.stroke();\n                    break;\n                case 'eraser':\n                    ctx.globalCompositeOperation = 'destination-out';\n                    ctx.arc(currentX, currentY, currentSize, 0, Math.PI * 2);\n                    ctx.fill();\n                    ctx.globalCompositeOperation = 'source-over';\n                    break;\n            }\n        });\n\n        canvas.addEventListener('mouseup', (e) => {\n            if (!isDrawing) return;\n            isDrawing = false;\n\n            const rect = canvas.getBoundingClientRect();\n            const endX = e.clientX - rect.left;\n            const endY = e.clientY - rect.top;\n\n            switch (currentTool) {\n                case 'line':\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                    break;\n                case 'rectangle':\n                    ctx.beginPath();\n                    ctx.rect(startX, startY, endX - startX, endY - startY);\n                    ctx.stroke();\n                    break;\n                case 'circle':\n                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));\n                    ctx.beginPath();\n                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);\n                    ctx.stroke();\n                    break;\n            }\n\n            // Save canvas data after drawing\n            this.saveCanvasData(canvas, container);\n        });\n    }\n\n    saveCanvasData(canvas, container) {\n        const imageData = canvas.toDataURL('image/png');\n        const hiddenInput = container.querySelector('input[name*=\"drawing_data\"]') || \n                           this.createHiddenInput(container, 'drawing_data', '');\n        hiddenInput.value = imageData;\n    }\n\n    setupFileUploads() {\n        const fileInputs = document.querySelectorAll('input[type=\"file\"][data-question-type=\"file_upload\"]');\n        \n        fileInputs.forEach(input => {\n            input.addEventListener('change', (e) => {\n                this.handleFileUpload(e.target);\n            });\n        });\n    }\n\n    handleFileUpload(input) {\n        const file = input.files[0];\n        if (!file) return;\n\n        const container = input.closest('.question-container') || input.closest('form');\n        const preview = container.querySelector('.file-upload-preview') || \n                       this.createFilePreview(container, input);\n\n        // Validate file type and size\n        const allowedTypes = input.dataset.allowedTypes ? \n                           input.dataset.allowedTypes.split(',') : \n                           ['pdf', 'docx', 'jpg', 'png', 'txt'];\n        \n        const maxSize = parseInt(input.dataset.maxSize || '10') * 1024 * 1024; // Convert MB to bytes\n        const fileExt = file.name.split('.').pop().toLowerCase();\n\n        if (!allowedTypes.includes(fileExt)) {\n            preview.innerHTML = `\n                <div class=\"alert alert-danger\">\n                    <i class=\"fas fa-exclamation-triangle\"></i>\n                    Invalid file type. Allowed: ${allowedTypes.join(', ')}\n                </div>\n            `;\n            input.value = '';\n            return;\n        }\n\n        if (file.size > maxSize) {\n            preview.innerHTML = `\n                <div class=\"alert alert-danger\">\n                    <i class=\"fas fa-exclamation-triangle\"></i>\n                    File too large. Maximum size: ${input.dataset.maxSize || '10'}MB\n                </div>\n            `;\n            input.value = '';\n            return;\n        }\n\n        // Show file preview\n        preview.innerHTML = `\n            <div class=\"alert alert-success\">\n                <i class=\"fas fa-file\"></i>\n                <strong>${file.name}</strong> (${this.formatFileSize(file.size)})\n                <button type=\"button\" class=\"btn btn-sm btn-outline-danger ms-2 remove-file\">\n                    <i class=\"fas fa-times\"></i>\n                </button>\n            </div>\n        `;\n\n        // Add remove functionality\n        preview.querySelector('.remove-file').addEventListener('click', () => {\n            input.value = '';\n            preview.innerHTML = '';\n        });\n\n        // Store file reference\n        this.uploadedFiles.set(input.name, file);\n    }\n\n    createFilePreview(container, input) {\n        const preview = document.createElement('div');\n        preview.className = 'file-upload-preview mt-2';\n        input.parentNode.insertBefore(preview, input.nextSibling);\n        return preview;\n    }\n\n    createHiddenInput(container, name, value) {\n        const input = document.createElement('input');\n        input.type = 'hidden';\n        input.name = name;\n        input.value = value;\n        container.appendChild(input);\n        return input;\n    }\n\n    formatFileSize(bytes) {\n        if (bytes === 0) return '0 Bytes';\n        const k = 1024;\n        const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n\n    // Public methods for form validation\n    validateCodeSubmission(questionId) {\n        const editor = this.codeEditors.get(questionId);\n        if (editor && editor.textarea.value.trim() === '') {\n            return { valid: false, message: 'Please provide code for this question.' };\n        }\n        return { valid: true };\n    }\n\n    validateFileUpload(questionId) {\n        const fileInput = document.querySelector(`input[name=\"file_${questionId}\"]`);\n        if (fileInput && (!fileInput.files || fileInput.files.length === 0)) {\n            return { valid: false, message: 'Please upload a file for this question.' };\n        }\n        return { valid: true };\n    }\n\n    validateDrawing(questionId) {\n        const canvas = this.canvases.get(questionId);\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            const hasDrawing = imageData.data.some(channel => channel !== 0);\n            \n            if (!hasDrawing) {\n                return { valid: false, message: 'Please create a drawing for this question.' };\n            }\n        }\n        return { valid: true };\n    }\n}\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.advancedQuestionHandler = new AdvancedQuestionHandler();\n});\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = AdvancedQuestionHandler;\n}","size_bytes":16397},"lti_integration.py":{"content":"\"\"\"\nLTI (Learning Tools Interoperability) Integration Module\nProvides LTI 1.1 and LTI 1.3 support for Canvas, Blackboard, Moodle integration\n\"\"\"\n\nimport hashlib\nimport hmac\nimport time\nimport uuid\nimport base64\nimport urllib.parse\nimport json\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional, Tuple\n\nimport requests\nfrom flask import request, session, url_for, redirect, jsonify\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nfrom app import db\nfrom models import User, Quiz, QuizAttempt\n\n# LTI Configuration\nclass LTIConfig:\n    # LTI 1.1 Parameters\n    LTI_VERSION = \"LTI-1p0\"\n    LTI_MESSAGE_TYPE = \"basic-lti-launch-request\"\n    \n    # LTI 1.3 Parameters\n    LTI_13_VERSION = \"1.3.0\"\n    LTI_13_MESSAGE_TYPE = \"LtiResourceLinkRequest\"\n    \n    # Supported LMS platforms\n    SUPPORTED_PLATFORMS = {\n        'canvas': {\n            'name': 'Canvas',\n            'oauth_url_template': 'https://{domain}/api/lti/authorize_redirect',\n            'token_url_template': 'https://{domain}/login/oauth2/token',\n            'grade_passback_url_template': 'https://{domain}/api/lti/v1/tools/{tool_id}/grade_passback'\n        },\n        'blackboard': {\n            'name': 'Blackboard Learn',\n            'oauth_url_template': 'https://{domain}/webapps/bb-auth-provider-sso/execute/authorizeRequest',\n            'token_url_template': 'https://{domain}/learn/api/public/v1/oauth2/token',\n            'grade_passback_url_template': 'https://{domain}/learn/api/public/v1/courses/{course_id}/gradebook/columns/{column_id}/attempts/{attempt_id}'\n        },\n        'moodle': {\n            'name': 'Moodle',\n            'oauth_url_template': 'https://{domain}/mod/lti/auth.php',\n            'token_url_template': 'https://{domain}/mod/lti/token.php',\n            'grade_passback_url_template': 'https://{domain}/mod/lti/service.php'\n        }\n    }\n\nclass LTIProvider:\n    \"\"\"LTI Provider implementation for accepting launches from LMS\"\"\"\n    \n    def __init__(self, consumer_key: str, consumer_secret: str):\n        self.consumer_key = consumer_key\n        self.consumer_secret = consumer_secret\n        \n    def validate_signature(self, request_data: Dict) -> bool:\n        \"\"\"Validate OAuth 1.0 signature for LTI 1.1 requests\"\"\"\n        try:\n            # Extract signature from request\n            oauth_signature = request_data.get('oauth_signature', '')\n            if not oauth_signature:\n                return False\n            \n            # Remove signature from parameters for validation\n            params = {k: v for k, v in request_data.items() if k != 'oauth_signature'}\n            \n            # Create base string\n            base_string = self._create_base_string('POST', request.url_root.rstrip('/') + '/lti/launch', params)\n            \n            # Create signing key\n            signing_key = f\"{urllib.parse.quote_plus(self.consumer_secret)}&\"\n            \n            # Calculate expected signature\n            expected_signature = base64.b64encode(\n                hmac.new(signing_key.encode(), base_string.encode(), hashlib.sha1).digest()\n            ).decode()\n            \n            return hmac.compare_digest(oauth_signature, expected_signature)\n            \n        except Exception as e:\n            logging.error(f\"LTI signature validation error: {e}\")\n            return False\n    \n    def _create_base_string(self, method: str, url: str, params: Dict) -> str:\n        \"\"\"Create OAuth base string for signature validation\"\"\"\n        # Normalize parameters\n        normalized_params = []\n        for key, value in sorted(params.items()):\n            normalized_params.append(f\"{urllib.parse.quote_plus(str(key))}={urllib.parse.quote_plus(str(value))}\")\n        \n        param_string = \"&\".join(normalized_params)\n        \n        return f\"{method}&{urllib.parse.quote_plus(url)}&{urllib.parse.quote_plus(param_string)}\"\n    \n    def process_launch_request(self, request_data: Dict) -> Tuple[bool, Dict]:\n        \"\"\"Process LTI launch request and extract user/context information\"\"\"\n        try:\n            # Validate required LTI parameters\n            required_params = [\n                'lti_message_type', 'lti_version', 'resource_link_id',\n                'user_id', 'oauth_consumer_key'\n            ]\n            \n            for param in required_params:\n                if param not in request_data:\n                    return False, {'error': f'Missing required parameter: {param}'}\n            \n            # Validate message type and version\n            if request_data.get('lti_message_type') != LTIConfig.LTI_MESSAGE_TYPE:\n                return False, {'error': 'Invalid LTI message type'}\n            \n            if request_data.get('lti_version') != LTIConfig.LTI_VERSION:\n                return False, {'error': 'Unsupported LTI version'}\n            \n            # Validate consumer key\n            if request_data.get('oauth_consumer_key') != self.consumer_key:\n                return False, {'error': 'Invalid consumer key'}\n            \n            # Extract user information\n            user_info = {\n                'lti_user_id': request_data.get('user_id'),\n                'username': request_data.get('lis_person_sourcedid', ''),\n                'email': request_data.get('lis_person_contact_email_primary', ''),\n                'first_name': request_data.get('lis_person_name_given', ''),\n                'last_name': request_data.get('lis_person_name_family', ''),\n                'full_name': request_data.get('lis_person_name_full', ''),\n                'roles': request_data.get('roles', '').split(',')\n            }\n            \n            # Extract context information\n            context_info = {\n                'course_id': request_data.get('context_id', ''),\n                'course_title': request_data.get('context_title', ''),\n                'resource_link_id': request_data.get('resource_link_id'),\n                'resource_link_title': request_data.get('resource_link_title', ''),\n                'resource_link_description': request_data.get('resource_link_description', ''),\n                'tool_consumer_instance_guid': request_data.get('tool_consumer_instance_guid', ''),\n                'tool_consumer_instance_name': request_data.get('tool_consumer_instance_name', ''),\n            }\n            \n            # Extract grade passback information\n            grade_info = {\n                'lis_outcome_service_url': request_data.get('lis_outcome_service_url', ''),\n                'lis_result_sourcedid': request_data.get('lis_result_sourcedid', ''),\n                'lis_person_sourcedid': request_data.get('lis_person_sourcedid', '')\n            }\n            \n            return True, {\n                'user_info': user_info,\n                'context_info': context_info,\n                'grade_info': grade_info,\n                'custom_params': {k: v for k, v in request_data.items() if k.startswith('custom_')}\n            }\n            \n        except Exception as e:\n            logging.error(f\"LTI launch processing error: {e}\")\n            return False, {'error': f'Launch processing failed: {str(e)}'}\n\nclass LTIUser:\n    \"\"\"Manages LTI user provisioning and authentication\"\"\"\n    \n    @staticmethod\n    def create_or_update_user(lti_data: Dict) -> Optional[User]:\n        \"\"\"Create or update user from LTI launch data\"\"\"\n        try:\n            user_info = lti_data.get('user_info', {})\n            lti_user_id = user_info.get('lti_user_id')\n            email = user_info.get('email')\n            \n            if not lti_user_id:\n                return None\n            \n            # Check if user exists by LTI user ID or email\n            user = User.query.filter(\n                (User.lti_user_id == lti_user_id) | \n                (User.email == email and email != '')\n            ).first()\n            \n            if user:\n                # Update existing user\n                user.lti_user_id = lti_user_id\n                if email and not user.email:\n                    user.email = email\n                if user_info.get('username') and not user.username:\n                    user.username = user_info.get('username')\n            else:\n                # Create new user\n                username = user_info.get('username') or f\"lti_user_{lti_user_id}\"\n                email = email or f\"{username}@lti.local\"\n                \n                # Determine user role based on LTI roles\n                roles = user_info.get('roles', [])\n                role = 'participant'  # default\n                \n                if any(r.lower() in ['instructor', 'teacher', 'administrator'] for r in roles):\n                    role = 'host'\n                elif any(r.lower() in ['admin', 'administrator'] for r in roles):\n                    role = 'admin'\n                \n                user = User(\n                    username=username,\n                    email=email,\n                    role=role,\n                    lti_user_id=lti_user_id,\n                    is_verified=True,  # LTI users are pre-verified\n                    password_hash=generate_password_hash(str(uuid.uuid4()))  # Random password\n                )\n                \n                db.session.add(user)\n            \n            db.session.commit()\n            return user\n            \n        except Exception as e:\n            logging.error(f\"LTI user creation error: {e}\")\n            db.session.rollback()\n            return None\n\nclass LTIGradePassback:\n    \"\"\"Handles grade passback to LMS\"\"\"\n    \n    def __init__(self, consumer_key: str, consumer_secret: str):\n        self.consumer_key = consumer_key\n        self.consumer_secret = consumer_secret\n    \n    def send_grade(self, grade_info: Dict, score: float, max_score: float = 100.0) -> bool:\n        \"\"\"Send grade back to LMS via LTI grade passback\"\"\"\n        try:\n            service_url = grade_info.get('lis_outcome_service_url')\n            source_id = grade_info.get('lis_result_sourcedid')\n            \n            if not service_url or not source_id:\n                logging.warning(\"Missing grade passback information\")\n                return False\n            \n            # Calculate normalized score (0.0 to 1.0)\n            normalized_score = min(max(score / max_score, 0.0), 1.0)\n            \n            # Create XML payload for grade passback\n            xml_payload = self._create_grade_xml(source_id, normalized_score)\n            \n            # Create OAuth parameters\n            oauth_params = {\n                'oauth_callback': 'about:blank',\n                'oauth_consumer_key': self.consumer_key,\n                'oauth_nonce': str(uuid.uuid4()),\n                'oauth_signature_method': 'HMAC-SHA1',\n                'oauth_timestamp': str(int(time.time())),\n                'oauth_version': '1.0'\n            }\n            \n            # Create base string and signature\n            base_string = self._create_base_string('POST', service_url, oauth_params)\n            signing_key = f\"{urllib.parse.quote_plus(self.consumer_secret)}&\"\n            signature = base64.b64encode(\n                hmac.new(signing_key.encode(), base_string.encode(), hashlib.sha1).digest()\n            ).decode()\n            \n            oauth_params['oauth_signature'] = signature\n            \n            # Create Authorization header\n            auth_header = 'OAuth ' + ', '.join([f'{k}=\"{v}\"' for k, v in oauth_params.items()])\n            \n            # Send grade passback request\n            headers = {\n                'Authorization': auth_header,\n                'Content-Type': 'application/xml'\n            }\n            \n            response = requests.post(service_url, data=xml_payload, headers=headers, timeout=30)\n            \n            if response.status_code == 200:\n                logging.info(f\"Grade passback successful for source_id: {source_id}\")\n                return True\n            else:\n                logging.error(f\"Grade passback failed: {response.status_code} - {response.text}\")\n                return False\n                \n        except Exception as e:\n            logging.error(f\"Grade passback error: {e}\")\n            return False\n    \n    def _create_grade_xml(self, source_id: str, score: float) -> str:\n        \"\"\"Create XML payload for LTI grade passback\"\"\"\n        return f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<imsx_POXEnvelopeRequest xmlns=\"http://www.imsglobal.org/services/ltiv1p1/xsd/imsoms_v1p0\">\n    <imsx_POXHeader>\n        <imsx_POXRequestHeaderInfo>\n            <imsx_version>V1.0</imsx_version>\n            <imsx_messageIdentifier>{uuid.uuid4()}</imsx_messageIdentifier>\n        </imsx_POXRequestHeaderInfo>\n    </imsx_POXHeader>\n    <imsx_POXBody>\n        <replaceResultRequest>\n            <resultRecord>\n                <sourcedGUID>\n                    <sourcedId>{source_id}</sourcedId>\n                </sourcedGUID>\n                <result>\n                    <resultScore>\n                        <language>en</language>\n                        <textString>{score:.6f}</textString>\n                    </resultScore>\n                </result>\n            </resultRecord>\n        </replaceResultRequest>\n    </imsx_POXBody>\n</imsx_POXEnvelopeRequest>\"\"\"\n    \n    def _create_base_string(self, method: str, url: str, params: Dict) -> str:\n        \"\"\"Create OAuth base string for signature\"\"\"\n        normalized_params = []\n        for key, value in sorted(params.items()):\n            normalized_params.append(f\"{urllib.parse.quote_plus(str(key))}={urllib.parse.quote_plus(str(value))}\")\n        \n        param_string = \"&\".join(normalized_params)\n        return f\"{method}&{urllib.parse.quote_plus(url)}&{urllib.parse.quote_plus(param_string)}\"\n\nclass LTIToolConfiguration:\n    \"\"\"Generates LTI tool configuration for LMS setup\"\"\"\n    \n    @staticmethod\n    def generate_xml_config(base_url: str, consumer_key: str, title: str = \"BigBossizzz Proctoring Platform\") -> str:\n        \"\"\"Generate LTI Tool Configuration XML\"\"\"\n        return f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<cartridge_basiclti_link xmlns=\"http://www.imsglobal.org/xsd/imslticc_v1p0\"\n    xmlns:blti=\"http://www.imsglobal.org/xsd/imsbasiclti_v1p0\"\n    xmlns:lticm=\"http://www.imsglobal.org/xsd/imslticm_v1p0\"\n    xmlns:lticp=\"http://www.imsglobal.org/xsd/imslticp_v1p0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.imsglobal.org/xsd/imslticc_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticc_v1p0.xsd\n    http://www.imsglobal.org/xsd/imsbasiclti_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imsbasiclti_v1p0.xsd\n    http://www.imsglobal.org/xsd/imslticm_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticm_v1p0.xsd\n    http://www.imsglobal.org/xsd/imslticp_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticp_v1p0.xsd\">\n\n    <blti:title>{title}</blti:title>\n    <blti:description>Comprehensive online examination and quiz management system with advanced proctoring capabilities</blti:description>\n    <blti:icon>{base_url}/static/img/icon.png</blti:icon>\n    <blti:launch_url>{base_url}/lti/launch</blti:launch_url>\n    \n    <blti:extensions platform=\"canvas.instructure.com\">\n        <lticm:property name=\"tool_id\">bigbossizzz_proctoring</lticm:property>\n        <lticm:property name=\"privacy_level\">public</lticm:property>\n        <lticm:options name=\"course_navigation\">\n            <lticm:property name=\"url\">{base_url}/lti/launch</lticm:property>\n            <lticm:property name=\"text\">{title}</lticm:property>\n            <lticm:property name=\"enabled\">true</lticm:property>\n        </lticm:options>\n        <lticm:options name=\"assignment_selection\">\n            <lticm:property name=\"url\">{base_url}/lti/launch</lticm:property>\n            <lticm:property name=\"text\">{title}</lticm:property>\n            <lticm:property name=\"enabled\">true</lticm:property>\n            <lticm:property name=\"message_type\">ContentItemSelectionRequest</lticm:property>\n        </lticm:options>\n    </blti:extensions>\n    \n    <blti:extensions platform=\"blackboard.com\">\n        <lticm:property name=\"tool_id\">bigbossizzz_proctoring</lticm:property>\n        <lticm:property name=\"privacy_level\">public</lticm:property>\n    </blti:extensions>\n    \n    <blti:extensions platform=\"moodle.org\">\n        <lticm:property name=\"tool_id\">bigbossizzz_proctoring</lticm:property>\n        <lticm:property name=\"privacy_level\">public</lticm:property>\n    </blti:extensions>\n    \n    <cartridge_bundle identifierref=\"BLTI001_Bundle\"/>\n    <cartridge_icon identifierref=\"BLTI001_Icon\"/>\n</cartridge_basiclti_link>\"\"\"\n    \n    @staticmethod\n    def generate_json_config(base_url: str, consumer_key: str, title: str = \"BigBossizzz Proctoring Platform\") -> Dict:\n        \"\"\"Generate LTI 1.3 Tool Configuration JSON\"\"\"\n        return {\n            \"title\": title,\n            \"description\": \"Comprehensive online examination and quiz management system with advanced proctoring capabilities\",\n            \"oidc_initiation_url\": f\"{base_url}/lti/1.3/login\",\n            \"target_link_uri\": f\"{base_url}/lti/1.3/launch\",\n            \"scopes\": [\n                \"https://purl.imsglobal.org/spec/lti-ags/scope/lineitem\",\n                \"https://purl.imsglobal.org/spec/lti-ags/scope/result.readonly\",\n                \"https://purl.imsglobal.org/spec/lti-ags/scope/score\",\n                \"https://purl.imsglobal.org/spec/lti-nrps/scope/contextmembership.readonly\"\n            ],\n            \"extensions\": [\n                {\n                    \"domain\": base_url.replace('https://', '').replace('http://', ''),\n                    \"tool_id\": \"bigbossizzz_proctoring\",\n                    \"platform\": \"canvas.instructure.com\",\n                    \"settings\": {\n                        \"placements\": [\n                            {\n                                \"placement\": \"course_navigation\",\n                                \"message_type\": \"LtiResourceLinkRequest\",\n                                \"text\": title,\n                                \"enabled\": True\n                            },\n                            {\n                                \"placement\": \"assignment_selection\",\n                                \"message_type\": \"LtiDeepLinkingRequest\", \n                                \"text\": title,\n                                \"enabled\": True\n                            }\n                        ]\n                    }\n                }\n            ],\n            \"public_jwk_url\": f\"{base_url}/lti/1.3/jwks\",\n            \"custom_fields\": {\n                \"canvas_user_id\": \"$Canvas.user.id\",\n                \"canvas_course_id\": \"$Canvas.course.id\",\n                \"canvas_assignment_id\": \"$Canvas.assignment.id\"\n            }\n        }\n\n# Helper functions for LTI integration\ndef get_lti_provider(consumer_key: str = None, consumer_secret: str = None) -> LTIProvider:\n    \"\"\"Get configured LTI provider instance\"\"\"\n    # In production, these should come from environment variables or database\n    default_key = \"bigbossizzz_lti_key\"\n    default_secret = \"bigbossizzz_lti_secret_change_in_production\"\n    \n    return LTIProvider(\n        consumer_key=consumer_key or default_key,\n        consumer_secret=consumer_secret or default_secret\n    )\n\ndef get_lti_grade_passback(consumer_key: str = None, consumer_secret: str = None) -> LTIGradePassback:\n    \"\"\"Get configured LTI grade passback instance\"\"\"\n    default_key = \"bigbossizzz_lti_key\"\n    default_secret = \"bigbossizzz_lti_secret_change_in_production\"\n    \n    return LTIGradePassback(\n        consumer_key=consumer_key or default_key,\n        consumer_secret=consumer_secret or default_secret\n    )","size_bytes":19667},"automated_proctoring_reports.py":{"content":"\"\"\"\nAutomated Proctoring Reports with AI-Generated Summaries\nProvides comprehensive analysis of proctoring violations and suspicious behavior patterns\n\"\"\"\n\nimport json\nimport logging\nimport statistics\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom collections import defaultdict, Counter\n\nimport pandas as pd\nfrom sqlalchemy import func, text\nfrom sqlalchemy.orm import joinedload\n\nfrom app import db\nfrom models import (User, Quiz, QuizAttempt, ProctoringEvent, UserViolation, \n                   DeviceLog, SecurityAlert, InteractionEvent, Answer)\n\nclass ProctoringReportGenerator:\n    \"\"\"Advanced proctoring report generation with AI-powered analysis\"\"\"\n    \n    def __init__(self):\n        self.violation_weights = {\n            'face_not_detected': 3,\n            'multiple_faces': 4,\n            'screen_capture': 5,\n            'tab_switch': 2,\n            'window_blur': 2,\n            'fullscreen_exit': 3,\n            'right_click': 1,\n            'copy_paste': 3,\n            'suspicious_audio': 4,\n            'keyboard_pattern': 2,\n            'mouse_pattern': 2,\n            'browser_console': 5,\n            'developer_tools': 5,\n            'external_monitor': 3,\n            'virtual_machine': 5,\n            'screen_sharing': 5\n        }\n        \n        self.severity_thresholds = {\n            'low': (0, 10),\n            'medium': (11, 25),\n            'high': (26, 40),\n            'critical': (41, float('inf'))\n        }\n\n    def generate_comprehensive_report(self, start_date: datetime, end_date: datetime, \n                                    quiz_ids: List[int] = None, user_ids: List[int] = None) -> Dict:\n        \"\"\"Generate comprehensive proctoring report with AI analysis\"\"\"\n        \n        try:\n            # Collect all proctoring data\n            attempts_data = self._get_quiz_attempts_data(start_date, end_date, quiz_ids, user_ids)\n            violations_data = self._get_violations_data(start_date, end_date, quiz_ids, user_ids)\n            events_data = self._get_proctoring_events_data(start_date, end_date, quiz_ids, user_ids)\n            interactions_data = self._get_interaction_events_data(start_date, end_date, quiz_ids, user_ids)\n            device_data = self._get_device_logs_data(start_date, end_date, user_ids)\n            \n            # Generate AI-powered analysis\n            ai_analysis = self._generate_ai_analysis(\n                attempts_data, violations_data, events_data, interactions_data, device_data\n            )\n            \n            # Create comprehensive report\n            report = {\n                'report_id': f\"proctoring_report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}\",\n                'generated_at': datetime.utcnow().isoformat(),\n                'period': {\n                    'start_date': start_date.isoformat(),\n                    'end_date': end_date.isoformat(),\n                    'duration_days': (end_date - start_date).days\n                },\n                'filters': {\n                    'quiz_ids': quiz_ids,\n                    'user_ids': user_ids\n                },\n                'summary': self._generate_executive_summary(ai_analysis),\n                'statistics': self._generate_detailed_statistics(attempts_data, violations_data, events_data),\n                'ai_analysis': ai_analysis,\n                'risk_assessment': self._generate_risk_assessment(violations_data, events_data),\n                'patterns_detected': self._detect_behavior_patterns(violations_data, events_data, interactions_data),\n                'recommendations': self._generate_recommendations(ai_analysis),\n                'detailed_findings': self._generate_detailed_findings(attempts_data, violations_data, events_data),\n                'appendix': {\n                    'methodology': self._get_methodology_description(),\n                    'data_sources': self._get_data_sources_info(),\n                    'limitations': self._get_limitations_info()\n                }\n            }\n            \n            return report\n            \n        except Exception as e:\n            logging.error(f\"Error generating comprehensive proctoring report: {e}\")\n            return {'error': str(e)}\n\n    def _get_quiz_attempts_data(self, start_date: datetime, end_date: datetime, \n                               quiz_ids: List[int] = None, user_ids: List[int] = None) -> List[Dict]:\n        \"\"\"Retrieve quiz attempts data for analysis\"\"\"\n        query = db.session.query(QuizAttempt).options(\n            joinedload(QuizAttempt.quiz),\n            joinedload(QuizAttempt.participant)\n        ).filter(\n            QuizAttempt.started_at >= start_date,\n            QuizAttempt.started_at <= end_date\n        )\n        \n        if quiz_ids:\n            query = query.filter(QuizAttempt.quiz_id.in_(quiz_ids))\n        if user_ids:\n            query = query.filter(QuizAttempt.participant_id.in_(user_ids))\n            \n        attempts = query.all()\n        \n        return [{\n            'attempt_id': attempt.id,\n            'user_id': attempt.participant_id,\n            'username': attempt.participant.username,\n            'quiz_id': attempt.quiz_id,\n            'quiz_title': attempt.quiz.title,\n            'started_at': attempt.started_at.isoformat() if attempt.started_at else None,\n            'completed_at': attempt.completed_at.isoformat() if attempt.completed_at else None,\n            'status': attempt.status,\n            'score': attempt.score,\n            'total_points': attempt.total_points,\n            'force_submitted': attempt.force_submitted,\n            'termination_reason': attempt.termination_reason,\n            'is_flagged': attempt.is_flagged,\n            'duration_minutes': self._calculate_attempt_duration(attempt)\n        } for attempt in attempts]\n\n    def _get_violations_data(self, start_date: datetime, end_date: datetime,\n                           quiz_ids: List[int] = None, user_ids: List[int] = None) -> List[Dict]:\n        \"\"\"Retrieve user violations data\"\"\"\n        query = db.session.query(UserViolation).filter(\n            UserViolation.created_at >= start_date,\n            UserViolation.created_at <= end_date\n        )\n        \n        if user_ids:\n            query = query.filter(UserViolation.user_id.in_(user_ids))\n            \n        violations = query.all()\n        \n        return [{\n            'violation_id': violation.id,\n            'user_id': violation.user_id,\n            'violation_type': violation.violation_type,\n            'severity': violation.severity,\n            'description': violation.description,\n            'evidence_data': violation.evidence_data,\n            'created_at': violation.created_at.isoformat(),\n            'quiz_context': violation.quiz_context,\n            'weight': self.violation_weights.get(violation.violation_type, 1)\n        } for violation in violations]\n\n    def _get_proctoring_events_data(self, start_date: datetime, end_date: datetime,\n                                  quiz_ids: List[int] = None, user_ids: List[int] = None) -> List[Dict]:\n        \"\"\"Retrieve proctoring events data\"\"\"\n        query = db.session.query(ProctoringEvent).filter(\n            ProctoringEvent.created_at >= start_date,\n            ProctoringEvent.created_at <= end_date\n        )\n        \n        if quiz_ids:\n            query = query.filter(ProctoringEvent.quiz_id.in_(quiz_ids))\n        if user_ids:\n            query = query.filter(ProctoringEvent.user_id.in_(user_ids))\n            \n        events = query.all()\n        \n        return [{\n            'event_id': event.id,\n            'user_id': event.user_id,\n            'quiz_id': event.quiz_id,\n            'event_type': event.event_type,\n            'event_data': event.event_data,\n            'severity': event.severity,\n            'created_at': event.created_at.isoformat(),\n            'ip_address': event.ip_address,\n            'user_agent': event.user_agent\n        } for event in events]\n\n    def _get_interaction_events_data(self, start_date: datetime, end_date: datetime,\n                                   quiz_ids: List[int] = None, user_ids: List[int] = None) -> List[Dict]:\n        \"\"\"Retrieve interaction events data\"\"\"\n        query = db.session.query(InteractionEvent).filter(\n            InteractionEvent.timestamp >= start_date,\n            InteractionEvent.timestamp <= end_date\n        )\n        \n        if quiz_ids:\n            query = query.filter(InteractionEvent.quiz_id.in_(quiz_ids))\n        if user_ids:\n            query = query.filter(InteractionEvent.user_id.in_(user_ids))\n            \n        interactions = query.all()\n        \n        return [{\n            'interaction_id': interaction.id,\n            'user_id': interaction.user_id,\n            'quiz_id': interaction.quiz_id,\n            'question_id': interaction.question_id,\n            'interaction_type': interaction.interaction_type,\n            'interaction_data': interaction.interaction_data,\n            'timestamp': interaction.timestamp.isoformat(),\n            'confidence_score': interaction.confidence_score\n        } for interaction in interactions]\n\n    def _get_device_logs_data(self, start_date: datetime, end_date: datetime,\n                             user_ids: List[int] = None) -> List[Dict]:\n        \"\"\"Retrieve device logs data\"\"\"\n        query = db.session.query(DeviceLog).filter(\n            DeviceLog.timestamp >= start_date,\n            DeviceLog.timestamp <= end_date\n        )\n        \n        if user_ids:\n            query = query.filter(DeviceLog.user_id.in_(user_ids))\n            \n        devices = query.all()\n        \n        return [{\n            'device_id': device.id,\n            'user_id': device.user_id,\n            'device_type': device.device_type,\n            'screen_resolution': device.screen_resolution,\n            'browser_info': device.browser_info,\n            'os_info': device.os_info,\n            'camera_info': device.camera_info,\n            'microphone_info': device.microphone_info,\n            'timestamp': device.timestamp.isoformat(),\n            'is_suspicious': device.is_suspicious,\n            'risk_score': device.risk_score\n        } for device in devices]\n\n    def _generate_ai_analysis(self, attempts_data: List[Dict], violations_data: List[Dict],\n                            events_data: List[Dict], interactions_data: List[Dict],\n                            device_data: List[Dict]) -> Dict:\n        \"\"\"Generate AI-powered analysis of proctoring data\"\"\"\n        \n        analysis = {\n            'overall_integrity_score': self._calculate_integrity_score(violations_data, events_data),\n            'behavior_analysis': self._analyze_behavior_patterns(violations_data, events_data, interactions_data),\n            'risk_distribution': self._analyze_risk_distribution(violations_data, attempts_data),\n            'temporal_patterns': self._analyze_temporal_patterns(violations_data, events_data),\n            'device_security_analysis': self._analyze_device_security(device_data),\n            'anomaly_detection': self._detect_anomalies(attempts_data, violations_data, interactions_data),\n            'predictive_insights': self._generate_predictive_insights(violations_data, events_data),\n            'compliance_assessment': self._assess_compliance(violations_data, events_data)\n        }\n        \n        return analysis\n\n    def _calculate_integrity_score(self, violations_data: List[Dict], events_data: List[Dict]) -> Dict:\n        \"\"\"Calculate overall exam integrity score\"\"\"\n        total_weight = sum(v['weight'] for v in violations_data)\n        total_events = len(events_data)\n        \n        if total_events == 0:\n            integrity_score = 100\n        else:\n            # Normalize score based on violations and events\n            violation_impact = min(total_weight * 2, 100)\n            event_impact = min(total_events * 0.5, 50)\n            integrity_score = max(0, 100 - violation_impact - event_impact)\n        \n        return {\n            'score': round(integrity_score, 2),\n            'grade': self._get_integrity_grade(integrity_score),\n            'total_violations_weight': total_weight,\n            'total_events': total_events,\n            'interpretation': self._interpret_integrity_score(integrity_score)\n        }\n\n    def _analyze_behavior_patterns(self, violations_data: List[Dict], events_data: List[Dict],\n                                 interactions_data: List[Dict]) -> Dict:\n        \"\"\"Analyze behavioral patterns using AI techniques\"\"\"\n        \n        # Violation type analysis\n        violation_types = Counter(v['violation_type'] for v in violations_data)\n        \n        # Temporal clustering analysis\n        violation_times = [datetime.fromisoformat(v['created_at']) for v in violations_data]\n        time_clusters = self._cluster_violations_by_time(violation_times)\n        \n        # User behavior profiling\n        user_profiles = self._create_user_behavior_profiles(violations_data, interactions_data)\n        \n        # Pattern recognition\n        suspicious_patterns = self._identify_suspicious_patterns(violations_data, events_data)\n        \n        return {\n            'violation_type_distribution': dict(violation_types),\n            'temporal_clusters': time_clusters,\n            'user_behavior_profiles': user_profiles,\n            'suspicious_patterns': suspicious_patterns,\n            'behavior_consistency': self._assess_behavior_consistency(interactions_data),\n            'collaboration_indicators': self._detect_collaboration_indicators(interactions_data)\n        }\n\n    def _analyze_risk_distribution(self, violations_data: List[Dict], attempts_data: List[Dict]) -> Dict:\n        \"\"\"Analyze risk distribution across users and quizzes\"\"\"\n        \n        # Risk by user\n        user_risks = defaultdict(float)\n        for violation in violations_data:\n            user_risks[violation['user_id']] += violation['weight']\n        \n        # Risk by quiz\n        quiz_risks = defaultdict(float)\n        for violation in violations_data:\n            if 'quiz_context' in violation and violation['quiz_context']:\n                quiz_risks[violation['quiz_context']] += violation['weight']\n        \n        # Risk distribution analysis\n        risk_values = list(user_risks.values())\n        \n        return {\n            'user_risk_distribution': {\n                'mean': statistics.mean(risk_values) if risk_values else 0,\n                'median': statistics.median(risk_values) if risk_values else 0,\n                'std_dev': statistics.stdev(risk_values) if len(risk_values) > 1 else 0,\n                'max_risk': max(risk_values) if risk_values else 0,\n                'min_risk': min(risk_values) if risk_values else 0\n            },\n            'quiz_risk_distribution': dict(quiz_risks),\n            'high_risk_users': self._identify_high_risk_users(user_risks),\n            'risk_severity_breakdown': self._categorize_risks(user_risks)\n        }\n\n    def _analyze_temporal_patterns(self, violations_data: List[Dict], events_data: List[Dict]) -> Dict:\n        \"\"\"Analyze temporal patterns in proctoring violations\"\"\"\n        \n        # Convert timestamps for analysis\n        violation_timestamps = [datetime.fromisoformat(v['created_at']) for v in violations_data]\n        event_timestamps = [datetime.fromisoformat(e['created_at']) for e in events_data]\n        \n        # Hour-of-day analysis\n        violation_hours = [ts.hour for ts in violation_timestamps]\n        hour_distribution = Counter(violation_hours)\n        \n        # Day-of-week analysis\n        violation_days = [ts.weekday() for ts in violation_timestamps]\n        day_distribution = Counter(violation_days)\n        \n        # Peak violation periods\n        peak_periods = self._identify_peak_periods(violation_timestamps)\n        \n        return {\n            'hourly_distribution': dict(hour_distribution),\n            'daily_distribution': dict(day_distribution),\n            'peak_violation_periods': peak_periods,\n            'violation_frequency_trends': self._calculate_frequency_trends(violation_timestamps),\n            'time_correlation_analysis': self._analyze_time_correlations(violations_data, events_data)\n        }\n\n    def _detect_anomalies(self, attempts_data: List[Dict], violations_data: List[Dict],\n                         interactions_data: List[Dict]) -> Dict:\n        \"\"\"Detect anomalies using statistical and machine learning techniques\"\"\"\n        \n        # Completion time anomalies\n        completion_times = [a['duration_minutes'] for a in attempts_data if a['duration_minutes']]\n        time_anomalies = self._detect_time_anomalies(completion_times)\n        \n        # Violation clustering anomalies\n        violation_clusters = self._detect_violation_clusters(violations_data)\n        \n        # Score distribution anomalies\n        scores = [a['score'] for a in attempts_data if a['score'] is not None]\n        score_anomalies = self._detect_score_anomalies(scores)\n        \n        # Interaction pattern anomalies\n        interaction_anomalies = self._detect_interaction_anomalies(interactions_data)\n        \n        return {\n            'completion_time_anomalies': time_anomalies,\n            'violation_clustering_anomalies': violation_clusters,\n            'score_distribution_anomalies': score_anomalies,\n            'interaction_pattern_anomalies': interaction_anomalies,\n            'statistical_outliers': self._identify_statistical_outliers(attempts_data, violations_data)\n        }\n\n    def _generate_recommendations(self, ai_analysis: Dict) -> List[Dict]:\n        \"\"\"Generate AI-powered recommendations for improving exam security\"\"\"\n        \n        recommendations = []\n        \n        # Integrity score recommendations\n        integrity_score = ai_analysis['overall_integrity_score']['score']\n        if integrity_score < 70:\n            recommendations.append({\n                'category': 'Security Enhancement',\n                'priority': 'High',\n                'title': 'Strengthen Proctoring Protocols',\n                'description': 'Current integrity score indicates significant security concerns. Consider implementing stricter proctoring measures.',\n                'actions': [\n                    'Enable additional camera monitoring',\n                    'Implement stricter browser lockdown',\n                    'Reduce violation tolerance thresholds',\n                    'Add manual review processes'\n                ]\n            })\n        \n        # Behavior pattern recommendations\n        behavior_patterns = ai_analysis['behavior_analysis']['suspicious_patterns']\n        if behavior_patterns:\n            recommendations.append({\n                'category': 'Behavior Monitoring',\n                'priority': 'Medium',\n                'title': 'Address Suspicious Behavior Patterns',\n                'description': 'Detected patterns suggest coordinated cheating or systematic workarounds.',\n                'actions': [\n                    'Investigate flagged user groups',\n                    'Randomize question order and timing',\n                    'Implement unique question sets per user',\n                    'Add behavioral biometric analysis'\n                ]\n            })\n        \n        # Temporal pattern recommendations\n        temporal_patterns = ai_analysis['temporal_patterns']\n        peak_periods = temporal_patterns.get('peak_violation_periods', [])\n        if peak_periods:\n            recommendations.append({\n                'category': 'Scheduling Optimization',\n                'priority': 'Low',\n                'title': 'Optimize Exam Scheduling',\n                'description': 'Certain time periods show higher violation rates.',\n                'actions': [\n                    'Avoid high-risk time periods for critical exams',\n                    'Increase monitoring during peak violation hours',\n                    'Consider timezone-specific scheduling',\n                    'Implement dynamic proctoring intensity'\n                ]\n            })\n        \n        return recommendations\n\n    def _generate_detailed_findings(self, attempts_data: List[Dict], violations_data: List[Dict],\n                                  events_data: List[Dict]) -> Dict:\n        \"\"\"Generate detailed findings with specific examples and evidence\"\"\"\n        \n        # High-risk attempts\n        high_risk_attempts = [\n            attempt for attempt in attempts_data \n            if attempt['force_submitted'] or attempt['is_flagged']\n        ]\n        \n        # Critical violations\n        critical_violations = [\n            violation for violation in violations_data\n            if violation['severity'] == 'high' or violation['weight'] >= 4\n        ]\n        \n        # System security events\n        security_events = [\n            event for event in events_data\n            if event['event_type'] in ['browser_console', 'developer_tools', 'screen_sharing']\n        ]\n        \n        return {\n            'high_risk_attempts': {\n                'count': len(high_risk_attempts),\n                'details': high_risk_attempts[:10],  # Top 10 for report\n                'analysis': self._analyze_high_risk_attempts(high_risk_attempts)\n            },\n            'critical_violations': {\n                'count': len(critical_violations),\n                'details': critical_violations[:20],  # Top 20 for report\n                'analysis': self._analyze_critical_violations(critical_violations)\n            },\n            'security_events': {\n                'count': len(security_events),\n                'details': security_events[:15],  # Top 15 for report\n                'analysis': self._analyze_security_events(security_events)\n            },\n            'investigation_priorities': self._prioritize_investigations(\n                high_risk_attempts, critical_violations, security_events\n            )\n        }\n\n    # Helper methods for analysis\n    def _calculate_attempt_duration(self, attempt) -> Optional[float]:\n        \"\"\"Calculate quiz attempt duration in minutes\"\"\"\n        if attempt.started_at and attempt.completed_at:\n            duration = attempt.completed_at - attempt.started_at\n            return round(duration.total_seconds() / 60, 2)\n        return None\n\n    def _get_integrity_grade(self, score: float) -> str:\n        \"\"\"Convert integrity score to letter grade\"\"\"\n        if score >= 90: return 'A'\n        elif score >= 80: return 'B'\n        elif score >= 70: return 'C'\n        elif score >= 60: return 'D'\n        else: return 'F'\n\n    def _interpret_integrity_score(self, score: float) -> str:\n        \"\"\"Provide interpretation of integrity score\"\"\"\n        if score >= 90:\n            return \"Excellent exam integrity with minimal security concerns\"\n        elif score >= 80:\n            return \"Good exam integrity with minor security issues\"\n        elif score >= 70:\n            return \"Acceptable exam integrity with moderate security concerns\"\n        elif score >= 60:\n            return \"Poor exam integrity with significant security issues requiring attention\"\n        else:\n            return \"Critical exam integrity issues requiring immediate investigation\"\n\n    # Additional helper methods would be implemented here...\n    def _cluster_violations_by_time(self, timestamps: List[datetime]) -> List[Dict]:\n        \"\"\"Cluster violations by time periods\"\"\"\n        # Simplified clustering implementation\n        clusters = []\n        if timestamps:\n            # Group by hour windows\n            hour_groups = defaultdict(list)\n            for ts in timestamps:\n                hour_key = ts.replace(minute=0, second=0, microsecond=0)\n                hour_groups[hour_key].append(ts)\n            \n            for hour, events in hour_groups.items():\n                if len(events) >= 3:  # Cluster threshold\n                    clusters.append({\n                        'start_time': hour.isoformat(),\n                        'event_count': len(events),\n                        'density': len(events) / 60,  # Events per minute\n                        'significance': 'high' if len(events) >= 5 else 'medium'\n                    })\n        \n        return clusters\n\n    def _create_user_behavior_profiles(self, violations_data: List[Dict], \n                                     interactions_data: List[Dict]) -> Dict:\n        \"\"\"Create behavioral profiles for users\"\"\"\n        profiles = {}\n        \n        # Group by user\n        user_violations = defaultdict(list)\n        user_interactions = defaultdict(list)\n        \n        for violation in violations_data:\n            user_violations[violation['user_id']].append(violation)\n        \n        for interaction in interactions_data:\n            user_interactions[interaction['user_id']].append(interaction)\n        \n        # Create profiles\n        for user_id in set(list(user_violations.keys()) + list(user_interactions.keys())):\n            violations = user_violations[user_id]\n            interactions = user_interactions[user_id]\n            \n            profiles[user_id] = {\n                'violation_count': len(violations),\n                'total_violation_weight': sum(v['weight'] for v in violations),\n                'most_common_violation': max(Counter(v['violation_type'] for v in violations).items(), \n                                           key=lambda x: x[1])[0] if violations else None,\n                'interaction_count': len(interactions),\n                'risk_level': self._calculate_user_risk_level(violations),\n                'behavior_consistency': self._calculate_behavior_consistency(interactions)\n            }\n        \n        return profiles\n\n    def _calculate_user_risk_level(self, violations: List[Dict]) -> str:\n        \"\"\"Calculate risk level for a user\"\"\"\n        total_weight = sum(v['weight'] for v in violations)\n        \n        for level, (min_val, max_val) in self.severity_thresholds.items():\n            if min_val <= total_weight <= max_val:\n                return level\n        \n        return 'low'\n\n    def _generate_executive_summary(self, ai_analysis: Dict) -> Dict:\n        \"\"\"Generate executive summary of the report\"\"\"\n        integrity_score = ai_analysis['overall_integrity_score']['score']\n        \n        return {\n            'overall_assessment': ai_analysis['overall_integrity_score']['interpretation'],\n            'key_metrics': {\n                'integrity_score': integrity_score,\n                'integrity_grade': ai_analysis['overall_integrity_score']['grade'],\n                'total_violations': ai_analysis['overall_integrity_score']['total_violations_weight'],\n                'total_events': ai_analysis['overall_integrity_score']['total_events']\n            },\n            'critical_findings': self._extract_critical_findings(ai_analysis),\n            'immediate_actions_required': integrity_score < 60,\n            'overall_risk_level': self._determine_overall_risk_level(integrity_score)\n        }\n\n    def _generate_detailed_statistics(self, attempts_data: List[Dict], violations_data: List[Dict], \n                                    events_data: List[Dict]) -> Dict:\n        \"\"\"Generate detailed statistical analysis\"\"\"\n        return {\n            'quiz_attempts': {\n                'total': len(attempts_data),\n                'completed': len([a for a in attempts_data if a['status'] == 'completed']),\n                'force_submitted': len([a for a in attempts_data if a['force_submitted']]),\n                'flagged': len([a for a in attempts_data if a['is_flagged']]),\n                'average_score': statistics.mean([a['score'] for a in attempts_data if a['score']]) if attempts_data else 0\n            },\n            'violations': {\n                'total': len(violations_data),\n                'by_severity': Counter(v['severity'] for v in violations_data),\n                'by_type': Counter(v['violation_type'] for v in violations_data),\n                'total_weight': sum(v['weight'] for v in violations_data)\n            },\n            'proctoring_events': {\n                'total': len(events_data),\n                'by_type': Counter(e['event_type'] for e in events_data),\n                'by_severity': Counter(e['severity'] for e in events_data)\n            }\n        }\n\n    # Additional methods would continue here...\n    def _get_methodology_description(self) -> str:\n        \"\"\"Return methodology description for the report\"\"\"\n        return \"\"\"\n        This report utilizes advanced AI and statistical analysis techniques to evaluate exam integrity:\n        - Weighted violation scoring based on security impact\n        - Temporal pattern analysis using clustering algorithms\n        - Behavioral profiling through interaction analysis\n        - Anomaly detection using statistical outlier identification\n        - Risk assessment through multi-factor correlation analysis\n        \"\"\"\n\n    def _get_data_sources_info(self) -> List[str]:\n        \"\"\"Return information about data sources\"\"\"\n        return [\n            \"Quiz attempt records and completion data\",\n            \"Proctoring violation events and severity classifications\",\n            \"Real-time monitoring events and system interactions\",\n            \"Device and browser security logs\",\n            \"User interaction patterns and behavioral metrics\",\n            \"Camera and audio monitoring data (metadata only)\"\n        ]\n\n    def _get_limitations_info(self) -> List[str]:\n        \"\"\"Return information about report limitations\"\"\"\n        return [\n            \"Analysis based on automated detection systems - manual review recommended for critical decisions\",\n            \"Some violations may be false positives due to technical issues or accessibility needs\",\n            \"Behavioral analysis requires sufficient data points for accurate profiling\",\n            \"Time-based patterns may be influenced by external factors (system load, network issues)\",\n            \"AI recommendations should be validated by educational and security professionals\"\n        ]\n\n# Additional supporting classes and functions would be implemented here...\n\ndef generate_scheduled_report(period_days: int = 7) -> Dict:\n    \"\"\"Generate automated periodic proctoring report\"\"\"\n    end_date = datetime.utcnow()\n    start_date = end_date - timedelta(days=period_days)\n    \n    generator = ProctoringReportGenerator()\n    return generator.generate_comprehensive_report(start_date, end_date)\n\ndef export_report_to_pdf(report_data: Dict, output_path: str) -> bool:\n    \"\"\"Export proctoring report to PDF format\"\"\"\n    try:\n        # PDF generation implementation would go here\n        # Using libraries like reportlab or weasyprint\n        logging.info(f\"Report exported to PDF: {output_path}\")\n        return True\n    except Exception as e:\n        logging.error(f\"Failed to export report to PDF: {e}\")\n        return False\n\ndef send_report_email(report_data: Dict, recipients: List[str]) -> bool:\n    \"\"\"Send proctoring report via email\"\"\"\n    try:\n        # Email sending implementation would go here\n        logging.info(f\"Report emailed to {len(recipients)} recipients\")\n        return True\n    except Exception as e:\n        logging.error(f\"Failed to send report email: {e}\")\n        return False","size_bytes":31239},"analytics_engine.py":{"content":"\"\"\"\nBigBossizzz Enhanced Analytics & Insights Engine\nComprehensive analytics system with predictive capabilities, performance analysis, and pattern detection\n\"\"\"\n\nimport json\nimport logging\nimport statistics\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom collections import defaultdict, Counter\nfrom dataclasses import dataclass\nfrom sklearn.ensemble import RandomForestClassifier, IsolationForest\nfrom sklearn.cluster import DBSCAN\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nimport pandas as pd\nfrom sqlalchemy import func, text, and_, or_\nfrom sqlalchemy.orm import joinedload\n\nfrom app import db\nfrom models import (User, Quiz, Question, QuestionOption, QuizAttempt, Answer, \n                   ProctoringEvent, UserViolation, InteractionEvent, Course,\n                   ParticipantEnrollment, SecurityAlert, CollaborationSignal,\n                   AttemptSimilarity, PlagiarismAnalysis)\n\n@dataclass\nclass StudentRiskProfile:\n    \"\"\"Student risk assessment profile\"\"\"\n    user_id: int\n    username: str\n    risk_score: float\n    risk_level: str\n    risk_factors: List[str]\n    intervention_recommendations: List[str]\n    predicted_failure_probability: float\n    engagement_score: float\n    performance_trend: str\n    last_activity: datetime\n    courses_enrolled: int\n    avg_quiz_score: float\n    violation_count: int\n    proctoring_issues: int\n\n@dataclass\nclass QuestionAnalytics:\n    \"\"\"Question performance analytics\"\"\"\n    question_id: int\n    question_text: str\n    difficulty_score: float\n    difficulty_level: str\n    discrimination_index: float\n    average_score: float\n    attempt_count: int\n    correct_percentage: float\n    time_to_complete_avg: float\n    revision_needed: bool\n    performance_category: str\n\n@dataclass\nclass CheatingPattern:\n    \"\"\"Detected cheating pattern\"\"\"\n    pattern_id: str\n    pattern_type: str\n    severity: str\n    confidence_score: float\n    participants: List[int]\n    quiz_id: Optional[int]\n    time_window: Tuple[datetime, datetime]\n    evidence: Dict[str, Any]\n    status: str\n    detected_at: datetime\n\n@dataclass\nclass InstitutionalMetrics:\n    \"\"\"Real-time institutional dashboard metrics\"\"\"\n    total_students: int\n    active_students_today: int\n    quizzes_in_progress: int\n    completed_quizzes_today: int\n    average_performance: float\n    high_risk_students: int\n    security_alerts_today: int\n    system_uptime: float\n    concurrent_users: int\n    violation_rate: float\n\nclass PredictiveAnalytics:\n    \"\"\"Advanced predictive analytics for student success\"\"\"\n    \n    def __init__(self):\n        self.risk_model = None\n        self.engagement_model = None\n        self.performance_model = None\n        self.feature_scaler = StandardScaler()\n        self.model_accuracy = 0.0\n        self.last_trained = None\n        \n    def analyze_student_risk(self, user_id: int = None, course_id: int = None) -> List[StudentRiskProfile]:\n        \"\"\"Analyze student risk profiles with predictive modeling\"\"\"\n        \n        try:\n            # Get student data for analysis\n            query = db.session.query(User).filter(User.role == 'participant')\n            \n            if user_id:\n                query = query.filter(User.id == user_id)\n            \n            students = query.all()\n            risk_profiles = []\n            \n            for student in students:\n                profile = self._create_risk_profile(student, course_id)\n                risk_profiles.append(profile)\n            \n            # Sort by risk score (highest first)\n            risk_profiles.sort(key=lambda x: x.risk_score, reverse=True)\n            \n            return risk_profiles\n            \n        except Exception as e:\n            logging.error(f\"Error in student risk analysis: {e}\")\n            return []\n    \n    def _create_risk_profile(self, student: User, course_id: int = None) -> StudentRiskProfile:\n        \"\"\"Create comprehensive risk profile for a student\"\"\"\n        \n        # Get student's quiz attempts\n        attempts_query = db.session.query(QuizAttempt).filter(\n            QuizAttempt.participant_id == student.id\n        )\n        \n        if course_id:\n            attempts_query = attempts_query.join(Quiz).filter(Quiz.course_id == course_id)\n        \n        attempts = attempts_query.all()\n        \n        # Calculate engagement metrics\n        engagement_score = self._calculate_engagement_score(student, attempts)\n        \n        # Calculate performance metrics\n        performance_data = self._calculate_performance_metrics(student, attempts)\n        \n        # Get violation data\n        violations = db.session.query(UserViolation).filter(\n            UserViolation.user_id == student.id\n        ).all()\n        \n        # Get proctoring events\n        proctoring_events = db.session.query(ProctoringEvent).join(QuizAttempt).filter(\n            QuizAttempt.participant_id == student.id\n        ).all()\n        \n        # Calculate risk factors\n        risk_factors = self._identify_risk_factors(student, attempts, violations, proctoring_events)\n        \n        # Calculate overall risk score\n        risk_score = self._calculate_risk_score(\n            engagement_score, performance_data, violations, proctoring_events, risk_factors\n        )\n        \n        # Determine risk level\n        risk_level = self._determine_risk_level(risk_score)\n        \n        # Generate intervention recommendations\n        recommendations = self._generate_interventions(risk_factors, risk_score, performance_data)\n        \n        # Predict failure probability\n        failure_probability = self._predict_failure_probability(\n            engagement_score, performance_data, risk_score\n        )\n        \n        # Determine performance trend\n        performance_trend = self._analyze_performance_trend(attempts)\n        \n        # Get enrollment data\n        enrollments = db.session.query(ParticipantEnrollment).filter(\n            ParticipantEnrollment.participant_id == student.id\n        ).count()\n        \n        return StudentRiskProfile(\n            user_id=student.id,\n            username=student.username,\n            risk_score=round(risk_score, 2),\n            risk_level=risk_level,\n            risk_factors=risk_factors,\n            intervention_recommendations=recommendations,\n            predicted_failure_probability=round(failure_probability, 3),\n            engagement_score=round(engagement_score, 2),\n            performance_trend=performance_trend,\n            last_activity=self._get_last_activity(student),\n            courses_enrolled=enrollments,\n            avg_quiz_score=round(performance_data.get('avg_score', 0), 2),\n            violation_count=len(violations),\n            proctoring_issues=len([e for e in proctoring_events if e.severity in ['medium', 'high']])\n        )\n    \n    def _calculate_engagement_score(self, student: User, attempts: List[QuizAttempt]) -> float:\n        \"\"\"Calculate student engagement score based on activity patterns\"\"\"\n        \n        if not attempts:\n            return 0.0\n        \n        engagement_factors = {\n            'quiz_completion_rate': 0.25,\n            'time_management': 0.20,\n            'consistency': 0.20,\n            'effort_level': 0.15,\n            'interaction_depth': 0.10,\n            'help_seeking': 0.10\n        }\n        \n        total_score = 0.0\n        \n        # Quiz completion rate\n        completed = len([a for a in attempts if a.status == 'completed'])\n        completion_rate = completed / len(attempts) if attempts else 0\n        total_score += completion_rate * engagement_factors['quiz_completion_rate']\n        \n        # Time management (not rushing or taking too long)\n        time_scores = []\n        for attempt in attempts:\n            if attempt.started_at and attempt.completed_at:\n                duration = (attempt.completed_at - attempt.started_at).total_seconds() / 60\n                quiz_time_limit = attempt.quiz.time_limit if attempt.quiz.time_limit else 60\n                \n                # Optimal time is 70-90% of allowed time\n                optimal_min = quiz_time_limit * 0.7\n                optimal_max = quiz_time_limit * 0.9\n                \n                if optimal_min <= duration <= optimal_max:\n                    time_scores.append(1.0)\n                elif duration < optimal_min:\n                    time_scores.append(0.5)  # Rushing\n                else:\n                    time_scores.append(0.7)  # Taking time\n        \n        avg_time_score = statistics.mean(time_scores) if time_scores else 0.5\n        total_score += avg_time_score * engagement_factors['time_management']\n        \n        # Consistency (regular quiz taking)\n        if len(attempts) > 1:\n            dates = [a.started_at.date() for a in attempts if a.started_at]\n            if len(set(dates)) > 1:\n                date_gaps = []\n                sorted_dates = sorted(set(dates))\n                for i in range(1, len(sorted_dates)):\n                    gap = (sorted_dates[i] - sorted_dates[i-1]).days\n                    date_gaps.append(gap)\n                \n                avg_gap = statistics.mean(date_gaps)\n                consistency_score = max(0, 1 - (avg_gap / 14))  # Penalty for gaps > 2 weeks\n                total_score += consistency_score * engagement_factors['consistency']\n        \n        # Effort level (based on answer changes and time spent)\n        interaction_events = db.session.query(InteractionEvent).join(QuizAttempt).filter(\n            QuizAttempt.participant_id == student.id\n        ).all()\n        \n        effort_indicators = len([e for e in interaction_events if e.event_type == 'answer_change'])\n        effort_score = min(1.0, effort_indicators / 10)  # Normalize to max 10 changes\n        total_score += effort_score * engagement_factors['effort_level']\n        \n        # Interaction depth\n        interaction_types = set([e.event_type for e in interaction_events])\n        depth_score = len(interaction_types) / 6  # Normalize to 6 interaction types\n        total_score += min(1.0, depth_score) * engagement_factors['interaction_depth']\n        \n        # Help seeking behavior (reasonable violation reports)\n        help_seeking_score = 0.5  # Default neutral score\n        total_score += help_seeking_score * engagement_factors['help_seeking']\n        \n        return min(100.0, total_score * 100)\n    \n    def _calculate_performance_metrics(self, student: User, attempts: List[QuizAttempt]) -> Dict[str, float]:\n        \"\"\"Calculate comprehensive performance metrics\"\"\"\n        \n        if not attempts:\n            return {\n                'avg_score': 0.0,\n                'score_trend': 0.0,\n                'consistency': 0.0,\n                'improvement_rate': 0.0\n            }\n        \n        scores = [a.score for a in attempts if a.score is not None]\n        \n        if not scores:\n            return {\n                'avg_score': 0.0,\n                'score_trend': 0.0,\n                'consistency': 0.0,\n                'improvement_rate': 0.0\n            }\n        \n        # Average score\n        avg_score = statistics.mean(scores)\n        \n        # Score trend (using linear regression slope)\n        if len(scores) > 1:\n            x = list(range(len(scores)))\n            slope = np.polyfit(x, scores, 1)[0]\n            score_trend = slope\n        else:\n            score_trend = 0.0\n        \n        # Consistency (inverse of standard deviation)\n        consistency = max(0, 100 - statistics.stdev(scores)) if len(scores) > 1 else 50\n        \n        # Improvement rate (comparing first half to second half)\n        if len(scores) >= 4:\n            mid = len(scores) // 2\n            first_half_avg = statistics.mean(scores[:mid])\n            second_half_avg = statistics.mean(scores[mid:])\n            improvement_rate = (second_half_avg - first_half_avg) / first_half_avg * 100\n        else:\n            improvement_rate = 0.0\n        \n        return {\n            'avg_score': avg_score,\n            'score_trend': score_trend,\n            'consistency': consistency,\n            'improvement_rate': improvement_rate\n        }\n    \n    def _identify_risk_factors(self, student: User, attempts: List[QuizAttempt], \n                             violations: List[UserViolation], proctoring_events: List[ProctoringEvent]) -> List[str]:\n        \"\"\"Identify specific risk factors for the student\"\"\"\n        \n        risk_factors = []\n        \n        # Performance-based risk factors\n        if attempts:\n            scores = [a.score for a in attempts if a.score is not None]\n            if scores:\n                avg_score = statistics.mean(scores)\n                if avg_score < 60:\n                    risk_factors.append(\"Low average quiz scores\")\n                if len(scores) > 1 and scores[-1] < scores[0]:\n                    risk_factors.append(\"Declining performance trend\")\n                \n                # Check for sudden performance drops\n                if len(scores) >= 3:\n                    recent_avg = statistics.mean(scores[-3:])\n                    overall_avg = statistics.mean(scores)\n                    if recent_avg < overall_avg * 0.8:\n                        risk_factors.append(\"Recent performance decline\")\n        \n        # Engagement-based risk factors\n        if len(attempts) < 3:\n            risk_factors.append(\"Low quiz participation\")\n        \n        incomplete_attempts = len([a for a in attempts if a.status != 'completed'])\n        if incomplete_attempts > len(attempts) * 0.3:\n            risk_factors.append(\"High incomplete attempt rate\")\n        \n        # Check for irregular timing patterns\n        if attempts:\n            late_submissions = len([a for a in attempts if a.force_submitted])\n            if late_submissions > len(attempts) * 0.2:\n                risk_factors.append(\"Frequent time management issues\")\n        \n        # Violation-based risk factors\n        if violations:\n            if len(violations) > 2:\n                risk_factors.append(\"Multiple proctoring violations\")\n            \n            flagged_violations = [v for v in violations if v.is_flagged]\n            if flagged_violations:\n                risk_factors.append(\"Flagged for suspicious behavior\")\n        \n        # Proctoring event analysis\n        high_severity_events = [e for e in proctoring_events if e.severity == 'high']\n        if len(high_severity_events) > 5:\n            risk_factors.append(\"Frequent high-severity proctoring alerts\")\n        \n        # Activity patterns\n        last_activity = self._get_last_activity(student)\n        if last_activity and (datetime.utcnow() - last_activity).days > 14:\n            risk_factors.append(\"Extended period of inactivity\")\n        \n        return risk_factors\n    \n    def _calculate_risk_score(self, engagement_score: float, performance_data: Dict, \n                            violations: List, proctoring_events: List, risk_factors: List[str]) -> float:\n        \"\"\"Calculate overall risk score (0-100, higher = more risk)\"\"\"\n        \n        # Base risk from engagement (inverse relationship)\n        engagement_risk = max(0, 100 - engagement_score)\n        \n        # Performance risk\n        avg_score = performance_data.get('avg_score', 0)\n        performance_risk = max(0, 100 - avg_score)\n        \n        # Trend risk\n        score_trend = performance_data.get('score_trend', 0)\n        trend_risk = max(0, -score_trend * 10)  # Negative trend increases risk\n        \n        # Violation risk\n        violation_risk = min(50, len(violations) * 10)\n        \n        # Proctoring risk\n        proctoring_risk = min(30, len(proctoring_events) * 2)\n        \n        # Risk factor penalty\n        factor_risk = min(40, len(risk_factors) * 8)\n        \n        # Weighted combination\n        total_risk = (\n            engagement_risk * 0.25 +\n            performance_risk * 0.30 +\n            trend_risk * 0.15 +\n            violation_risk * 0.15 +\n            proctoring_risk * 0.10 +\n            factor_risk * 0.05\n        )\n        \n        return min(100.0, max(0.0, total_risk))\n    \n    def _determine_risk_level(self, risk_score: float) -> str:\n        \"\"\"Determine risk level category\"\"\"\n        if risk_score >= 80:\n            return \"Critical\"\n        elif risk_score >= 60:\n            return \"High\"\n        elif risk_score >= 40:\n            return \"Medium\"\n        elif risk_score >= 20:\n            return \"Low\"\n        else:\n            return \"Minimal\"\n    \n    def _generate_interventions(self, risk_factors: List[str], risk_score: float, \n                              performance_data: Dict) -> List[str]:\n        \"\"\"Generate personalized intervention recommendations\"\"\"\n        \n        recommendations = []\n        \n        # Performance-based interventions\n        if \"Low average quiz scores\" in risk_factors:\n            recommendations.append(\"Schedule one-on-one tutoring sessions\")\n            recommendations.append(\"Provide additional practice materials\")\n        \n        if \"Declining performance trend\" in risk_factors:\n            recommendations.append(\"Immediate academic counseling session\")\n            recommendations.append(\"Review study strategies and time management\")\n        \n        # Engagement interventions\n        if \"Low quiz participation\" in risk_factors:\n            recommendations.append(\"Send engagement reminders and check-ins\")\n            recommendations.append(\"Investigate potential technical or personal barriers\")\n        \n        if \"High incomplete attempt rate\" in risk_factors:\n            recommendations.append(\"Time management workshop enrollment\")\n            recommendations.append(\"Extend quiz time limits or provide breaks\")\n        \n        # Behavioral interventions\n        if \"Multiple proctoring violations\" in risk_factors:\n            recommendations.append(\"Academic integrity training required\")\n            recommendations.append(\"Supervised testing environment\")\n        \n        if \"Extended period of inactivity\" in risk_factors:\n            recommendations.append(\"Immediate outreach contact\")\n            recommendations.append(\"Check for withdrawal or personal issues\")\n        \n        # Risk level specific interventions\n        if risk_score >= 80:\n            recommendations.append(\"Emergency academic intervention meeting\")\n            recommendations.append(\"Consider course withdrawal/incomplete options\")\n        elif risk_score >= 60:\n            recommendations.append(\"Weekly check-ins with instructor\")\n            recommendations.append(\"Peer study group assignment\")\n        \n        # Remove duplicates while preserving order\n        return list(dict.fromkeys(recommendations))\n    \n    def _predict_failure_probability(self, engagement_score: float, performance_data: Dict, risk_score: float) -> float:\n        \"\"\"Predict probability of course failure using multiple factors\"\"\"\n        \n        # Simple logistic regression-like calculation\n        avg_score = performance_data.get('avg_score', 0)\n        score_trend = performance_data.get('score_trend', 0)\n        \n        # Feature weights based on education research\n        weights = {\n            'performance': 0.4,\n            'engagement': 0.25,\n            'trend': 0.20,\n            'risk': 0.15\n        }\n        \n        # Normalize factors to 0-1 scale for probability calculation\n        performance_factor = max(0, min(1, (100 - avg_score) / 100))\n        engagement_factor = max(0, min(1, (100 - engagement_score) / 100))\n        trend_factor = max(0, min(1, max(0, -score_trend) / 10))\n        risk_factor = max(0, min(1, risk_score / 100))\n        \n        # Calculate weighted probability\n        failure_probability = (\n            performance_factor * weights['performance'] +\n            engagement_factor * weights['engagement'] +\n            trend_factor * weights['trend'] +\n            risk_factor * weights['risk']\n        )\n        \n        return min(0.99, max(0.01, failure_probability))\n    \n    def _analyze_performance_trend(self, attempts: List[QuizAttempt]) -> str:\n        \"\"\"Analyze overall performance trend\"\"\"\n        \n        if len(attempts) < 3:\n            return \"Insufficient Data\"\n        \n        scores = [a.score for a in attempts if a.score is not None]\n        \n        if len(scores) < 3:\n            return \"Insufficient Data\"\n        \n        # Calculate trend using linear regression\n        x = list(range(len(scores)))\n        slope = np.polyfit(x, scores, 1)[0]\n        \n        if slope > 2:\n            return \"Strongly Improving\"\n        elif slope > 0.5:\n            return \"Improving\"\n        elif slope > -0.5:\n            return \"Stable\"\n        elif slope > -2:\n            return \"Declining\"\n        else:\n            return \"Strongly Declining\"\n    \n    def _get_last_activity(self, student: User) -> Optional[datetime]:\n        \"\"\"Get student's last activity timestamp\"\"\"\n        \n        # Check quiz attempts\n        last_attempt = db.session.query(QuizAttempt).filter(\n            QuizAttempt.participant_id == student.id\n        ).order_by(QuizAttempt.started_at.desc()).first()\n        \n        # Check interaction events\n        last_interaction = db.session.query(InteractionEvent).join(QuizAttempt).filter(\n            QuizAttempt.participant_id == student.id\n        ).order_by(InteractionEvent.timestamp.desc()).first()\n        \n        activities = []\n        if last_attempt and last_attempt.started_at:\n            activities.append(last_attempt.started_at)\n        if last_interaction and last_interaction.timestamp:\n            activities.append(last_interaction.timestamp)\n        \n        return max(activities) if activities else None\n\nclass QuestionPerformanceAnalyzer:\n    \"\"\"Analyze question difficulty and effectiveness\"\"\"\n    \n    def analyze_question_performance(self, question_id: int = None, quiz_id: int = None) -> List[QuestionAnalytics]:\n        \"\"\"Comprehensive question performance analysis\"\"\"\n        \n        try:\n            query = db.session.query(Question)\n            \n            if question_id:\n                query = query.filter(Question.id == question_id)\n            elif quiz_id:\n                query = query.filter(Question.quiz_id == quiz_id)\n            \n            questions = query.all()\n            analytics_results = []\n            \n            for question in questions:\n                analytics = self._analyze_single_question(question)\n                analytics_results.append(analytics)\n            \n            return analytics_results\n            \n        except Exception as e:\n            logging.error(f\"Error in question performance analysis: {e}\")\n            return []\n    \n    def _analyze_single_question(self, question: Question) -> QuestionAnalytics:\n        \"\"\"Analyze performance of a single question\"\"\"\n        \n        # Get all answers for this question\n        answers = db.session.query(Answer).filter(Answer.question_id == question.id).all()\n        \n        if not answers:\n            return QuestionAnalytics(\n                question_id=question.id,\n                question_text=question.question_text[:100] + \"...\" if len(question.question_text) > 100 else question.question_text,\n                difficulty_score=50.0,\n                difficulty_level=\"Unknown\",\n                discrimination_index=0.0,\n                average_score=0.0,\n                attempt_count=0,\n                correct_percentage=0.0,\n                time_to_complete_avg=0.0,\n                revision_needed=False,\n                performance_category=\"No Data\"\n            )\n        \n        # Calculate basic statistics\n        attempt_count = len(answers)\n        correct_answers = len([a for a in answers if a.is_correct])\n        correct_percentage = (correct_answers / attempt_count) * 100 if attempt_count > 0 else 0\n        \n        # Calculate average score\n        scores = [a.points_earned for a in answers if a.points_earned is not None]\n        average_score = statistics.mean(scores) if scores else 0\n        \n        # Calculate difficulty score (inverse of correct percentage)\n        difficulty_score = 100 - correct_percentage\n        \n        # Determine difficulty level\n        difficulty_level = self._categorize_difficulty(difficulty_score)\n        \n        # Calculate discrimination index (how well question differentiates high/low performers)\n        discrimination_index = self._calculate_discrimination_index(question, answers)\n        \n        # Calculate average time to complete\n        time_to_complete_avg = self._calculate_average_completion_time(answers)\n        \n        # Determine if revision is needed\n        revision_needed = self._needs_revision(difficulty_score, discrimination_index, correct_percentage)\n        \n        # Categorize performance\n        performance_category = self._categorize_performance(difficulty_score, discrimination_index, correct_percentage)\n        \n        return QuestionAnalytics(\n            question_id=question.id,\n            question_text=question.question_text[:100] + \"...\" if len(question.question_text) > 100 else question.question_text,\n            difficulty_score=round(difficulty_score, 2),\n            difficulty_level=difficulty_level,\n            discrimination_index=round(discrimination_index, 3),\n            average_score=round(average_score, 2),\n            attempt_count=attempt_count,\n            correct_percentage=round(correct_percentage, 2),\n            time_to_complete_avg=round(time_to_complete_avg, 2),\n            revision_needed=revision_needed,\n            performance_category=performance_category\n        )\n    \n    def _categorize_difficulty(self, difficulty_score: float) -> str:\n        \"\"\"Categorize question difficulty level\"\"\"\n        if difficulty_score >= 80:\n            return \"Very Hard\"\n        elif difficulty_score >= 60:\n            return \"Hard\"\n        elif difficulty_score >= 40:\n            return \"Moderate\"\n        elif difficulty_score >= 20:\n            return \"Easy\"\n        else:\n            return \"Very Easy\"\n    \n    def _calculate_discrimination_index(self, question: Question, answers: List[Answer]) -> float:\n        \"\"\"Calculate discrimination index using upper/lower group method\"\"\"\n        \n        if len(answers) < 10:\n            return 0.0\n        \n        # Get quiz attempt scores for context\n        attempt_scores = {}\n        for answer in answers:\n            attempt = db.session.query(QuizAttempt).filter(\n                QuizAttempt.id == answer.attempt_id\n            ).first()\n            if attempt and attempt.score is not None:\n                attempt_scores[answer.id] = attempt.score\n        \n        if len(attempt_scores) < 10:\n            return 0.0\n        \n        # Sort answers by overall quiz performance\n        sorted_answers = sorted(answers, key=lambda a: attempt_scores.get(a.id, 0), reverse=True)\n        \n        # Get upper and lower 27% groups (standard practice)\n        group_size = max(1, int(len(sorted_answers) * 0.27))\n        upper_group = sorted_answers[:group_size]\n        lower_group = sorted_answers[-group_size:]\n        \n        # Calculate correct percentages for each group\n        upper_correct = len([a for a in upper_group if a.is_correct]) / len(upper_group)\n        lower_correct = len([a for a in lower_group if a.is_correct]) / len(lower_group)\n        \n        # Discrimination index = P_upper - P_lower\n        return upper_correct - lower_correct\n    \n    def _calculate_average_completion_time(self, answers: List[Answer]) -> float:\n        \"\"\"Calculate average time to complete question\"\"\"\n        \n        completion_times = []\n        \n        for answer in answers:\n            # Get interaction events for this answer\n            interactions = db.session.query(InteractionEvent).filter(\n                InteractionEvent.question_id == answer.question_id,\n                InteractionEvent.attempt_id == answer.attempt_id\n            ).order_by(InteractionEvent.timestamp).all()\n            \n            if len(interactions) >= 2:\n                start_time = interactions[0].timestamp\n                end_time = interactions[-1].timestamp\n                duration = (end_time - start_time).total_seconds()\n                completion_times.append(duration)\n        \n        return statistics.mean(completion_times) if completion_times else 0.0\n    \n    def _needs_revision(self, difficulty_score: float, discrimination_index: float, correct_percentage: float) -> bool:\n        \"\"\"Determine if question needs revision\"\"\"\n        \n        # Question needs revision if:\n        # 1. Too easy (>90% correct) or too hard (<10% correct)\n        # 2. Poor discrimination (< 0.2)\n        # 3. Very low or negative discrimination\n        \n        if correct_percentage > 90 or correct_percentage < 10:\n            return True\n        \n        if discrimination_index < 0.2:\n            return True\n        \n        if discrimination_index < 0:\n            return True\n        \n        return False\n    \n    def _categorize_performance(self, difficulty_score: float, discrimination_index: float, correct_percentage: float) -> str:\n        \"\"\"Categorize overall question performance\"\"\"\n        \n        if discrimination_index >= 0.4 and 20 <= correct_percentage <= 80:\n            return \"Excellent\"\n        elif discrimination_index >= 0.3 and 15 <= correct_percentage <= 85:\n            return \"Good\"\n        elif discrimination_index >= 0.2 and 10 <= correct_percentage <= 90:\n            return \"Acceptable\"\n        elif discrimination_index >= 0.1:\n            return \"Needs Improvement\"\n        else:\n            return \"Poor\"\n\nclass CheatingPatternDetector:\n    \"\"\"Advanced cheating pattern detection and analysis\"\"\"\n    \n    def __init__(self):\n        self.anomaly_detector = IsolationForest(contamination=0.1, random_state=42)\n        self.clustering_model = DBSCAN(eps=0.5, min_samples=3)\n        \n    def detect_cheating_patterns(self, quiz_id: int = None, time_window_hours: int = 24) -> List[CheatingPattern]:\n        \"\"\"Detect various cheating patterns across quizzes\"\"\"\n        \n        try:\n            end_time = datetime.utcnow()\n            start_time = end_time - timedelta(hours=time_window_hours)\n            \n            patterns = []\n            \n            # Detect different types of cheating patterns\n            patterns.extend(self._detect_answer_similarity_patterns(quiz_id, start_time, end_time))\n            patterns.extend(self._detect_timing_patterns(quiz_id, start_time, end_time))\n            patterns.extend(self._detect_ip_clustering_patterns(quiz_id, start_time, end_time))\n            patterns.extend(self._detect_behavioral_anomalies(quiz_id, start_time, end_time))\n            patterns.extend(self._detect_collaboration_signals(quiz_id, start_time, end_time))\n            \n            return patterns\n            \n        except Exception as e:\n            logging.error(f\"Error in cheating pattern detection: {e}\")\n            return []\n    \n    def _detect_answer_similarity_patterns(self, quiz_id: int, start_time: datetime, end_time: datetime) -> List[CheatingPattern]:\n        \"\"\"Detect unusual answer similarity patterns\"\"\"\n        \n        patterns = []\n        \n        # Get quiz attempts in time window\n        query = db.session.query(QuizAttempt).filter(\n            QuizAttempt.started_at >= start_time,\n            QuizAttempt.started_at <= end_time\n        )\n        \n        if quiz_id:\n            query = query.filter(QuizAttempt.quiz_id == quiz_id)\n        \n        attempts = query.all()\n        \n        if len(attempts) < 2:\n            return patterns\n        \n        # Check for highly similar answer patterns\n        similarity_matrix = {}\n        \n        for i, attempt1 in enumerate(attempts):\n            for j, attempt2 in enumerate(attempts[i+1:], i+1):\n                similarity_score = self._calculate_answer_similarity(attempt1, attempt2)\n                \n                if similarity_score > 0.8:  # High similarity threshold\n                    pattern_id = f\"answer_similarity_{attempt1.id}_{attempt2.id}_{int(datetime.utcnow().timestamp())}\"\n                    \n                    pattern = CheatingPattern(\n                        pattern_id=pattern_id,\n                        pattern_type=\"Answer Similarity\",\n                        severity=\"High\" if similarity_score > 0.9 else \"Medium\",\n                        confidence_score=similarity_score,\n                        participants=[attempt1.participant_id, attempt2.participant_id],\n                        quiz_id=attempt1.quiz_id,\n                        time_window=(min(attempt1.started_at, attempt2.started_at), \n                                   max(attempt1.completed_at or attempt1.started_at, \n                                       attempt2.completed_at or attempt2.started_at)),\n                        evidence={\n                            \"similarity_score\": similarity_score,\n                            \"matching_answers\": self._get_matching_answers(attempt1, attempt2),\n                            \"attempt_ids\": [attempt1.id, attempt2.id]\n                        },\n                        status=\"Active\",\n                        detected_at=datetime.utcnow()\n                    )\n                    \n                    patterns.append(pattern)\n        \n        return patterns\n    \n    def _detect_timing_patterns(self, quiz_id: int, start_time: datetime, end_time: datetime) -> List[CheatingPattern]:\n        \"\"\"Detect suspicious timing patterns\"\"\"\n        \n        patterns = []\n        \n        # Get attempts with completion times\n        query = db.session.query(QuizAttempt).filter(\n            QuizAttempt.started_at >= start_time,\n            QuizAttempt.started_at <= end_time,\n            QuizAttempt.completed_at.isnot(None)\n        )\n        \n        if quiz_id:\n            query = query.filter(QuizAttempt.quiz_id == quiz_id)\n        \n        attempts = query.all()\n        \n        if len(attempts) < 3:\n            return patterns\n        \n        # Group by quiz and analyze timing\n        quiz_groups = defaultdict(list)\n        for attempt in attempts:\n            quiz_groups[attempt.quiz_id].append(attempt)\n        \n        for quiz_id, quiz_attempts in quiz_groups.items():\n            if len(quiz_attempts) < 3:\n                continue\n            \n            # Calculate completion times\n            completion_times = []\n            for attempt in quiz_attempts:\n                duration = (attempt.completed_at - attempt.started_at).total_seconds() / 60\n                completion_times.append((attempt, duration))\n            \n            # Detect unusually fast completions\n            durations = [ct[1] for ct in completion_times]\n            if len(durations) > 2:\n                mean_duration = statistics.mean(durations)\n                std_duration = statistics.stdev(durations) if len(durations) > 1 else 0\n                \n                for attempt, duration in completion_times:\n                    if duration < mean_duration - 2 * std_duration and duration < mean_duration * 0.5:\n                        pattern_id = f\"fast_completion_{attempt.id}_{int(datetime.utcnow().timestamp())}\"\n                        \n                        pattern = CheatingPattern(\n                            pattern_id=pattern_id,\n                            pattern_type=\"Suspicious Timing\",\n                            severity=\"Medium\",\n                            confidence_score=min(0.9, (mean_duration - duration) / mean_duration),\n                            participants=[attempt.participant_id],\n                            quiz_id=quiz_id,\n                            time_window=(attempt.started_at, attempt.completed_at),\n                            evidence={\n                                \"completion_time_minutes\": duration,\n                                \"average_time_minutes\": mean_duration,\n                                \"deviation_factor\": (mean_duration - duration) / mean_duration\n                            },\n                            status=\"Active\",\n                            detected_at=datetime.utcnow()\n                        )\n                        \n                        patterns.append(pattern)\n        \n        return patterns\n    \n    def _detect_ip_clustering_patterns(self, quiz_id: int, start_time: datetime, end_time: datetime) -> List[CheatingPattern]:\n        \"\"\"Detect IP address clustering that might indicate collusion\"\"\"\n        \n        patterns = []\n        \n        # Get attempts with IP addresses from proctoring events\n        query = db.session.query(QuizAttempt).join(ProctoringEvent).filter(\n            QuizAttempt.started_at >= start_time,\n            QuizAttempt.started_at <= end_time,\n            ProctoringEvent.ip_address.isnot(None)\n        )\n        \n        if quiz_id:\n            query = query.filter(QuizAttempt.quiz_id == quiz_id)\n        \n        attempts = query.all()\n        \n        # Group by IP address\n        ip_groups = defaultdict(list)\n        for attempt in attempts:\n            # Get IP from proctoring events\n            proctoring_event = db.session.query(ProctoringEvent).filter(\n                ProctoringEvent.attempt_id == attempt.id,\n                ProctoringEvent.ip_address.isnot(None)\n            ).first()\n            \n            if proctoring_event and proctoring_event.ip_address:\n                ip_groups[proctoring_event.ip_address].append(attempt)\n        \n        # Check for suspicious IP clustering\n        for ip_address, ip_attempts in ip_groups.items():\n            if len(ip_attempts) > 2:  # More than 2 attempts from same IP\n                # Check if they're different users\n                user_ids = set(attempt.participant_id for attempt in ip_attempts)\n                \n                if len(user_ids) > 1:  # Multiple users from same IP\n                    pattern_id = f\"ip_clustering_{ip_address.replace('.', '_')}_{int(datetime.utcnow().timestamp())}\"\n                    \n                    pattern = CheatingPattern(\n                        pattern_id=pattern_id,\n                        pattern_type=\"IP Clustering\",\n                        severity=\"Medium\",\n                        confidence_score=min(0.8, len(user_ids) / 5),  # Higher score for more users\n                        participants=list(user_ids),\n                        quiz_id=ip_attempts[0].quiz_id,\n                        time_window=(min(a.started_at for a in ip_attempts),\n                                   max(a.completed_at or a.started_at for a in ip_attempts)),\n                        evidence={\n                            \"ip_address\": ip_address,\n                            \"user_count\": len(user_ids),\n                            \"attempt_count\": len(ip_attempts),\n                            \"attempt_ids\": [a.id for a in ip_attempts]\n                        },\n                        status=\"Active\",\n                        detected_at=datetime.utcnow()\n                    )\n                    \n                    patterns.append(pattern)\n        \n        return patterns\n    \n    def _detect_behavioral_anomalies(self, quiz_id: int, start_time: datetime, end_time: datetime) -> List[CheatingPattern]:\n        \"\"\"Detect behavioral anomalies using machine learning\"\"\"\n        \n        patterns = []\n        \n        try:\n            # Get interaction events for analysis\n            query = db.session.query(InteractionEvent).join(QuizAttempt).filter(\n                QuizAttempt.started_at >= start_time,\n                QuizAttempt.started_at <= end_time\n            )\n            \n            if quiz_id:\n                query = query.filter(QuizAttempt.quiz_id == quiz_id)\n            \n            interactions = query.all()\n            \n            if len(interactions) < 50:  # Need sufficient data for anomaly detection\n                return patterns\n            \n            # Create feature vectors for anomaly detection\n            features = []\n            attempt_mapping = {}\n            \n            # Group interactions by attempt\n            attempt_interactions = defaultdict(list)\n            for interaction in interactions:\n                attempt_interactions[interaction.attempt_id].append(interaction)\n            \n            for attempt_id, attempt_events in attempt_interactions.items():\n                if len(attempt_events) < 5:  # Skip attempts with too few interactions\n                    continue\n                \n                feature_vector = self._extract_behavioral_features(attempt_events)\n                features.append(feature_vector)\n                attempt_mapping[len(features) - 1] = attempt_id\n            \n            if len(features) < 10:\n                return patterns\n            \n            # Detect anomalies\n            feature_array = np.array(features)\n            anomaly_scores = self.anomaly_detector.fit_predict(feature_array)\n            \n            # Identify anomalous attempts\n            for idx, score in enumerate(anomaly_scores):\n                if score == -1:  # Anomaly detected\n                    attempt_id = attempt_mapping[idx]\n                    attempt = db.session.query(QuizAttempt).get(attempt_id)\n                    \n                    if attempt:\n                        pattern_id = f\"behavioral_anomaly_{attempt_id}_{int(datetime.utcnow().timestamp())}\"\n                        \n                        pattern = CheatingPattern(\n                            pattern_id=pattern_id,\n                            pattern_type=\"Behavioral Anomaly\",\n                            severity=\"Medium\",\n                            confidence_score=0.7,\n                            participants=[attempt.participant_id],\n                            quiz_id=attempt.quiz_id,\n                            time_window=(attempt.started_at, attempt.completed_at or attempt.started_at),\n                            evidence={\n                                \"anomaly_score\": float(score),\n                                \"feature_vector\": features[idx],\n                                \"unusual_patterns\": self._describe_anomaly(features[idx])\n                            },\n                            status=\"Active\",\n                            detected_at=datetime.utcnow()\n                        )\n                        \n                        patterns.append(pattern)\n        \n        except Exception as e:\n            logging.error(f\"Error in behavioral anomaly detection: {e}\")\n        \n        return patterns\n    \n    def _detect_collaboration_signals(self, quiz_id: int, start_time: datetime, end_time: datetime) -> List[CheatingPattern]:\n        \"\"\"Detect collaboration signals from existing collaboration analysis\"\"\"\n        \n        patterns = []\n        \n        # Get collaboration signals from the database\n        query = db.session.query(CollaborationSignal).filter(\n            CollaborationSignal.created_at >= start_time,\n            CollaborationSignal.created_at <= end_time,\n            CollaborationSignal.severity.in_(['warn', 'high'])\n        )\n        \n        if quiz_id:\n            query = query.filter(CollaborationSignal.quiz_id == quiz_id)\n        \n        signals = query.all()\n        \n        for signal in signals:\n            pattern_id = f\"collaboration_{signal.id}_{int(datetime.utcnow().timestamp())}\"\n            \n            pattern = CheatingPattern(\n                pattern_id=pattern_id,\n                pattern_type=\"Collaboration Detected\",\n                severity=\"High\" if signal.severity == 'high' else \"Medium\",\n                confidence_score=signal.score,\n                participants=signal.participants if signal.participants else [],\n                quiz_id=signal.quiz_id,\n                time_window=(signal.window_start, signal.window_end),\n                evidence={\n                    \"signal_type\": signal.signal_type,\n                    \"signal_details\": signal.details,\n                    \"collaboration_score\": signal.score\n                },\n                status=\"Active\",\n                detected_at=signal.created_at\n            )\n            \n            patterns.append(pattern)\n        \n        return patterns\n    \n    def _calculate_answer_similarity(self, attempt1: QuizAttempt, attempt2: QuizAttempt) -> float:\n        \"\"\"Calculate similarity score between two quiz attempts\"\"\"\n        \n        # Get answers for both attempts\n        answers1 = db.session.query(Answer).filter(Answer.attempt_id == attempt1.id).all()\n        answers2 = db.session.query(Answer).filter(Answer.attempt_id == attempt2.id).all()\n        \n        if not answers1 or not answers2:\n            return 0.0\n        \n        # Create answer mappings by question\n        answer_map1 = {a.question_id: a for a in answers1}\n        answer_map2 = {a.question_id: a for a in answers2}\n        \n        # Compare answers for common questions\n        common_questions = set(answer_map1.keys()) & set(answer_map2.keys())\n        \n        if not common_questions:\n            return 0.0\n        \n        matches = 0\n        total = len(common_questions)\n        \n        for question_id in common_questions:\n            ans1 = answer_map1[question_id]\n            ans2 = answer_map2[question_id]\n            \n            # Compare answer content\n            if ans1.selected_option_id and ans2.selected_option_id:\n                if ans1.selected_option_id == ans2.selected_option_id:\n                    matches += 1\n            elif ans1.answer_text and ans2.answer_text:\n                # For text answers, use similarity threshold\n                similarity = self._text_similarity(ans1.answer_text, ans2.answer_text)\n                if similarity > 0.8:\n                    matches += 1\n        \n        return matches / total if total > 0 else 0.0\n    \n    def _get_matching_answers(self, attempt1: QuizAttempt, attempt2: QuizAttempt) -> List[Dict]:\n        \"\"\"Get detailed information about matching answers\"\"\"\n        \n        answers1 = db.session.query(Answer).filter(Answer.attempt_id == attempt1.id).all()\n        answers2 = db.session.query(Answer).filter(Answer.attempt_id == attempt2.id).all()\n        \n        answer_map1 = {a.question_id: a for a in answers1}\n        answer_map2 = {a.question_id: a for a in answers2}\n        \n        matches = []\n        common_questions = set(answer_map1.keys()) & set(answer_map2.keys())\n        \n        for question_id in common_questions:\n            ans1 = answer_map1[question_id]\n            ans2 = answer_map2[question_id]\n            \n            is_match = False\n            match_type = \"No Match\"\n            \n            if ans1.selected_option_id and ans2.selected_option_id:\n                if ans1.selected_option_id == ans2.selected_option_id:\n                    is_match = True\n                    match_type = \"Identical Option\"\n            elif ans1.answer_text and ans2.answer_text:\n                similarity = self._text_similarity(ans1.answer_text, ans2.answer_text)\n                if similarity > 0.8:\n                    is_match = True\n                    match_type = f\"Text Similarity ({similarity:.2f})\"\n            \n            if is_match:\n                matches.append({\n                    \"question_id\": question_id,\n                    \"match_type\": match_type,\n                    \"answer1\": ans1.selected_option_id or ans1.answer_text,\n                    \"answer2\": ans2.selected_option_id or ans2.answer_text\n                })\n        \n        return matches\n    \n    def _text_similarity(self, text1: str, text2: str) -> float:\n        \"\"\"Calculate text similarity using simple word overlap\"\"\"\n        \n        if not text1 or not text2:\n            return 0.0\n        \n        words1 = set(text1.lower().split())\n        words2 = set(text2.lower().split())\n        \n        if not words1 or not words2:\n            return 0.0\n        \n        intersection = words1 & words2\n        union = words1 | words2\n        \n        return len(intersection) / len(union) if union else 0.0\n    \n    def _extract_behavioral_features(self, interactions: List[InteractionEvent]) -> List[float]:\n        \"\"\"Extract behavioral features from interaction events\"\"\"\n        \n        features = []\n        \n        # Time-based features\n        timestamps = [i.timestamp for i in interactions]\n        time_gaps = []\n        for i in range(1, len(timestamps)):\n            gap = (timestamps[i] - timestamps[i-1]).total_seconds()\n            time_gaps.append(gap)\n        \n        features.extend([\n            len(interactions),  # Total interactions\n            statistics.mean(time_gaps) if time_gaps else 0,  # Average time between interactions\n            statistics.stdev(time_gaps) if len(time_gaps) > 1 else 0,  # Time gap variance\n            max(time_gaps) if time_gaps else 0,  # Maximum gap\n            min(time_gaps) if time_gaps else 0,  # Minimum gap\n        ])\n        \n        # Interaction type distribution\n        interaction_types = [i.event_type for i in interactions]\n        type_counts = Counter(interaction_types)\n        \n        # Normalize to percentages\n        total_interactions = len(interactions)\n        features.extend([\n            type_counts.get('click', 0) / total_interactions,\n            type_counts.get('focus', 0) / total_interactions,\n            type_counts.get('scroll', 0) / total_interactions,\n            type_counts.get('answer_change', 0) / total_interactions,\n            len(set(interaction_types)) / 6,  # Diversity of interaction types\n        ])\n        \n        # Position-based features\n        positions = [(i.x_coordinate, i.y_coordinate) for i in interactions if i.x_coordinate and i.y_coordinate]\n        if positions:\n            x_coords = [p[0] for p in positions]\n            y_coords = [p[1] for p in positions]\n            \n            features.extend([\n                statistics.stdev(x_coords) if len(x_coords) > 1 else 0,\n                statistics.stdev(y_coords) if len(y_coords) > 1 else 0,\n                max(x_coords) - min(x_coords) if x_coords else 0,\n                max(y_coords) - min(y_coords) if y_coords else 0,\n            ])\n        else:\n            features.extend([0, 0, 0, 0])\n        \n        return features\n    \n    def _describe_anomaly(self, feature_vector: List[float]) -> List[str]:\n        \"\"\"Describe what makes this behavioral pattern anomalous\"\"\"\n        \n        descriptions = []\n        \n        # Analyze specific features\n        if feature_vector[0] < 5:  # Very few interactions\n            descriptions.append(\"Unusually low interaction count\")\n        elif feature_vector[0] > 100:  # Too many interactions\n            descriptions.append(\"Unusually high interaction count\")\n        \n        if feature_vector[1] > 60:  # Long gaps between interactions\n            descriptions.append(\"Extended periods of inactivity\")\n        elif feature_vector[1] < 1:  # Very rapid interactions\n            descriptions.append(\"Abnormally rapid interaction patterns\")\n        \n        if feature_vector[9] < 0.1:  # Low interaction diversity\n            descriptions.append(\"Limited interaction pattern diversity\")\n        \n        if not descriptions:\n            descriptions.append(\"Unusual behavioral pattern detected\")\n        \n        return descriptions\n\nclass InstitutionalDashboard:\n    \"\"\"Real-time institutional dashboard and monitoring\"\"\"\n    \n    def get_real_time_metrics(self) -> InstitutionalMetrics:\n        \"\"\"Get comprehensive real-time institutional metrics\"\"\"\n        \n        try:\n            today = datetime.utcnow().date()\n            today_start = datetime.combine(today, datetime.min.time())\n            \n            # Total students\n            total_students = db.session.query(User).filter(User.role == 'participant').count()\n            \n            # Active students today (had any activity)\n            active_students_today = db.session.query(User).filter(\n                User.role == 'participant',\n                User.id.in_(\n                    db.session.query(QuizAttempt.participant_id).filter(\n                        QuizAttempt.started_at >= today_start\n                    )\n                )\n            ).count()\n            \n            # Quizzes in progress\n            quizzes_in_progress = db.session.query(QuizAttempt).filter(\n                QuizAttempt.status == 'in_progress'\n            ).count()\n            \n            # Completed quizzes today\n            completed_quizzes_today = db.session.query(QuizAttempt).filter(\n                QuizAttempt.completed_at >= today_start,\n                QuizAttempt.status == 'completed'\n            ).count()\n            \n            # Average performance today\n            today_scores = db.session.query(QuizAttempt.score).filter(\n                QuizAttempt.completed_at >= today_start,\n                QuizAttempt.score.isnot(None)\n            ).all()\n            \n            average_performance = statistics.mean([s[0] for s in today_scores]) if today_scores else 0.0\n            \n            # High risk students (using predictive analytics)\n            predictor = PredictiveAnalytics()\n            risk_profiles = predictor.analyze_student_risk()\n            high_risk_students = len([p for p in risk_profiles if p.risk_level in ['High', 'Critical']])\n            \n            # Security alerts today\n            security_alerts_today = db.session.query(SecurityAlert).filter(\n                SecurityAlert.created_at >= today_start\n            ).count()\n            \n            # System uptime (simplified - would be more complex in production)\n            system_uptime = 99.5  # Placeholder\n            \n            # Concurrent users (simplified - would use real session tracking)\n            concurrent_users = db.session.query(QuizAttempt).filter(\n                QuizAttempt.status == 'in_progress'\n            ).count()\n            \n            # Violation rate\n            total_attempts_today = db.session.query(QuizAttempt).filter(\n                QuizAttempt.started_at >= today_start\n            ).count()\n            \n            violated_attempts = db.session.query(QuizAttempt).filter(\n                QuizAttempt.started_at >= today_start,\n                QuizAttempt.is_flagged == True\n            ).count()\n            \n            violation_rate = (violated_attempts / total_attempts_today * 100) if total_attempts_today > 0 else 0\n            \n            return InstitutionalMetrics(\n                total_students=total_students,\n                active_students_today=active_students_today,\n                quizzes_in_progress=quizzes_in_progress,\n                completed_quizzes_today=completed_quizzes_today,\n                average_performance=round(average_performance, 2),\n                high_risk_students=high_risk_students,\n                security_alerts_today=security_alerts_today,\n                system_uptime=system_uptime,\n                concurrent_users=concurrent_users,\n                violation_rate=round(violation_rate, 2)\n            )\n            \n        except Exception as e:\n            logging.error(f\"Error generating institutional metrics: {e}\")\n            return InstitutionalMetrics(\n                total_students=0, active_students_today=0, quizzes_in_progress=0,\n                completed_quizzes_today=0, average_performance=0.0, high_risk_students=0,\n                security_alerts_today=0, system_uptime=0.0, concurrent_users=0, violation_rate=0.0\n            )\n    \n    def get_live_monitoring_data(self) -> Dict[str, Any]:\n        \"\"\"Get live monitoring data for real-time dashboard updates\"\"\"\n        \n        try:\n            # Current active sessions\n            active_sessions = db.session.query(QuizAttempt).filter(\n                QuizAttempt.status == 'in_progress'\n            ).options(joinedload(QuizAttempt.participant), joinedload(QuizAttempt.quiz)).all()\n            \n            # Recent alerts (last hour)\n            recent_alerts = db.session.query(SecurityAlert).filter(\n                SecurityAlert.created_at >= datetime.utcnow() - timedelta(hours=1)\n            ).order_by(SecurityAlert.created_at.desc()).limit(10).all()\n            \n            # Performance trends (last 24 hours)\n            performance_data = self._get_performance_trends()\n            \n            # System health metrics\n            system_health = self._get_system_health()\n            \n            return {\n                'active_sessions': [\n                    {\n                        'attempt_id': session.id,\n                        'participant': session.participant.username,\n                        'quiz': session.quiz.title,\n                        'started_at': session.started_at.isoformat(),\n                        'duration_minutes': (datetime.utcnow() - session.started_at).total_seconds() / 60\n                    }\n                    for session in active_sessions\n                ],\n                'recent_alerts': [\n                    {\n                        'id': alert.id,\n                        'type': alert.alert_type,\n                        'severity': alert.severity,\n                        'user_id': alert.user_id,\n                        'description': alert.description,\n                        'created_at': alert.created_at.isoformat()\n                    }\n                    for alert in recent_alerts\n                ],\n                'performance_trends': performance_data,\n                'system_health': system_health,\n                'last_updated': datetime.utcnow().isoformat()\n            }\n            \n        except Exception as e:\n            logging.error(f\"Error generating live monitoring data: {e}\")\n            return {\n                'active_sessions': [],\n                'recent_alerts': [],\n                'performance_trends': {},\n                'system_health': {},\n                'last_updated': datetime.utcnow().isoformat(),\n                'error': str(e)\n            }\n    \n    def _get_performance_trends(self) -> Dict[str, Any]:\n        \"\"\"Get performance trend data for the last 24 hours\"\"\"\n        \n        end_time = datetime.utcnow()\n        start_time = end_time - timedelta(hours=24)\n        \n        # Hourly completion counts\n        hourly_completions = db.session.query(\n            func.date_trunc('hour', QuizAttempt.completed_at).label('hour'),\n            func.count(QuizAttempt.id).label('count'),\n            func.avg(QuizAttempt.score).label('avg_score')\n        ).filter(\n            QuizAttempt.completed_at >= start_time,\n            QuizAttempt.completed_at <= end_time,\n            QuizAttempt.status == 'completed'\n        ).group_by('hour').order_by('hour').all()\n        \n        return {\n            'hourly_data': [\n                {\n                    'hour': row.hour.isoformat(),\n                    'completions': row.count,\n                    'average_score': round(float(row.avg_score), 2) if row.avg_score else 0\n                }\n                for row in hourly_completions\n            ]\n        }\n    \n    def _get_system_health(self) -> Dict[str, Any]:\n        \"\"\"Get system health metrics\"\"\"\n        \n        # Database connection health\n        try:\n            db.session.execute(text('SELECT 1'))\n            db_health = 'healthy'\n        except Exception:\n            db_health = 'unhealthy'\n        \n        # Recent error rates\n        recent_errors = db.session.query(SecurityAlert).filter(\n            SecurityAlert.created_at >= datetime.utcnow() - timedelta(hours=1),\n            SecurityAlert.severity == 'critical'\n        ).count()\n        \n        return {\n            'database_status': db_health,\n            'critical_errors_last_hour': recent_errors,\n            'system_load': 'normal',  # Placeholder - would integrate with system monitoring\n            'memory_usage': 75.5,  # Placeholder\n            'disk_usage': 45.2,  # Placeholder\n            'last_checked': datetime.utcnow().isoformat()\n        }\n\n# Main Analytics Engine\nclass AnalyticsEngine:\n    \"\"\"Main analytics engine coordinating all analysis modules\"\"\"\n    \n    def __init__(self):\n        self.predictive_analytics = PredictiveAnalytics()\n        self.question_analyzer = QuestionPerformanceAnalyzer()\n        self.cheating_detector = CheatingPatternDetector()\n        self.dashboard = InstitutionalDashboard()\n    \n    def generate_comprehensive_report(self, scope: str = 'institutional') -> Dict[str, Any]:\n        \"\"\"Generate comprehensive analytics report\"\"\"\n        \n        try:\n            report = {\n                'report_id': f'analytics_report_{datetime.utcnow().strftime(\"%Y%m%d_%H%M%S\")}',\n                'generated_at': datetime.utcnow().isoformat(),\n                'scope': scope,\n                'predictive_analytics': {},\n                'question_performance': {},\n                'cheating_patterns': {},\n                'institutional_metrics': {}\n            }\n            \n            # Student risk analysis\n            risk_profiles = self.predictive_analytics.analyze_student_risk()\n            report['predictive_analytics'] = {\n                'total_students_analyzed': len(risk_profiles),\n                'high_risk_students': len([p for p in risk_profiles if p.risk_level in ['High', 'Critical']]),\n                'risk_distribution': Counter(p.risk_level for p in risk_profiles),\n                'top_risk_factors': self._get_top_risk_factors(risk_profiles),\n                'intervention_recommendations': self._get_intervention_summary(risk_profiles)\n            }\n            \n            # Question performance analysis\n            question_analytics = self.question_analyzer.analyze_question_performance()\n            report['question_performance'] = {\n                'questions_analyzed': len(question_analytics),\n                'questions_needing_revision': len([q for q in question_analytics if q.revision_needed]),\n                'difficulty_distribution': Counter(q.difficulty_level for q in question_analytics),\n                'performance_categories': Counter(q.performance_category for q in question_analytics),\n                'average_discrimination_index': statistics.mean([q.discrimination_index for q in question_analytics]) if question_analytics else 0\n            }\n            \n            # Cheating pattern detection\n            cheating_patterns = self.cheating_detector.detect_cheating_patterns()\n            report['cheating_patterns'] = {\n                'patterns_detected': len(cheating_patterns),\n                'pattern_types': Counter(p.pattern_type for p in cheating_patterns),\n                'severity_distribution': Counter(p.severity for p in cheating_patterns),\n                'students_involved': len(set(user_id for p in cheating_patterns for user_id in p.participants))\n            }\n            \n            # Institutional metrics\n            institutional_metrics = self.dashboard.get_real_time_metrics()\n            report['institutional_metrics'] = {\n                'total_students': institutional_metrics.total_students,\n                'active_students_today': institutional_metrics.active_students_today,\n                'average_performance': institutional_metrics.average_performance,\n                'violation_rate': institutional_metrics.violation_rate,\n                'system_uptime': institutional_metrics.system_uptime\n            }\n            \n            return report\n            \n        except Exception as e:\n            logging.error(f\"Error generating comprehensive analytics report: {e}\")\n            return {'error': str(e)}\n    \n    def _get_top_risk_factors(self, risk_profiles: List[StudentRiskProfile]) -> List[Tuple[str, int]]:\n        \"\"\"Get most common risk factors across all students\"\"\"\n        \n        all_factors = []\n        for profile in risk_profiles:\n            all_factors.extend(profile.risk_factors)\n        \n        factor_counts = Counter(all_factors)\n        return factor_counts.most_common(10)\n    \n    def _get_intervention_summary(self, risk_profiles: List[StudentRiskProfile]) -> Dict[str, int]:\n        \"\"\"Summarize intervention recommendations\"\"\"\n        \n        all_interventions = []\n        for profile in risk_profiles:\n            all_interventions.extend(profile.intervention_recommendations)\n        \n        intervention_counts = Counter(all_interventions)\n        return dict(intervention_counts.most_common(10))\n\n# Factory function for easy access\ndef get_analytics_engine():\n    \"\"\"Get initialized analytics engine instance\"\"\"\n    return AnalyticsEngine()","size_bytes":64692},"static/css/accessibility-features.css":{"content":"/*\nBigBossizzz Accessibility Features\nComprehensive accessibility support for screen readers, keyboard navigation, and inclusive design\n*/\n\n/* Screen Reader Only Content */\n.sr-only {\n    position: absolute !important;\n    width: 1px !important;\n    height: 1px !important;\n    padding: 0 !important;\n    margin: -1px !important;\n    overflow: hidden !important;\n    clip: rect(0, 0, 0, 0) !important;\n    white-space: nowrap !important;\n    border: 0 !important;\n}\n\n.sr-only-focusable:focus,\n.sr-only-focusable:active {\n    position: static !important;\n    width: auto !important;\n    height: auto !important;\n    padding: 0.5rem 1rem !important;\n    margin: 0 !important;\n    overflow: visible !important;\n    clip: auto !important;\n    white-space: normal !important;\n    background-color: var(--primary-bg) !important;\n    color: var(--text-primary) !important;\n    border: 2px solid var(--focus-ring) !important;\n    border-radius: 4px !important;\n    font-size: 1rem !important;\n    z-index: 100000 !important;\n}\n\n/* Skip Links */\n.skip-links {\n    position: absolute;\n    top: -40px;\n    left: 6px;\n    z-index: 1000;\n}\n\n.skip-link {\n    display: inline-block;\n    padding: 8px 16px;\n    background-color: var(--btn-primary-bg);\n    color: white;\n    text-decoration: none;\n    border-radius: 4px;\n    font-weight: bold;\n    transition: top 0.3s ease;\n}\n\n.skip-link:focus {\n    top: 6px;\n    color: white;\n    text-decoration: none;\n}\n\n/* Enhanced Focus Indicators */\n.focus-enhanced:focus,\n.btn:focus,\n.form-control:focus,\n.form-select:focus,\n.nav-link:focus,\n.dropdown-item:focus,\n.quiz-option:focus,\n.pagination .page-link:focus,\n.breadcrumb-item a:focus {\n    outline: 3px solid var(--focus-ring) !important;\n    outline-offset: 2px !important;\n    box-shadow: 0 0 0 1px var(--primary-bg), 0 0 0 4px var(--focus-ring) !important;\n    border-radius: 4px;\n}\n\n/* High Contrast Focus for Better Visibility */\n@media (prefers-contrast: high) {\n    .focus-enhanced:focus,\n    .btn:focus,\n    .form-control:focus,\n    .form-select:focus,\n    .nav-link:focus,\n    .dropdown-item:focus,\n    .quiz-option:focus {\n        outline: 4px solid #ffff00 !important;\n        outline-offset: 2px !important;\n        background-color: #000000 !important;\n        color: #ffffff !important;\n    }\n}\n\n/* Keyboard Navigation Indicators */\n.keyboard-nav-active *:focus {\n    outline: 2px solid var(--focus-ring) !important;\n    outline-offset: 2px !important;\n}\n\n.mouse-nav-active *:focus {\n    outline: none !important;\n}\n\n/* Quiz Accessibility */\n.quiz-question {\n    scroll-margin-top: 100px; /* For smooth scrolling to questions */\n}\n\n.quiz-option {\n    position: relative;\n    cursor: pointer;\n    border: 2px solid transparent;\n    transition: all 0.2s ease;\n}\n\n.quiz-option:hover {\n    border-color: var(--border-color);\n    background-color: var(--quiz-option-hover);\n}\n\n.quiz-option:focus {\n    border-color: var(--focus-ring);\n    background-color: var(--quiz-option-hover);\n}\n\n.quiz-option.selected {\n    border-color: var(--btn-primary-bg);\n    background-color: var(--quiz-option-selected);\n}\n\n.quiz-option[aria-checked=\"true\"]::before {\n    content: \"‚úì \";\n    font-weight: bold;\n    color: var(--btn-success-bg);\n    margin-right: 0.5rem;\n}\n\n/* Form Labels and Descriptions */\n.form-label {\n    font-weight: 600;\n    margin-bottom: 0.5rem;\n    display: block;\n}\n\n.form-help {\n    font-size: 0.875rem;\n    color: var(--text-muted);\n    margin-top: 0.25rem;\n}\n\n.required::after {\n    content: \" *\";\n    color: var(--btn-danger-bg);\n    font-weight: bold;\n}\n\n/* Error States */\n.form-control.is-invalid,\n.form-select.is-invalid {\n    border-color: var(--btn-danger-bg) !important;\n    background-image: none;\n}\n\n.form-control.is-invalid:focus,\n.form-select.is-invalid:focus {\n    border-color: var(--btn-danger-bg) !important;\n    box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25) !important;\n}\n\n.invalid-feedback {\n    color: var(--btn-danger-bg);\n    font-size: 0.875rem;\n    margin-top: 0.25rem;\n    display: block;\n}\n\n/* Loading States */\n.loading {\n    position: relative;\n    pointer-events: none;\n    opacity: 0.6;\n}\n\n.loading::after {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 1rem;\n    height: 1rem;\n    margin: -0.5rem 0 0 -0.5rem;\n    border: 2px solid transparent;\n    border-top: 2px solid var(--btn-primary-bg);\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Accessible Tables */\n.table-responsive {\n    border: 1px solid var(--border-color);\n    border-radius: 4px;\n}\n\n.table th {\n    background-color: var(--secondary-bg);\n    border-bottom: 2px solid var(--border-color);\n    font-weight: 600;\n}\n\n.table caption {\n    caption-side: top;\n    padding: 0.75rem;\n    color: var(--text-primary);\n    text-align: left;\n    font-weight: 600;\n}\n\n/* Modal Accessibility */\n.modal {\n    display: none;\n}\n\n.modal.show {\n    display: block;\n}\n\n.modal-backdrop {\n    position: fixed;\n    top: 0;\n    left: 0;\n    z-index: 1040;\n    width: 100vw;\n    height: 100vh;\n    background-color: rgba(0, 0, 0, 0.5);\n}\n\n.modal-dialog {\n    position: relative;\n    margin: 1.75rem auto;\n    max-width: 500px;\n    pointer-events: none;\n}\n\n.modal-content {\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    pointer-events: auto;\n    background-color: var(--modal-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 0.5rem;\n    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);\n}\n\n/* Navigation Breadcrumbs */\n.breadcrumb {\n    background-color: var(--secondary-bg);\n    border-radius: 4px;\n    padding: 0.75rem 1rem;\n}\n\n.breadcrumb-item + .breadcrumb-item::before {\n    content: \">\";\n    color: var(--text-muted);\n    padding: 0 0.5rem;\n}\n\n.breadcrumb-item.active {\n    color: var(--text-muted);\n}\n\n/* Pagination Accessibility */\n.pagination {\n    margin: 0;\n}\n\n.page-link {\n    position: relative;\n    color: var(--btn-primary-bg);\n    background-color: var(--card-bg);\n    border: 1px solid var(--border-color);\n    padding: 0.5rem 0.75rem;\n    text-decoration: none;\n}\n\n.page-link:hover {\n    color: var(--btn-primary-hover);\n    background-color: var(--secondary-bg);\n    border-color: var(--border-color);\n}\n\n.page-item.active .page-link {\n    color: white;\n    background-color: var(--btn-primary-bg);\n    border-color: var(--btn-primary-bg);\n}\n\n.page-item.disabled .page-link {\n    color: var(--text-muted);\n    background-color: var(--card-bg);\n    border-color: var(--border-color);\n    pointer-events: none;\n}\n\n/* Card Accessibility */\n.card {\n    border: 1px solid var(--border-color);\n    border-radius: 0.5rem;\n}\n\n.card-header {\n    background-color: var(--secondary-bg);\n    border-bottom: 1px solid var(--border-color);\n    padding: 0.75rem 1rem;\n    font-weight: 600;\n}\n\n/* Alert Accessibility */\n.alert {\n    position: relative;\n    padding: 0.75rem 1rem;\n    margin-bottom: 1rem;\n    border: 1px solid transparent;\n    border-radius: 0.5rem;\n}\n\n.alert-dismissible .btn-close {\n    position: absolute;\n    top: 0;\n    right: 0;\n    z-index: 2;\n    padding: 0.9375rem 0.75rem;\n}\n\n/* Progress Indicators */\n.progress {\n    height: 1rem;\n    background-color: var(--secondary-bg);\n    border-radius: 0.5rem;\n    overflow: hidden;\n}\n\n.progress-bar {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    color: white;\n    text-align: center;\n    white-space: nowrap;\n    background-color: var(--btn-primary-bg);\n    transition: width 0.6s ease;\n}\n\n/* Tooltip Accessibility */\n.tooltip {\n    position: absolute;\n    z-index: 1070;\n    display: block;\n    margin: 0;\n    font-size: 0.875rem;\n    word-wrap: break-word;\n    opacity: 0.9;\n}\n\n.tooltip .tooltip-inner {\n    max-width: 200px;\n    padding: 0.25rem 0.5rem;\n    color: white;\n    text-align: center;\n    background-color: rgba(0, 0, 0, 0.9);\n    border-radius: 0.25rem;\n}\n\n/* Voice Command Indicators */\n.voice-command-active {\n    border: 3px solid var(--btn-success-bg) !important;\n    animation: pulse-success 1.5s infinite;\n}\n\n.voice-command-listening {\n    border: 3px solid var(--btn-warning-bg) !important;\n    animation: pulse-warning 1s infinite;\n}\n\n.voice-command-error {\n    border: 3px solid var(--btn-danger-bg) !important;\n    animation: pulse-danger 0.5s 3;\n}\n\n@keyframes pulse-success {\n    0% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7); }\n    70% { box-shadow: 0 0 0 10px rgba(25, 135, 84, 0); }\n    100% { box-shadow: 0 0 0 0 rgba(25, 135, 84, 0); }\n}\n\n@keyframes pulse-warning {\n    0% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }\n    70% { box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }\n    100% { box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }\n}\n\n@keyframes pulse-danger {\n    0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }\n    70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }\n    100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }\n}\n\n/* Responsive Design for Accessibility */\n@media (max-width: 768px) {\n    .skip-links {\n        left: 3px;\n        right: 3px;\n    }\n    \n    .skip-link {\n        display: block;\n        margin-bottom: 3px;\n        text-align: center;\n    }\n    \n    .modal-dialog {\n        margin: 0.5rem;\n    }\n    \n    .form-control, .form-select {\n        font-size: 16px; /* Prevent zoom on iOS */\n    }\n}\n\n/* Print Accessibility */\n@media print {\n    .skip-links,\n    .navbar,\n    .sidebar,\n    .btn,\n    .modal,\n    .tooltip {\n        display: none !important;\n    }\n    \n    .sr-only {\n        position: static !important;\n        width: auto !important;\n        height: auto !important;\n        margin: 0 !important;\n        overflow: visible !important;\n        clip: auto !important;\n        white-space: normal !important;\n    }\n    \n    a[href]:after {\n        content: \" (\" attr(href) \")\";\n        font-size: 0.8em;\n    }\n    \n    .page-break {\n        page-break-before: always;\n    }\n}\n\n/* Motion Accessibility */\n@media (prefers-reduced-motion: reduce) {\n    .loading::after,\n    .voice-command-active,\n    .voice-command-listening,\n    .voice-command-error {\n        animation: none !important;\n    }\n    \n    .progress-bar {\n        transition: none !important;\n    }\n    \n    * {\n        animation-duration: 0.01ms !important;\n        animation-iteration-count: 1 !important;\n        transition-duration: 0.01ms !important;\n        scroll-behavior: auto !important;\n    }\n}\n\n/* Color Contrast Enhancements */\n@media (prefers-contrast: high) {\n    :root {\n        --focus-ring: #ffff00;\n        --btn-primary-bg: #0000ff;\n        --btn-primary-hover: #000080;\n        --text-primary: #000000;\n        --border-color: #000000;\n    }\n    \n    [data-theme=\"dark\"] {\n        --focus-ring: #ffff00;\n        --btn-primary-bg: #00ffff;\n        --btn-primary-hover: #00cccc;\n        --text-primary: #ffffff;\n        --border-color: #ffffff;\n    }\n    \n    .btn {\n        border-width: 2px !important;\n        font-weight: bold !important;\n    }\n    \n    .form-control, .form-select {\n        border-width: 2px !important;\n    }\n}","size_bytes":11090},"static/css/mobile-enhancements.css":{"content":"/*\nBigBossizzz Mobile App Enhancements\nAdvanced responsive design with Progressive Web App features\n*/\n\n/* ===== Progressive Web App Base Styles ===== */\n:root {\n    --mobile-primary: #4a5568;\n    --mobile-secondary: #718096;\n    --mobile-accent: #3182ce;\n    --mobile-success: #38a169;\n    --mobile-warning: #d69e2e;\n    --mobile-danger: #e53e3e;\n    --mobile-background: #f7fafc;\n    --mobile-surface: #ffffff;\n    --mobile-text: #2d3748;\n    --mobile-border: #e2e8f0;\n    --mobile-shadow: rgba(0, 0, 0, 0.1);\n    --mobile-header-height: 60px;\n    --mobile-bottom-nav-height: 70px;\n    --mobile-touch-target: 48px;\n}\n\n/* PWA Splash Screen Styles */\n.pwa-splash {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(135deg, var(--mobile-primary), var(--mobile-accent));\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    z-index: 9999;\n    color: white;\n    opacity: 1;\n    transition: opacity 0.5s ease;\n}\n\n.pwa-splash.hidden {\n    opacity: 0;\n    pointer-events: none;\n}\n\n.pwa-splash .logo {\n    font-size: 3rem;\n    font-weight: bold;\n    margin-bottom: 1rem;\n    animation: pulse 2s infinite;\n}\n\n.pwa-splash .loading {\n    font-size: 1.2rem;\n    margin-top: 2rem;\n}\n\n/* ===== Enhanced Mobile Navigation ===== */\n@media (max-width: 768px) {\n    /* Mobile Header Optimization */\n    .navbar {\n        height: var(--mobile-header-height);\n        padding: 0 1rem;\n        box-shadow: 0 2px 10px var(--mobile-shadow);\n        backdrop-filter: blur(10px);\n        -webkit-backdrop-filter: blur(10px);\n        position: sticky;\n        top: 0;\n        z-index: 1020;\n    }\n    \n    .navbar-brand {\n        font-size: 1.3rem;\n        font-weight: 700;\n        color: var(--mobile-primary) !important;\n    }\n    \n    /* Mobile Menu Toggle */\n    .navbar-toggler {\n        border: none;\n        padding: 0.5rem;\n        font-size: 1.2rem;\n        background: var(--mobile-surface);\n        border-radius: 8px;\n        box-shadow: 0 2px 8px var(--mobile-shadow);\n        transition: all 0.3s ease;\n    }\n    \n    .navbar-toggler:focus {\n        box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.25);\n    }\n    \n    .navbar-toggler:not(.collapsed) {\n        background: var(--mobile-accent);\n        color: white;\n    }\n    \n    /* Enhanced Mobile Dropdown */\n    .navbar-collapse {\n        background: var(--mobile-surface);\n        border-radius: 12px;\n        margin-top: 10px;\n        box-shadow: 0 8px 32px var(--mobile-shadow);\n        border: 1px solid var(--mobile-border);\n        backdrop-filter: blur(10px);\n        -webkit-backdrop-filter: blur(10px);\n    }\n    \n    .navbar-nav .nav-link {\n        padding: 1rem 1.5rem;\n        color: var(--mobile-text) !important;\n        font-weight: 500;\n        border-bottom: 1px solid var(--mobile-border);\n        transition: all 0.3s ease;\n        display: flex;\n        align-items: center;\n        min-height: var(--mobile-touch-target);\n    }\n    \n    .navbar-nav .nav-link:hover,\n    .navbar-nav .nav-link:focus {\n        background: var(--mobile-background);\n        color: var(--mobile-accent) !important;\n        transform: translateX(8px);\n    }\n    \n    .navbar-nav .nav-link:last-child {\n        border-bottom: none;\n        border-radius: 0 0 12px 12px;\n    }\n    \n    .navbar-nav .nav-link i {\n        margin-right: 12px;\n        font-size: 1.1rem;\n        width: 20px;\n        text-align: center;\n    }\n}\n\n/* ===== Mobile Bottom Navigation ===== */\n@media (max-width: 768px) {\n    .mobile-bottom-nav {\n        position: fixed;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        height: var(--mobile-bottom-nav-height);\n        background: var(--mobile-surface);\n        border-top: 1px solid var(--mobile-border);\n        display: flex;\n        justify-content: space-around;\n        align-items: center;\n        z-index: 1010;\n        backdrop-filter: blur(10px);\n        -webkit-backdrop-filter: blur(10px);\n        box-shadow: 0 -2px 20px var(--mobile-shadow);\n    }\n    \n    .mobile-nav-item {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        padding: 8px 12px;\n        color: var(--mobile-secondary);\n        text-decoration: none;\n        transition: all 0.3s ease;\n        border-radius: 12px;\n        min-width: var(--mobile-touch-target);\n        min-height: var(--mobile-touch-target);\n        justify-content: center;\n    }\n    \n    .mobile-nav-item:hover,\n    .mobile-nav-item:focus,\n    .mobile-nav-item.active {\n        color: var(--mobile-accent);\n        background: rgba(49, 130, 206, 0.1);\n        text-decoration: none;\n        transform: translateY(-2px);\n    }\n    \n    .mobile-nav-item i {\n        font-size: 1.2rem;\n        margin-bottom: 4px;\n    }\n    \n    .mobile-nav-item span {\n        font-size: 0.7rem;\n        font-weight: 500;\n    }\n    \n    /* Badge for notifications */\n    .mobile-nav-item .badge {\n        position: absolute;\n        top: 5px;\n        right: 8px;\n        background: var(--mobile-danger);\n        color: white;\n        border-radius: 50%;\n        width: 18px;\n        height: 18px;\n        font-size: 0.6rem;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    /* Adjust body padding for bottom navigation */\n    body.mobile-nav-enabled {\n        padding-bottom: var(--mobile-bottom-nav-height);\n    }\n}\n\n/* ===== Enhanced Quiz Interface for Mobile ===== */\n@media (max-width: 768px) {\n    .quiz-container {\n        padding: 1rem 0.75rem;\n        margin-bottom: var(--mobile-bottom-nav-height);\n    }\n    \n    .quiz-header {\n        background: var(--mobile-surface);\n        border-radius: 16px;\n        padding: 1.5rem;\n        margin-bottom: 1rem;\n        box-shadow: 0 4px 16px var(--mobile-shadow);\n        border: 1px solid var(--mobile-border);\n    }\n    \n    .quiz-progress {\n        background: var(--mobile-background);\n        border-radius: 12px;\n        padding: 1rem;\n        margin-bottom: 1rem;\n    }\n    \n    .progress {\n        height: 12px;\n        border-radius: 6px;\n        background: var(--mobile-border);\n        overflow: hidden;\n    }\n    \n    .progress-bar {\n        background: linear-gradient(90deg, var(--mobile-success), var(--mobile-accent));\n        transition: width 0.5s ease;\n    }\n    \n    .question-card {\n        background: var(--mobile-surface);\n        border-radius: 20px;\n        padding: 1.5rem;\n        margin-bottom: 1.5rem;\n        box-shadow: 0 8px 32px var(--mobile-shadow);\n        border: 1px solid var(--mobile-border);\n        transform: translateY(0);\n        transition: all 0.3s ease;\n    }\n    \n    .question-card.active {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 48px rgba(49, 130, 206, 0.15);\n        border-color: var(--mobile-accent);\n    }\n    \n    .question-number {\n        background: linear-gradient(135deg, var(--mobile-accent), var(--mobile-primary));\n        color: white;\n        border-radius: 12px;\n        padding: 0.5rem 1rem;\n        font-weight: 600;\n        display: inline-block;\n        margin-bottom: 1rem;\n        font-size: 0.9rem;\n    }\n    \n    .question-text {\n        font-size: 1.1rem;\n        line-height: 1.6;\n        color: var(--mobile-text);\n        margin-bottom: 1.5rem;\n        font-weight: 500;\n    }\n    \n    /* Enhanced Answer Options */\n    .form-check {\n        background: var(--mobile-background);\n        border-radius: 12px;\n        padding: 1rem;\n        margin-bottom: 0.75rem;\n        border: 2px solid var(--mobile-border);\n        transition: all 0.3s ease;\n        cursor: pointer;\n        min-height: var(--mobile-touch-target);\n        display: flex;\n        align-items: center;\n    }\n    \n    .form-check:hover {\n        background: var(--mobile-surface);\n        border-color: var(--mobile-accent);\n        transform: translateX(4px);\n    }\n    \n    .form-check.checked {\n        background: rgba(49, 130, 206, 0.1);\n        border-color: var(--mobile-accent);\n        box-shadow: 0 4px 12px rgba(49, 130, 206, 0.2);\n    }\n    \n    .form-check-input {\n        margin-right: 1rem;\n        transform: scale(1.3);\n        accent-color: var(--mobile-accent);\n    }\n    \n    .form-check-label {\n        font-size: 1rem;\n        line-height: 1.5;\n        color: var(--mobile-text);\n        cursor: pointer;\n        flex: 1;\n        font-weight: 500;\n    }\n    \n    /* Text Input Enhancement */\n    .form-control {\n        font-size: 16px !important; /* Prevents iOS zoom */\n        padding: 1rem;\n        border-radius: 12px;\n        border: 2px solid var(--mobile-border);\n        background: var(--mobile-surface);\n        transition: all 0.3s ease;\n        min-height: var(--mobile-touch-target);\n    }\n    \n    .form-control:focus {\n        border-color: var(--mobile-accent);\n        box-shadow: 0 0 0 4px rgba(49, 130, 206, 0.1);\n        outline: none;\n    }\n    \n    textarea.form-control {\n        resize: vertical;\n        min-height: 120px;\n    }\n}\n\n/* ===== Mobile Action Buttons ===== */\n@media (max-width: 768px) {\n    .mobile-actions {\n        position: fixed;\n        bottom: calc(var(--mobile-bottom-nav-height) + 1rem);\n        left: 1rem;\n        right: 1rem;\n        z-index: 1000;\n    }\n    \n    .btn-mobile {\n        width: 100%;\n        padding: 1rem 2rem;\n        font-size: 1.1rem;\n        font-weight: 600;\n        border-radius: 16px;\n        border: none;\n        transition: all 0.3s ease;\n        position: relative;\n        overflow: hidden;\n        min-height: var(--mobile-touch-target);\n        margin-bottom: 0.75rem;\n        box-shadow: 0 4px 16px var(--mobile-shadow);\n    }\n    \n    .btn-mobile::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: -100%;\n        width: 100%;\n        height: 100%;\n        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);\n        transition: left 0.5s ease;\n    }\n    \n    .btn-mobile:hover::before,\n    .btn-mobile:focus::before {\n        left: 100%;\n    }\n    \n    .btn-primary.btn-mobile {\n        background: linear-gradient(135deg, var(--mobile-accent), var(--mobile-primary));\n        color: white;\n    }\n    \n    .btn-primary.btn-mobile:hover,\n    .btn-primary.btn-mobile:focus {\n        transform: translateY(-2px);\n        box-shadow: 0 8px 24px rgba(49, 130, 206, 0.3);\n    }\n    \n    .btn-secondary.btn-mobile {\n        background: var(--mobile-surface);\n        color: var(--mobile-text);\n        border: 2px solid var(--mobile-border);\n    }\n    \n    .btn-secondary.btn-mobile:hover,\n    .btn-secondary.btn-mobile:focus {\n        background: var(--mobile-background);\n        border-color: var(--mobile-accent);\n        color: var(--mobile-accent);\n    }\n    \n    .btn-success.btn-mobile {\n        background: linear-gradient(135deg, var(--mobile-success), #2f855a);\n        color: white;\n    }\n    \n    .btn-danger.btn-mobile {\n        background: linear-gradient(135deg, var(--mobile-danger), #c53030);\n        color: white;\n    }\n}\n\n/* ===== Mobile Proctoring Interface ===== */\n@media (max-width: 768px) {\n    .mobile-proctoring-panel {\n        position: fixed;\n        top: var(--mobile-header-height);\n        left: 0;\n        right: 0;\n        background: var(--mobile-surface);\n        border-bottom: 1px solid var(--mobile-border);\n        padding: 1rem;\n        z-index: 1005;\n        backdrop-filter: blur(10px);\n        -webkit-backdrop-filter: blur(10px);\n        transform: translateY(-100%);\n        transition: transform 0.3s ease;\n    }\n    \n    .mobile-proctoring-panel.active {\n        transform: translateY(0);\n    }\n    \n    .proctoring-status-mobile {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        padding: 0.75rem 1rem;\n        background: var(--mobile-background);\n        border-radius: 12px;\n        margin-bottom: 1rem;\n    }\n    \n    .proctoring-status-mobile .status-indicator {\n        width: 12px;\n        height: 12px;\n        border-radius: 50%;\n        margin-right: 0.75rem;\n        animation: pulse 2s infinite;\n    }\n    \n    .proctoring-status-mobile .status-indicator.active {\n        background: var(--mobile-success);\n    }\n    \n    .proctoring-status-mobile .status-indicator.warning {\n        background: var(--mobile-warning);\n    }\n    \n    .proctoring-status-mobile .status-indicator.error {\n        background: var(--mobile-danger);\n    }\n    \n    .mobile-camera-preview {\n        width: 120px;\n        height: 90px;\n        border-radius: 12px;\n        background: #000;\n        border: 2px solid var(--mobile-border);\n        overflow: hidden;\n        position: relative;\n    }\n    \n    .mobile-camera-preview video {\n        width: 100%;\n        height: 100%;\n        object-fit: cover;\n    }\n    \n    .mobile-camera-preview .camera-overlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        background: rgba(0,0,0,0.7);\n        color: white;\n        font-size: 0.8rem;\n    }\n}\n\n/* ===== Mobile Card Stack Interface ===== */\n@media (max-width: 768px) {\n    .mobile-card-stack {\n        position: relative;\n        perspective: 1000px;\n    }\n    \n    .mobile-card {\n        background: var(--mobile-surface);\n        border-radius: 20px;\n        padding: 1.5rem;\n        margin-bottom: 1rem;\n        box-shadow: 0 8px 32px var(--mobile-shadow);\n        border: 1px solid var(--mobile-border);\n        transform-style: preserve-3d;\n        transition: all 0.5s ease;\n        position: relative;\n    }\n    \n    .mobile-card:not(.current) {\n        transform: scale(0.95) rotateY(10deg);\n        opacity: 0.7;\n        pointer-events: none;\n    }\n    \n    .mobile-card.current {\n        transform: scale(1) rotateY(0deg);\n        opacity: 1;\n        z-index: 10;\n    }\n    \n    .mobile-card.next {\n        transform: scale(0.9) rotateY(-5deg) translateX(20px);\n        opacity: 0.5;\n    }\n    \n    .mobile-card.prev {\n        transform: scale(0.9) rotateY(5deg) translateX(-20px);\n        opacity: 0.3;\n    }\n}\n\n/* ===== Mobile Toast Notifications ===== */\n@media (max-width: 768px) {\n    .mobile-toast {\n        position: fixed;\n        top: calc(var(--mobile-header-height) + 1rem);\n        left: 1rem;\n        right: 1rem;\n        z-index: 1030;\n        background: var(--mobile-surface);\n        border-radius: 12px;\n        padding: 1rem;\n        box-shadow: 0 8px 32px var(--mobile-shadow);\n        border: 1px solid var(--mobile-border);\n        transform: translateY(-200%);\n        transition: all 0.4s ease;\n        backdrop-filter: blur(10px);\n        -webkit-backdrop-filter: blur(10px);\n    }\n    \n    .mobile-toast.show {\n        transform: translateY(0);\n    }\n    \n    .mobile-toast.success {\n        border-left: 4px solid var(--mobile-success);\n    }\n    \n    .mobile-toast.warning {\n        border-left: 4px solid var(--mobile-warning);\n    }\n    \n    .mobile-toast.error {\n        border-left: 4px solid var(--mobile-danger);\n    }\n    \n    .mobile-toast .toast-header {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 0.5rem;\n    }\n    \n    .mobile-toast .toast-title {\n        font-weight: 600;\n        color: var(--mobile-text);\n    }\n    \n    .mobile-toast .toast-close {\n        background: none;\n        border: none;\n        font-size: 1.2rem;\n        color: var(--mobile-secondary);\n        cursor: pointer;\n        padding: 0;\n        min-width: var(--mobile-touch-target);\n        min-height: var(--mobile-touch-target);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    .mobile-toast .toast-body {\n        color: var(--mobile-secondary);\n        line-height: 1.5;\n    }\n}\n\n/* ===== Mobile Pull-to-Refresh ===== */\n@media (max-width: 768px) {\n    .mobile-pull-refresh {\n        position: absolute;\n        top: -80px;\n        left: 0;\n        right: 0;\n        height: 80px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        background: var(--mobile-surface);\n        border-radius: 0 0 20px 20px;\n        box-shadow: 0 4px 16px var(--mobile-shadow);\n        transition: all 0.3s ease;\n        z-index: 1000;\n    }\n    \n    .mobile-pull-refresh.active {\n        top: var(--mobile-header-height);\n    }\n    \n    .mobile-pull-refresh .refresh-icon {\n        font-size: 1.5rem;\n        color: var(--mobile-accent);\n        animation: spin 1s linear infinite;\n    }\n    \n    .mobile-pull-refresh .refresh-text {\n        margin-left: 0.75rem;\n        color: var(--mobile-text);\n        font-weight: 500;\n    }\n}\n\n/* ===== Mobile Floating Action Button ===== */\n@media (max-width: 768px) {\n    .mobile-fab {\n        position: fixed;\n        bottom: calc(var(--mobile-bottom-nav-height) + 1rem);\n        right: 1rem;\n        width: 56px;\n        height: 56px;\n        background: linear-gradient(135deg, var(--mobile-accent), var(--mobile-primary));\n        border-radius: 50%;\n        border: none;\n        color: white;\n        font-size: 1.5rem;\n        box-shadow: 0 8px 24px rgba(49, 130, 206, 0.3);\n        z-index: 1010;\n        transition: all 0.3s ease;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    .mobile-fab:hover,\n    .mobile-fab:focus {\n        transform: scale(1.1) rotate(5deg);\n        box-shadow: 0 12px 36px rgba(49, 130, 206, 0.4);\n    }\n    \n    .mobile-fab:active {\n        transform: scale(0.95);\n    }\n}\n\n/* ===== Mobile Accessibility Enhancements ===== */\n@media (max-width: 768px) {\n    /* Focus indicators */\n    .mobile-focus:focus {\n        outline: 3px solid var(--mobile-accent);\n        outline-offset: 2px;\n        box-shadow: 0 0 0 6px rgba(49, 130, 206, 0.1);\n    }\n    \n    /* High contrast mode support */\n    @media (prefers-contrast: high) {\n        :root {\n            --mobile-primary: #000000;\n            --mobile-secondary: #666666;\n            --mobile-accent: #0066cc;\n            --mobile-background: #ffffff;\n            --mobile-surface: #ffffff;\n            --mobile-text: #000000;\n            --mobile-border: #333333;\n        }\n    }\n    \n    /* Reduced motion support */\n    @media (prefers-reduced-motion: reduce) {\n        * {\n            animation-duration: 0.01ms !important;\n            animation-iteration-count: 1 !important;\n            transition-duration: 0.01ms !important;\n        }\n    }\n    \n    /* Dark mode support */\n    @media (prefers-color-scheme: dark) {\n        :root {\n            --mobile-primary: #e2e8f0;\n            --mobile-secondary: #a0aec0;\n            --mobile-accent: #63b3ed;\n            --mobile-background: #1a202c;\n            --mobile-surface: #2d3748;\n            --mobile-text: #f7fafc;\n            --mobile-border: #4a5568;\n            --mobile-shadow: rgba(0, 0, 0, 0.3);\n        }\n    }\n}\n\n/* ===== Mobile Performance Optimizations ===== */\n@media (max-width: 768px) {\n    /* GPU acceleration for smooth animations */\n    .gpu-accelerated {\n        transform: translateZ(0);\n        will-change: transform;\n    }\n    \n    /* Optimized touch targets */\n    .touch-target {\n        min-width: var(--mobile-touch-target);\n        min-height: var(--mobile-touch-target);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n    \n    /* Content loading optimization */\n    .mobile-content {\n        opacity: 0;\n        transform: translateY(20px);\n        transition: all 0.5s ease;\n    }\n    \n    .mobile-content.loaded {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* ===== Animations ===== */\n@keyframes pulse {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.7; }\n}\n\n@keyframes spin {\n    from { transform: rotate(0deg); }\n    to { transform: rotate(360deg); }\n}\n\n@keyframes slideInUp {\n    from {\n        transform: translateY(100%);\n        opacity: 0;\n    }\n    to {\n        transform: translateY(0);\n        opacity: 1;\n    }\n}\n\n@keyframes slideInDown {\n    from {\n        transform: translateY(-100%);\n        opacity: 0;\n    }\n    to {\n        transform: translateY(0);\n        opacity: 1;\n    }\n}\n\n@keyframes fadeInScale {\n    from {\n        transform: scale(0.8);\n        opacity: 0;\n    }\n    to {\n        transform: scale(1);\n        opacity: 1;\n    }\n}\n\n/* ===== Mobile-First Responsive Grid ===== */\n@media (max-width: 768px) {\n    .mobile-grid {\n        display: grid;\n        grid-template-columns: 1fr;\n        gap: 1rem;\n        padding: 1rem;\n    }\n    \n    .mobile-grid-2 {\n        grid-template-columns: 1fr 1fr;\n    }\n    \n    .mobile-grid-auto {\n        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\n    }\n    \n    .mobile-grid-item {\n        background: var(--mobile-surface);\n        border-radius: 16px;\n        padding: 1.5rem;\n        box-shadow: 0 4px 16px var(--mobile-shadow);\n        border: 1px solid var(--mobile-border);\n        transition: all 0.3s ease;\n    }\n    \n    .mobile-grid-item:hover {\n        transform: translateY(-2px);\n        box-shadow: 0 8px 24px var(--mobile-shadow);\n    }\n}","size_bytes":21189},"static/css/theme-system.css":{"content":"/*\nBigBossizzz Theme System\nComplete dark/light theme implementation with user preferences\n*/\n\n:root {\n    /* Light Theme Variables (Default) */\n    --primary-bg: #ffffff;\n    --secondary-bg: #f8f9fa;\n    --tertiary-bg: #e9ecef;\n    --card-bg: #ffffff;\n    --modal-bg: #ffffff;\n    --text-primary: #212529;\n    --text-secondary: #6c757d;\n    --text-muted: #868e96;\n    --text-inverse: #ffffff;\n    --border-color: #dee2e6;\n    --border-light: #e9ecef;\n    --shadow-color: rgba(0, 0, 0, 0.1);\n    --shadow-hover: rgba(0, 0, 0, 0.15);\n    \n    /* Button Colors */\n    --btn-primary-bg: #0d6efd;\n    --btn-primary-hover: #0b5ed7;\n    --btn-secondary-bg: #6c757d;\n    --btn-secondary-hover: #5c636a;\n    --btn-success-bg: #198754;\n    --btn-success-hover: #157347;\n    --btn-danger-bg: #dc3545;\n    --btn-danger-hover: #bb2d3b;\n    --btn-warning-bg: #ffc107;\n    --btn-warning-hover: #ffca2c;\n    --btn-info-bg: #0dcaf0;\n    --btn-info-hover: #31d2f2;\n    \n    /* Form Elements */\n    --input-bg: #ffffff;\n    --input-border: #ced4da;\n    --input-focus: #86b7fe;\n    --input-placeholder: #6c757d;\n    \n    /* Navigation */\n    --navbar-bg: #ffffff;\n    --navbar-text: #212529;\n    --navbar-brand: #0d6efd;\n    --navbar-hover: #f8f9fa;\n    \n    /* Status Colors */\n    --success-bg: #d1edff;\n    --success-text: #0f5132;\n    --error-bg: #f8d7da;\n    --error-text: #721c24;\n    --warning-bg: #fff3cd;\n    --warning-text: #664d03;\n    --info-bg: #cff4fc;\n    --info-text: #055160;\n    \n    /* Quiz Specific */\n    --quiz-bg: #ffffff;\n    --quiz-question-bg: #f8f9fa;\n    --quiz-option-bg: #ffffff;\n    --quiz-option-hover: #e9ecef;\n    --quiz-option-selected: #cfe2ff;\n    --quiz-timer-bg: #ffc107;\n    --quiz-timer-text: #664d03;\n    \n    /* Proctoring */\n    --proctoring-safe: #d4edda;\n    --proctoring-warning: #fff3cd;\n    --proctoring-danger: #f8d7da;\n    --camera-bg: #000000;\n    --violation-bg: #f8d7da;\n    \n    /* Accessibility */\n    --focus-ring: #0d6efd;\n    --focus-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);\n}\n\n/* Dark Theme Variables */\n[data-theme=\"dark\"] {\n    --primary-bg: #121212;\n    --secondary-bg: #1e1e1e;\n    --tertiary-bg: #2d2d2d;\n    --card-bg: #1e1e1e;\n    --modal-bg: #2d2d2d;\n    --text-primary: #ffffff;\n    --text-secondary: #b3b3b3;\n    --text-muted: #8a8a8a;\n    --text-inverse: #121212;\n    --border-color: #404040;\n    --border-light: #353535;\n    --shadow-color: rgba(0, 0, 0, 0.3);\n    --shadow-hover: rgba(0, 0, 0, 0.4);\n    \n    /* Button Colors - Adjusted for dark theme */\n    --btn-primary-bg: #0d6efd;\n    --btn-primary-hover: #3d8bfd;\n    --btn-secondary-bg: #6c757d;\n    --btn-secondary-hover: #858b93;\n    --btn-success-bg: #198754;\n    --btn-success-hover: #20c997;\n    --btn-danger-bg: #dc3545;\n    --btn-danger-hover: #e55763;\n    --btn-warning-bg: #ffc107;\n    --btn-warning-hover: #ffca2c;\n    --btn-info-bg: #0dcaf0;\n    --btn-info-hover: #31d2f2;\n    \n    /* Form Elements */\n    --input-bg: #2d2d2d;\n    --input-border: #404040;\n    --input-focus: #86b7fe;\n    --input-placeholder: #8a8a8a;\n    \n    /* Navigation */\n    --navbar-bg: #1e1e1e;\n    --navbar-text: #ffffff;\n    --navbar-brand: #3d8bfd;\n    --navbar-hover: #2d2d2d;\n    \n    /* Status Colors - Dark theme variants */\n    --success-bg: #0f2419;\n    --success-text: #75dd99;\n    --error-bg: #2c0b0e;\n    --error-text: #f1aeb5;\n    --warning-bg: #332701;\n    --warning-text: #ffda6a;\n    --info-bg: #032830;\n    --info-text: #6edff6;\n    \n    /* Quiz Specific */\n    --quiz-bg: #1e1e1e;\n    --quiz-question-bg: #2d2d2d;\n    --quiz-option-bg: #2d2d2d;\n    --quiz-option-hover: #404040;\n    --quiz-option-selected: #1a365d;\n    --quiz-timer-bg: #332701;\n    --quiz-timer-text: #ffda6a;\n    \n    /* Proctoring */\n    --proctoring-safe: #0f2419;\n    --proctoring-warning: #332701;\n    --proctoring-danger: #2c0b0e;\n    --camera-bg: #000000;\n    --violation-bg: #2c0b0e;\n    \n    /* Accessibility */\n    --focus-ring: #3d8bfd;\n    --focus-shadow: 0 0 0 0.25rem rgba(61, 139, 253, 0.25);\n}\n\n/* Auto Theme (System Preference) */\n@media (prefers-color-scheme: dark) {\n    [data-theme=\"auto\"] {\n        --primary-bg: #121212;\n        --secondary-bg: #1e1e1e;\n        --tertiary-bg: #2d2d2d;\n        --card-bg: #1e1e1e;\n        --modal-bg: #2d2d2d;\n        --text-primary: #ffffff;\n        --text-secondary: #b3b3b3;\n        --text-muted: #8a8a8a;\n        --text-inverse: #121212;\n        --border-color: #404040;\n        --border-light: #353535;\n        --shadow-color: rgba(0, 0, 0, 0.3);\n        --shadow-hover: rgba(0, 0, 0, 0.4);\n        \n        --btn-primary-bg: #0d6efd;\n        --btn-primary-hover: #3d8bfd;\n        --btn-secondary-bg: #6c757d;\n        --btn-secondary-hover: #858b93;\n        --btn-success-bg: #198754;\n        --btn-success-hover: #20c997;\n        --btn-danger-bg: #dc3545;\n        --btn-danger-hover: #e55763;\n        --btn-warning-bg: #ffc107;\n        --btn-warning-hover: #ffca2c;\n        --btn-info-bg: #0dcaf0;\n        --btn-info-hover: #31d2f2;\n        \n        --input-bg: #2d2d2d;\n        --input-border: #404040;\n        --input-focus: #86b7fe;\n        --input-placeholder: #8a8a8a;\n        \n        --navbar-bg: #1e1e1e;\n        --navbar-text: #ffffff;\n        --navbar-brand: #3d8bfd;\n        --navbar-hover: #2d2d2d;\n        \n        --success-bg: #0f2419;\n        --success-text: #75dd99;\n        --error-bg: #2c0b0e;\n        --error-text: #f1aeb5;\n        --warning-bg: #332701;\n        --warning-text: #ffda6a;\n        --info-bg: #032830;\n        --info-text: #6edff6;\n        \n        --quiz-bg: #1e1e1e;\n        --quiz-question-bg: #2d2d2d;\n        --quiz-option-bg: #2d2d2d;\n        --quiz-option-hover: #404040;\n        --quiz-option-selected: #1a365d;\n        --quiz-timer-bg: #332701;\n        --quiz-timer-text: #ffda6a;\n        \n        --proctoring-safe: #0f2419;\n        --proctoring-warning: #332701;\n        --proctoring-danger: #2c0b0e;\n        --camera-bg: #000000;\n        --violation-bg: #2c0b0e;\n        \n        --focus-ring: #3d8bfd;\n        --focus-shadow: 0 0 0 0.25rem rgba(61, 139, 253, 0.25);\n    }\n}\n\n/* Theme Application */\nbody {\n    background-color: var(--primary-bg);\n    color: var(--text-primary);\n    transition: background-color 0.3s ease, color 0.3s ease;\n}\n\n/* Cards and Containers */\n.card, .modal-content, .dropdown-menu {\n    background-color: var(--card-bg);\n    border-color: var(--border-color);\n    color: var(--text-primary);\n}\n\n.bg-light {\n    background-color: var(--secondary-bg) !important;\n}\n\n.bg-white {\n    background-color: var(--card-bg) !important;\n}\n\n/* Text Colors */\n.text-muted {\n    color: var(--text-muted) !important;\n}\n\n.text-secondary {\n    color: var(--text-secondary) !important;\n}\n\n/* Forms */\n.form-control, .form-select {\n    background-color: var(--input-bg);\n    border-color: var(--input-border);\n    color: var(--text-primary);\n}\n\n.form-control:focus, .form-select:focus {\n    background-color: var(--input-bg);\n    border-color: var(--input-focus);\n    box-shadow: var(--focus-shadow);\n    color: var(--text-primary);\n}\n\n.form-control::placeholder {\n    color: var(--input-placeholder);\n}\n\n/* Navigation */\n.navbar {\n    background-color: var(--navbar-bg) !important;\n}\n\n.navbar-brand, .navbar-nav .nav-link {\n    color: var(--navbar-text) !important;\n}\n\n.navbar-brand:hover, .navbar-nav .nav-link:hover {\n    background-color: var(--navbar-hover);\n}\n\n/* Buttons */\n.btn-outline-primary {\n    color: var(--btn-primary-bg);\n    border-color: var(--btn-primary-bg);\n}\n\n.btn-outline-primary:hover {\n    background-color: var(--btn-primary-bg);\n    border-color: var(--btn-primary-hover);\n}\n\n/* Tables */\n.table {\n    color: var(--text-primary);\n}\n\n.table-striped tbody tr:nth-of-type(odd) {\n    background-color: var(--secondary-bg);\n}\n\n/* Alerts */\n.alert-success {\n    background-color: var(--success-bg);\n    color: var(--success-text);\n    border-color: var(--success-text);\n}\n\n.alert-danger {\n    background-color: var(--error-bg);\n    color: var(--error-text);\n    border-color: var(--error-text);\n}\n\n.alert-warning {\n    background-color: var(--warning-bg);\n    color: var(--warning-text);\n    border-color: var(--warning-text);\n}\n\n.alert-info {\n    background-color: var(--info-bg);\n    color: var(--info-text);\n    border-color: var(--info-text);\n}\n\n/* Quiz Specific Styling */\n.quiz-container {\n    background-color: var(--quiz-bg);\n}\n\n.question-card {\n    background-color: var(--quiz-question-bg);\n    border-color: var(--border-color);\n}\n\n.quiz-option {\n    background-color: var(--quiz-option-bg);\n    border-color: var(--border-color);\n    color: var(--text-primary);\n}\n\n.quiz-option:hover {\n    background-color: var(--quiz-option-hover);\n}\n\n.quiz-option.selected {\n    background-color: var(--quiz-option-selected);\n    border-color: var(--btn-primary-bg);\n}\n\n.quiz-timer {\n    background-color: var(--quiz-timer-bg);\n    color: var(--quiz-timer-text);\n}\n\n/* Proctoring Interface */\n.proctoring-status.safe {\n    background-color: var(--proctoring-safe);\n    color: var(--success-text);\n}\n\n.proctoring-status.warning {\n    background-color: var(--proctoring-warning);\n    color: var(--warning-text);\n}\n\n.proctoring-status.danger {\n    background-color: var(--proctoring-danger);\n    color: var(--error-text);\n}\n\n.camera-preview {\n    background-color: var(--camera-bg);\n    border-color: var(--border-color);\n}\n\n.violation-alert {\n    background-color: var(--violation-bg);\n    color: var(--error-text);\n}\n\n/* Theme Toggle Button */\n.theme-toggle {\n    position: fixed;\n    top: 70px;\n    right: 20px;\n    z-index: 1050;\n    background-color: var(--card-bg);\n    border: 2px solid var(--border-color);\n    border-radius: 50px;\n    padding: 8px 12px;\n    cursor: pointer;\n    box-shadow: 0 2px 10px var(--shadow-color);\n    transition: all 0.3s ease;\n}\n\n.theme-toggle:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 15px var(--shadow-hover);\n}\n\n.theme-toggle i {\n    font-size: 1.2em;\n    color: var(--text-primary);\n    transition: color 0.3s ease;\n}\n\n.theme-toggle-dropdown {\n    position: absolute;\n    top: 100%;\n    right: 0;\n    margin-top: 5px;\n    background-color: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    box-shadow: 0 4px 15px var(--shadow-color);\n    padding: 8px 0;\n    min-width: 120px;\n    display: none;\n}\n\n.theme-toggle-dropdown.show {\n    display: block;\n}\n\n.theme-option {\n    padding: 8px 16px;\n    cursor: pointer;\n    color: var(--text-primary);\n    transition: background-color 0.2s ease;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.theme-option:hover {\n    background-color: var(--navbar-hover);\n}\n\n.theme-option.active {\n    background-color: var(--btn-primary-bg);\n    color: var(--text-inverse);\n}\n\n.theme-option i {\n    width: 16px;\n    text-align: center;\n}\n\n/* Accessibility Focus Improvements */\n.btn:focus, .form-control:focus, .form-select:focus,\n.nav-link:focus, .dropdown-item:focus {\n    outline: 2px solid var(--focus-ring);\n    outline-offset: 2px;\n    box-shadow: var(--focus-shadow);\n}\n\n/* High Contrast Mode Support */\n@media (prefers-contrast: high) {\n    :root {\n        --border-color: #000000;\n        --text-primary: #000000;\n        --text-secondary: #333333;\n    }\n    \n    [data-theme=\"dark\"] {\n        --border-color: #ffffff;\n        --text-primary: #ffffff;\n        --text-secondary: #cccccc;\n    }\n}\n\n/* Reduced Motion Support */\n@media (prefers-reduced-motion: reduce) {\n    *, *::before, *::after {\n        animation-duration: 0.01ms !important;\n        animation-iteration-count: 1 !important;\n        transition-duration: 0.01ms !important;\n    }\n}\n\n/* Print Styles */\n@media print {\n    body {\n        background-color: white !important;\n        color: black !important;\n    }\n    \n    .theme-toggle, .navbar, .footer {\n        display: none !important;\n    }\n}\n\n/* Smooth Theme Transitions */\n* {\n    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;\n}","size_bytes":11954},"static/js/accessibility-manager.js":{"content":"/**\n * BigBossizzz Accessibility Manager\n * Comprehensive accessibility features including screen reader support, keyboard navigation, and inclusive UX\n */\n\nclass AccessibilityManager {\n    constructor() {\n        this.isKeyboardNavActive = false;\n        this.currentRegion = null;\n        this.announcements = [];\n        this.focusHistory = [];\n        this.skipLinks = [];\n        \n        this.init();\n    }\n    \n    init() {\n        console.log('[INFO] Initializing Accessibility Manager...');\n        \n        // Create skip links\n        this.createSkipLinks();\n        \n        // Setup keyboard navigation detection\n        this.setupKeyboardNavigation();\n        \n        // Setup focus management\n        this.setupFocusManagement();\n        \n        // Setup ARIA live regions\n        this.setupLiveRegions();\n        \n        // Setup form accessibility\n        this.setupFormAccessibility();\n        \n        // Setup modal accessibility\n        this.setupModalAccessibility();\n        \n        // Setup table accessibility\n        this.setupTableAccessibility();\n        \n        // Setup quiz accessibility\n        this.setupQuizAccessibility();\n        \n        // Setup landmark navigation\n        this.setupLandmarkNavigation();\n        \n        console.log('[INFO] Accessibility Manager initialized successfully');\n    }\n    \n    createSkipLinks() {\n        const skipLinksContainer = document.createElement('div');\n        skipLinksContainer.className = 'skip-links';\n        skipLinksContainer.setAttribute('role', 'navigation');\n        skipLinksContainer.setAttribute('aria-label', 'Skip links');\n        \n        this.skipLinks = [\n            { href: '#main-content', text: 'Skip to main content' },\n            { href: '#navigation', text: 'Skip to navigation' },\n            { href: '#quiz-content', text: 'Skip to quiz' },\n            { href: '#footer', text: 'Skip to footer' }\n        ];\n        \n        this.skipLinks.forEach(link => {\n            const skipLink = document.createElement('a');\n            skipLink.href = link.href;\n            skipLink.className = 'skip-link sr-only-focusable';\n            skipLink.textContent = link.text;\n            skipLink.addEventListener('click', this.handleSkipLinkClick.bind(this));\n            skipLinksContainer.appendChild(skipLink);\n        });\n        \n        document.body.insertBefore(skipLinksContainer, document.body.firstChild);\n    }\n    \n    handleSkipLinkClick(event) {\n        event.preventDefault();\n        const targetId = event.target.getAttribute('href').substring(1);\n        const targetElement = document.getElementById(targetId);\n        \n        if (targetElement) {\n            targetElement.focus();\n            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });\n            this.announce(`Skipped to ${event.target.textContent.toLowerCase()}`);\n        }\n    }\n    \n    setupKeyboardNavigation() {\n        // Detect keyboard vs mouse navigation\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Tab') {\n                this.isKeyboardNavActive = true;\n                document.body.classList.add('keyboard-nav-active');\n                document.body.classList.remove('mouse-nav-active');\n            }\n        });\n        \n        document.addEventListener('mousedown', () => {\n            this.isKeyboardNavActive = false;\n            document.body.classList.add('mouse-nav-active');\n            document.body.classList.remove('keyboard-nav-active');\n        });\n        \n        // Enhanced keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            // Alt + M: Go to main content\n            if (e.altKey && e.key === 'm') {\n                e.preventDefault();\n                this.focusMainContent();\n            }\n            \n            // Alt + N: Go to navigation\n            if (e.altKey && e.key === 'n') {\n                e.preventDefault();\n                this.focusNavigation();\n            }\n            \n            // Alt + S: Go to search\n            if (e.altKey && e.key === 's') {\n                e.preventDefault();\n                this.focusSearch();\n            }\n            \n            // Alt + H: Go to help\n            if (e.altKey && e.key === 'h') {\n                e.preventDefault();\n                this.showKeyboardShortcuts();\n            }\n            \n            // Escape: Close modals, dropdowns, etc.\n            if (e.key === 'Escape') {\n                this.handleEscapeKey();\n            }\n        });\n    }\n    \n    setupFocusManagement() {\n        // Track focus history for better navigation\n        document.addEventListener('focusin', (e) => {\n            this.focusHistory.push(e.target);\n            if (this.focusHistory.length > 10) {\n                this.focusHistory.shift();\n            }\n        });\n        \n        // Ensure focus is visible\n        document.addEventListener('focusin', (e) => {\n            if (this.isKeyboardNavActive) {\n                e.target.scrollIntoView({ \n                    behavior: 'smooth', \n                    block: 'nearest',\n                    inline: 'nearest'\n                });\n            }\n        });\n        \n        // Focus trapping for modals\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Tab') {\n                const modal = document.querySelector('.modal.show');\n                if (modal) {\n                    this.trapFocusInModal(e, modal);\n                }\n            }\n        });\n    }\n    \n    setupLiveRegions() {\n        // Create live regions for announcements\n        const liveRegionPolite = document.createElement('div');\n        liveRegionPolite.id = 'live-region-polite';\n        liveRegionPolite.setAttribute('aria-live', 'polite');\n        liveRegionPolite.setAttribute('aria-atomic', 'true');\n        liveRegionPolite.className = 'sr-only';\n        \n        const liveRegionAssertive = document.createElement('div');\n        liveRegionAssertive.id = 'live-region-assertive';\n        liveRegionAssertive.setAttribute('aria-live', 'assertive');\n        liveRegionAssertive.setAttribute('aria-atomic', 'true');\n        liveRegionAssertive.className = 'sr-only';\n        \n        document.body.appendChild(liveRegionPolite);\n        document.body.appendChild(liveRegionAssertive);\n    }\n    \n    setupFormAccessibility() {\n        // Enhanced form labeling and descriptions\n        const forms = document.querySelectorAll('form');\n        forms.forEach(form => {\n            // Add form submission announcements\n            form.addEventListener('submit', (e) => {\n                this.announce('Form submitted. Please wait...', 'assertive');\n            });\n            \n            // Enhanced error handling\n            const inputs = form.querySelectorAll('input, select, textarea');\n            inputs.forEach(input => {\n                input.addEventListener('invalid', (e) => {\n                    const label = this.getAssociatedLabel(input);\n                    const labelText = label ? label.textContent : 'Field';\n                    this.announce(`${labelText} has an error: ${input.validationMessage}`, 'assertive');\n                });\n                \n                // Describe form controls\n                this.enhanceFormControl(input);\n            });\n        });\n    }\n    \n    enhanceFormControl(input) {\n        // Add aria-describedby for help text\n        const helpText = input.parentElement.querySelector('.form-help, .form-text');\n        if (helpText && !helpText.id) {\n            helpText.id = `help-${Date.now()}-${Math.random()}`;\n            input.setAttribute('aria-describedby', helpText.id);\n        }\n        \n        // Mark required fields\n        if (input.required) {\n            const label = this.getAssociatedLabel(input);\n            if (label) {\n                label.classList.add('required');\n                input.setAttribute('aria-required', 'true');\n            }\n        }\n        \n        // Add change announcements for important fields\n        if (input.type === 'checkbox' || input.type === 'radio') {\n            input.addEventListener('change', () => {\n                const label = this.getAssociatedLabel(input);\n                const labelText = label ? label.textContent : 'Option';\n                const status = input.checked ? 'checked' : 'unchecked';\n                this.announce(`${labelText} ${status}`);\n            });\n        }\n    }\n    \n    getAssociatedLabel(input) {\n        // Find associated label\n        if (input.id) {\n            return document.querySelector(`label[for=\"${input.id}\"]`);\n        }\n        return input.closest('label') || input.parentElement.querySelector('label');\n    }\n    \n    setupModalAccessibility() {\n        // Handle modal opening\n        document.addEventListener('show.bs.modal', (e) => {\n            const modal = e.target;\n            this.setupModalFocus(modal);\n            this.announce('Dialog opened');\n        });\n        \n        // Handle modal closing\n        document.addEventListener('hide.bs.modal', (e) => {\n            this.announce('Dialog closed');\n            this.restoreFocus();\n        });\n    }\n    \n    setupModalFocus(modal) {\n        // Store the element that opened the modal\n        this.modalTrigger = document.activeElement;\n        \n        // Focus the first focusable element in modal\n        setTimeout(() => {\n            const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\\n            if (firstFocusable) {\\n                firstFocusable.focus();\\n            }\\n        }, 100);\\n    }\\n    \\n    trapFocusInModal(event, modal) {\\n        const focusableElements = modal.querySelectorAll(\\n            'button, [href], input, select, textarea, [tabindex]:not([tabindex=\\\"-1\\\"])'\\n        );\\n        \\n        const firstFocusable = focusableElements[0];\\n        const lastFocusable = focusableElements[focusableElements.length - 1];\\n        \\n        if (event.shiftKey) {\\n            if (document.activeElement === firstFocusable) {\\n                event.preventDefault();\\n                lastFocusable.focus();\\n            }\\n        } else {\\n            if (document.activeElement === lastFocusable) {\\n                event.preventDefault();\\n                firstFocusable.focus();\\n            }\\n        }\\n    }\\n    \\n    setupTableAccessibility() {\\n        const tables = document.querySelectorAll('table');\\n        tables.forEach(table => {\\n            // Add table caption if missing\\n            if (!table.caption) {\\n                const caption = document.createElement('caption');\\n                caption.textContent = 'Data table';\\n                caption.className = 'sr-only';\\n                table.appendChild(caption);\\n            }\\n            \\n            // Add scope attributes to headers\\n            const headers = table.querySelectorAll('th');\\n            headers.forEach(header => {\\n                if (!header.getAttribute('scope')) {\\n                    // Determine if it's a column or row header\\n                    const isColumnHeader = header.parentElement.parentElement.tagName === 'THEAD';\\n                    header.setAttribute('scope', isColumnHeader ? 'col' : 'row');\\n                }\\n            });\\n            \\n            // Add table navigation instructions\\n            this.addTableInstructions(table);\\n        });\\n    }\\n    \\n    addTableInstructions(table) {\\n        const instructions = document.createElement('div');\\n        instructions.className = 'sr-only';\\n        instructions.textContent = 'Use arrow keys to navigate table cells when focused';\\n        table.parentElement.insertBefore(instructions, table);\\n        \\n        // Add arrow key navigation\\n        table.addEventListener('keydown', (e) => {\\n            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {\\n                this.navigateTable(e, table);\\n            }\\n        });\\n    }\\n    \\n    navigateTable(event, table) {\\n        const cell = event.target.closest('td, th');\\n        if (!cell) return;\\n        \\n        const row = cell.parentElement;\\n        const rowIndex = Array.from(row.parentElement.children).indexOf(row);\\n        const cellIndex = Array.from(row.children).indexOf(cell);\\n        \\n        let targetRow, targetCell;\\n        \\n        switch (event.key) {\\n            case 'ArrowUp':\\n                targetRow = row.parentElement.children[rowIndex - 1];\\n                break;\\n            case 'ArrowDown':\\n                targetRow = row.parentElement.children[rowIndex + 1];\\n                break;\\n            case 'ArrowLeft':\\n                targetCell = row.children[cellIndex - 1];\\n                break;\\n            case 'ArrowRight':\\n                targetCell = row.children[cellIndex + 1];\\n                break;\\n        }\\n        \\n        if (targetRow && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) {\\n            targetCell = targetRow.children[cellIndex];\\n        }\\n        \\n        if (targetCell) {\\n            event.preventDefault();\\n            targetCell.focus();\\n            targetCell.setAttribute('tabindex', '0');\\n            cell.setAttribute('tabindex', '-1');\\n        }\\n    }\\n    \\n    setupQuizAccessibility() {\\n        // Enhanced quiz option accessibility\\n        const quizOptions = document.querySelectorAll('.quiz-option');\\n        quizOptions.forEach((option, index) => {\\n            // Add proper ARIA attributes\\n            option.setAttribute('role', 'radio');\\n            option.setAttribute('aria-checked', 'false');\\n            option.setAttribute('tabindex', index === 0 ? '0' : '-1');\\n            \\n            // Add keyboard navigation\\n            option.addEventListener('keydown', (e) => {\\n                this.handleQuizOptionKeydown(e, option);\\n            });\\n            \\n            // Add selection announcements\\n            option.addEventListener('click', () => {\\n                this.announceQuizSelection(option);\\n            });\\n        });\\n        \\n        // Add quiz instructions\\n        const quizContainer = document.querySelector('.quiz-container');\\n        if (quizContainer) {\\n            this.addQuizInstructions(quizContainer);\\n        }\\n    }\\n    \\n    handleQuizOptionKeydown(event, option) {\\n        const options = Array.from(option.parentElement.querySelectorAll('.quiz-option'));\\n        const currentIndex = options.indexOf(option);\\n        \\n        switch (event.key) {\\n            case 'ArrowUp':\\n            case 'ArrowLeft':\\n                event.preventDefault();\\n                const prevIndex = (currentIndex - 1 + options.length) % options.length;\\n                this.focusQuizOption(options[prevIndex]);\\n                break;\\n                \\n            case 'ArrowDown':\\n            case 'ArrowRight':\\n                event.preventDefault();\\n                const nextIndex = (currentIndex + 1) % options.length;\\n                this.focusQuizOption(options[nextIndex]);\\n                break;\\n                \\n            case 'Enter':\\n            case ' ':\\n                event.preventDefault();\\n                option.click();\\n                break;\\n        }\\n    }\\n    \\n    focusQuizOption(option) {\\n        // Update tabindex\\n        option.parentElement.querySelectorAll('.quiz-option').forEach(opt => {\\n            opt.setAttribute('tabindex', '-1');\\n        });\\n        option.setAttribute('tabindex', '0');\\n        option.focus();\\n    }\\n    \\n    announceQuizSelection(option) {\\n        const optionText = option.textContent.trim();\\n        const questionElement = option.closest('.question-card');\\n        const questionNumber = questionElement ? \\n            questionElement.querySelector('.question-number')?.textContent || '' : '';\\n        \\n        this.announce(`${questionNumber} Selected: ${optionText}`);\\n    }\\n    \\n    addQuizInstructions(container) {\\n        const instructions = document.createElement('div');\\n        instructions.className = 'sr-only';\\n        instructions.setAttribute('aria-live', 'polite');\\n        instructions.innerHTML = `\\n            <p>Quiz instructions: Use Tab to navigate between questions and options. \\n            Use arrow keys to move between options within a question. \\n            Press Enter or Space to select an option.</p>\\n        `;\\n        container.insertBefore(instructions, container.firstChild);\\n    }\\n    \\n    setupLandmarkNavigation() {\\n        // Add landmark roles if missing\\n        const landmarks = [\\n            { selector: 'nav', role: 'navigation' },\\n            { selector: 'main', role: 'main' },\\n            { selector: 'header', role: 'banner' },\\n            { selector: 'footer', role: 'contentinfo' },\\n            { selector: 'aside', role: 'complementary' }\\n        ];\\n        \\n        landmarks.forEach(({ selector, role }) => {\\n            const elements = document.querySelectorAll(selector);\\n            elements.forEach(element => {\\n                if (!element.getAttribute('role')) {\\n                    element.setAttribute('role', role);\\n                }\\n            });\\n        });\\n        \\n        // Add landmark navigation\\n        document.addEventListener('keydown', (e) => {\\n            // Alt + R: Navigate through regions\\n            if (e.altKey && e.key === 'r') {\\n                e.preventDefault();\\n                this.navigateToNextLandmark();\\n            }\\n        });\\n    }\\n    \\n    navigateToNextLandmark() {\\n        const landmarks = document.querySelectorAll('[role=\\\"banner\\\"], [role=\\\"navigation\\\"], [role=\\\"main\\\"], [role=\\\"complementary\\\"], [role=\\\"contentinfo\\\"]');\\n        const currentIndex = Array.from(landmarks).findIndex(landmark => \\n            landmark.contains(document.activeElement));\\n        \\n        const nextIndex = (currentIndex + 1) % landmarks.length;\\n        const nextLandmark = landmarks[nextIndex];\\n        \\n        if (nextLandmark) {\\n            nextLandmark.focus();\\n            const role = nextLandmark.getAttribute('role');\\n            this.announce(`Navigated to ${role} landmark`);\\n        }\\n    }\\n    \\n    // Utility methods\\n    announce(message, priority = 'polite') {\\n        const liveRegion = document.getElementById(`live-region-${priority}`);\\n        if (liveRegion) {\\n            liveRegion.textContent = '';\\n            setTimeout(() => {\\n                liveRegion.textContent = message;\\n            }, 100);\\n        }\\n        \\n        // Store announcement for history\\n        this.announcements.push({\\n            message,\\n            priority,\\n            timestamp: new Date()\\n        });\\n        \\n        // Keep only last 50 announcements\\n        if (this.announcements.length > 50) {\\n            this.announcements.shift();\\n        }\\n    }\\n    \\n    focusMainContent() {\\n        const mainContent = document.getElementById('main-content') || \\n                          document.querySelector('main') || \\n                          document.querySelector('.main-content');\\n        if (mainContent) {\\n            mainContent.focus();\\n            this.announce('Focused main content');\\n        }\\n    }\\n    \\n    focusNavigation() {\\n        const navigation = document.getElementById('navigation') || \\n                         document.querySelector('nav') || \\n                         document.querySelector('.navbar');\\n        if (navigation) {\\n            const firstLink = navigation.querySelector('a, button');\\n            if (firstLink) {\\n                firstLink.focus();\\n                this.announce('Focused navigation');\\n            }\\n        }\\n    }\\n    \\n    focusSearch() {\\n        const searchInput = document.querySelector('input[type=\\\"search\\\"], .search-input, #search');\\n        if (searchInput) {\\n            searchInput.focus();\\n            this.announce('Focused search');\\n        }\\n    }\\n    \\n    showKeyboardShortcuts() {\\n        const shortcuts = [\\n            'Alt + M: Go to main content',\\n            'Alt + N: Go to navigation',\\n            'Alt + S: Go to search',\\n            'Alt + R: Navigate landmarks',\\n            'Alt + H: Show this help',\\n            'Tab: Navigate forward',\\n            'Shift + Tab: Navigate backward',\\n            'Escape: Close dialogs'\\n        ];\\n        \\n        this.announce(`Keyboard shortcuts available: ${shortcuts.join('. ')}`, 'polite');\\n    }\\n    \\n    handleEscapeKey() {\\n        // Close modals\\n        const openModal = document.querySelector('.modal.show');\\n        if (openModal) {\\n            const closeButton = openModal.querySelector('.btn-close, [data-bs-dismiss=\\\"modal\\\"]');\\n            if (closeButton) {\\n                closeButton.click();\\n            }\\n            return;\\n        }\\n        \\n        // Close dropdowns\\n        const openDropdown = document.querySelector('.dropdown-menu.show');\\n        if (openDropdown) {\\n            openDropdown.classList.remove('show');\\n            return;\\n        }\\n        \\n        // Close any other overlays\\n        const overlay = document.querySelector('.overlay, .popup, .tooltip');\\n        if (overlay) {\\n            overlay.remove();\\n        }\\n    }\\n    \\n    restoreFocus() {\\n        if (this.modalTrigger) {\\n            this.modalTrigger.focus();\\n            this.modalTrigger = null;\\n        }\\n    }\\n    \\n    // Public API methods\\n    makeAnnouncement(message, priority = 'polite') {\\n        this.announce(message, priority);\\n    }\\n    \\n    addSkipLink(href, text) {\\n        this.skipLinks.push({ href, text });\\n        // Recreate skip links\\n        const existingSkipLinks = document.querySelector('.skip-links');\\n        if (existingSkipLinks) {\\n            existingSkipLinks.remove();\\n        }\\n        this.createSkipLinks();\\n    }\\n    \\n    getAnnouncementHistory() {\\n        return this.announcements;\\n    }\\n    \\n    isKeyboardNavigationActive() {\\n        return this.isKeyboardNavActive;\\n    }\\n}\\n\\n// Auto-initialize accessibility manager\\ndocument.addEventListener('DOMContentLoaded', () => {\\n    window.accessibilityManager = new AccessibilityManager();\\n});\\n\\n// Export for use in other modules\\nif (typeof module !== 'undefined' && module.exports) {\\n    module.exports = AccessibilityManager;\\n}","size_bytes":22465},"static/js/mobile-app.js":{"content":"/**\n * BigBossizzz Mobile App Enhancements\n * Progressive Web App functionality with mobile-specific features\n */\n\nclass MobileAppManager {\n    constructor() {\n        this.isStandalone = window.matchMedia('(display-mode: standalone)').matches;\n        this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);\n        this.isAndroid = /Android/.test(navigator.userAgent);\n        this.isMobile = this.isIOS || this.isAndroid || window.innerWidth <= 768;\n        \n        // PWA Installation\n        this.deferredPrompt = null;\n        this.installPromptShown = false;\n        \n        // Mobile Navigation\n        this.bottomNavActive = false;\n        this.lastScrollPosition = 0;\n        this.scrollDirection = 'up';\n        \n        // Touch Interactions\n        this.touchStartY = 0;\n        this.touchStartX = 0;\n        this.pullToRefreshThreshold = 80;\n        this.isRefreshing = false;\n        \n        // Mobile Performance\n        this.isVisible = true;\n        this.performanceObserver = null;\n        \n        // Notification Management\n        this.notificationPermission = 'default';\n        this.activeToasts = [];\n        \n        this.init();\n    }\n    \n    async init() {\n        console.log('[INFO] Initializing Mobile App Manager...');\n        \n        if (!this.isMobile && !this.isStandalone) {\n            console.log('[INFO] Not on mobile device, skipping mobile enhancements');\n            return;\n        }\n        \n        try {\n            await this.setupPWA();\n            this.setupMobileNavigation();\n            this.setupTouchInteractions();\n            this.setupPerformanceOptimizations();\n            this.setupNotifications();\n            this.setupOfflineSupport();\n            this.applyMobileStyles();\n            this.initializeUIComponents();\n            \n            console.log('[INFO] Mobile App Manager initialized successfully');\n        } catch (error) {\n            console.error('[ERROR] Mobile App Manager initialization failed:', error);\n        }\n    }\n    \n    // ===== PWA Installation & Management =====\n    async setupPWA() {\n        // Check if PWA is already installed\n        if (this.isStandalone) {\n            console.log('[INFO] Running as installed PWA');\n            document.body.classList.add('pwa-installed');\n            this.hidePWAPrompt();\n            return;\n        }\n        \n        // Listen for beforeinstallprompt event\n        window.addEventListener('beforeinstallprompt', (e) => {\n            console.log('[INFO] PWA install prompt available');\n            e.preventDefault();\n            this.deferredPrompt = e;\n            this.showPWAPrompt();\n        });\n        \n        // Listen for app installed event\n        window.addEventListener('appinstalled', () => {\n            console.log('[INFO] PWA installed successfully');\n            this.hidePWAPrompt();\n            this.showToast('App installed successfully!', 'success');\n        });\n        \n        // Register service worker\n        if ('serviceWorker' in navigator) {\n            try {\n                const registration = await navigator.serviceWorker.register('/static/js/sw.js');\n                console.log('[INFO] Service Worker registered:', registration);\n                \n                // Listen for updates\n                registration.addEventListener('updatefound', () => {\n                    console.log('[INFO] New version available');\n                    this.showUpdatePrompt();\n                });\n            } catch (error) {\n                console.error('[ERROR] Service Worker registration failed:', error);\n            }\n        }\n    }\n    \n    showPWAPrompt() {\n        if (this.installPromptShown) return;\n        \n        const promptHTML = `\n            <div class=\"pwa-install-prompt\" id=\"pwaPrompt\">\n                <div class=\"pwa-prompt-content\">\n                    <div class=\"pwa-prompt-icon\">\n                        <i class=\"fas fa-mobile-alt\"></i>\n                    </div>\n                    <div class=\"pwa-prompt-text\">\n                        <h4>Install BigBossizzz</h4>\n                        <p>Install our app for the best mobile experience with offline support and push notifications.</p>\n                    </div>\n                    <div class=\"pwa-prompt-actions\">\n                        <button class=\"btn btn-outline-secondary btn-sm\" onclick=\"mobileApp.dismissPWAPrompt()\">\n                            Not now\n                        </button>\n                        <button class=\"btn btn-primary btn-sm\" onclick=\"mobileApp.installPWA()\">\n                            Install\n                        </button>\n                    </div>\n                </div>\n            </div>\n        `;\n        \n        document.body.insertAdjacentHTML('beforeend', promptHTML);\n        this.installPromptShown = true;\n        \n        // Auto-hide after 10 seconds\n        setTimeout(() => {\n            this.dismissPWAPrompt();\n        }, 10000);\n    }\n    \n    async installPWA() {\n        if (!this.deferredPrompt) return;\n        \n        try {\n            const result = await this.deferredPrompt.prompt();\n            console.log('PWA install result:', result);\n            \n            if (result.outcome === 'accepted') {\n                this.showToast('Installing app...', 'info');\n            }\n            \n            this.deferredPrompt = null;\n            this.hidePWAPrompt();\n        } catch (error) {\n            console.error('PWA installation error:', error);\n        }\n    }\n    \n    dismissPWAPrompt() {\n        this.hidePWAPrompt();\n        localStorage.setItem('pwa-prompt-dismissed', Date.now().toString());\n    }\n    \n    hidePWAPrompt() {\n        const prompt = document.getElementById('pwaPrompt');\n        if (prompt) {\n            prompt.remove();\n        }\n    }\n    \n    // ===== Mobile Navigation =====\n    setupMobileNavigation() {\n        // Create bottom navigation\n        this.createBottomNavigation();\n        \n        // Handle scroll behavior\n        this.setupScrollBehavior();\n        \n        // Setup mobile menu toggle\n        this.setupMobileMenu();\n        \n        // Handle orientation changes\n        this.setupOrientationHandling();\n    }\n    \n    createBottomNavigation() {\n        // Mobile navigation is now server-rendered in templates/_mobile_nav.html\n        // This prevents route drift and uses url_for() for correct links\n        \n        // Just add the mobile navigation enabled class if needed\n        const existingNav = document.getElementById('mobileBottomNav');\n        if (existingNav) {\n            document.body.classList.add('mobile-nav-enabled');\n        }\n        \n        // Setup click handlers for any existing navigation\n        this.setupBottomNavClickHandlers();\n    }\n    \n    setupBottomNavClickHandlers() {\n        const navItems = document.querySelectorAll('.mobile-nav-item');\n        \n        navItems.forEach(item => {\n            item.addEventListener('click', (e) => {\n                // Update active state\n                navItems.forEach(nav => nav.classList.remove('active'));\n                item.classList.add('active');\n                \n                // Add click animation\n                item.style.transform = 'scale(0.9)';\n                setTimeout(() => {\n                    item.style.transform = '';\n                }, 150);\n            });\n        });\n    }\n    \n    setupScrollBehavior() {\n        let ticking = false;\n        \n        const updateNavigation = () => {\n            const currentScroll = window.pageYOffset;\n            const bottomNav = document.getElementById('mobileBottomNav');\n            \n            if (!bottomNav) return;\n            \n            // Determine scroll direction\n            if (currentScroll > this.lastScrollPosition && currentScroll > 100) {\n                // Scrolling down - hide navigation\n                bottomNav.style.transform = 'translateY(100%)';\n                this.scrollDirection = 'down';\n            } else {\n                // Scrolling up - show navigation\n                bottomNav.style.transform = 'translateY(0)';\n                this.scrollDirection = 'up';\n            }\n            \n            this.lastScrollPosition = currentScroll;\n            ticking = false;\n        };\n        \n        const requestTick = () => {\n            if (!ticking) {\n                requestAnimationFrame(updateNavigation);\n                ticking = true;\n            }\n        };\n        \n        window.addEventListener('scroll', requestTick, { passive: true });\n    }\n    \n    setupMobileMenu() {\n        const navbar = document.querySelector('.navbar');\n        const navbarToggler = document.querySelector('.navbar-toggler');\n        const navbarCollapse = document.querySelector('.navbar-collapse');\n        \n        if (navbarToggler && navbarCollapse) {\n            navbarToggler.addEventListener('click', () => {\n                const isExpanded = navbarToggler.getAttribute('aria-expanded') === 'true';\n                \n                if (!isExpanded) {\n                    // Opening menu\n                    navbarCollapse.style.animation = 'slideInDown 0.3s ease';\n                } else {\n                    // Closing menu\n                    navbarCollapse.style.animation = 'slideInUp 0.3s ease reverse';\n                }\n            });\n        }\n    }\n    \n    setupOrientationHandling() {\n        const handleOrientationChange = () => {\n            // Delay to allow for orientation change to complete\n            setTimeout(() => {\n                // Update viewport height for iOS\n                if (this.isIOS) {\n                    const vh = window.innerHeight * 0.01;\n                    document.documentElement.style.setProperty('--vh', `${vh}px`);\n                }\n                \n                // Refresh layout-dependent components\n                this.refreshMobileLayout();\n            }, 300);\n        };\n        \n        window.addEventListener('orientationchange', handleOrientationChange);\n        window.addEventListener('resize', handleOrientationChange);\n        \n        // Initial setup\n        handleOrientationChange();\n    }\n    \n    refreshMobileLayout() {\n        // Trigger layout recalculation for mobile components\n        const mobileComponents = document.querySelectorAll('.mobile-card, .quiz-container, .mobile-proctoring-panel');\n        \n        mobileComponents.forEach(component => {\n            component.style.display = 'none';\n            component.offsetHeight; // Force reflow\n            component.style.display = '';\n        });\n    }\n    \n    // ===== Touch Interactions =====\n    setupTouchInteractions() {\n        this.setupPullToRefresh();\n        this.setupSwipeGestures();\n        this.setupTouchFeedback();\n    }\n    \n    setupPullToRefresh() {\n        let startY = 0;\n        let pullDistance = 0;\n        let isPulling = false;\n        let refreshElement = null;\n        \n        // Create pull to refresh element\n        const refreshHTML = `\n            <div class=\"mobile-pull-refresh\" id=\"pullToRefresh\">\n                <i class=\"fas fa-sync-alt refresh-icon\"></i>\n                <span class=\"refresh-text\">Pull to refresh</span>\n            </div>\n        `;\n        \n        document.body.insertAdjacentHTML('afterbegin', refreshHTML);\n        refreshElement = document.getElementById('pullToRefresh');\n        \n        const handleTouchStart = (e) => {\n            if (window.pageYOffset === 0) {\n                startY = e.touches[0].clientY;\n                isPulling = true;\n            }\n        };\n        \n        const handleTouchMove = (e) => {\n            if (!isPulling) return;\n            \n            const currentY = e.touches[0].clientY;\n            pullDistance = Math.max(0, currentY - startY);\n            \n            if (pullDistance > 0) {\n                e.preventDefault();\n                \n                // Update refresh element\n                const progress = Math.min(pullDistance / this.pullToRefreshThreshold, 1);\n                refreshElement.style.transform = `translateY(${pullDistance * 0.5}px)`;\n                refreshElement.style.opacity = progress;\n                \n                if (pullDistance >= this.pullToRefreshThreshold) {\n                    refreshElement.classList.add('active');\n                    refreshElement.querySelector('.refresh-text').textContent = 'Release to refresh';\n                } else {\n                    refreshElement.classList.remove('active');\n                    refreshElement.querySelector('.refresh-text').textContent = 'Pull to refresh';\n                }\n            }\n        };\n        \n        const handleTouchEnd = () => {\n            if (!isPulling) return;\n            \n            isPulling = false;\n            \n            if (pullDistance >= this.pullToRefreshThreshold && !this.isRefreshing) {\n                this.triggerRefresh();\n            } else {\n                // Reset refresh element\n                refreshElement.style.transform = '';\n                refreshElement.style.opacity = '';\n                refreshElement.classList.remove('active');\n            }\n            \n            pullDistance = 0;\n        };\n        \n        document.addEventListener('touchstart', handleTouchStart, { passive: false });\n        document.addEventListener('touchmove', handleTouchMove, { passive: false });\n        document.addEventListener('touchend', handleTouchEnd, { passive: true });\n    }\n    \n    async triggerRefresh() {\n        if (this.isRefreshing) return;\n        \n        this.isRefreshing = true;\n        const refreshElement = document.getElementById('pullToRefresh');\n        \n        if (refreshElement) {\n            refreshElement.classList.add('active');\n            refreshElement.querySelector('.refresh-icon').style.animation = 'spin 1s linear infinite';\n            refreshElement.querySelector('.refresh-text').textContent = 'Refreshing...';\n        }\n        \n        try {\n            // Refresh current page data\n            await this.refreshPageData();\n            \n            // Show success feedback\n            this.showToast('Page refreshed successfully!', 'success');\n        } catch (error) {\n            console.error('Refresh failed:', error);\n            this.showToast('Failed to refresh page', 'error');\n        } finally {\n            // Reset refresh state\n            setTimeout(() => {\n                if (refreshElement) {\n                    refreshElement.style.transform = '';\n                    refreshElement.style.opacity = '';\n                    refreshElement.classList.remove('active');\n                    refreshElement.querySelector('.refresh-icon').style.animation = '';\n                    refreshElement.querySelector('.refresh-text').textContent = 'Pull to refresh';\n                }\n                this.isRefreshing = false;\n            }, 1000);\n        }\n    }\n    \n    async refreshPageData() {\n        // Simulate data refresh\n        return new Promise(resolve => {\n            setTimeout(() => {\n                // Reload current page\n                window.location.reload();\n                resolve();\n            }, 1500);\n        });\n    }\n    \n    setupSwipeGestures() {\n        let startX = 0;\n        let startY = 0;\n        let threshold = 100;\n        \n        const handleSwipeStart = (e) => {\n            startX = e.touches[0].clientX;\n            startY = e.touches[0].clientY;\n        };\n        \n        const handleSwipeEnd = (e) => {\n            const endX = e.changedTouches[0].clientX;\n            const endY = e.changedTouches[0].clientY;\n            \n            const deltaX = endX - startX;\n            const deltaY = endY - startY;\n            \n            // Check if it's a horizontal swipe\n            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold) {\n                if (deltaX > 0) {\n                    // Swipe right\n                    this.handleSwipeRight();\n                } else {\n                    // Swipe left\n                    this.handleSwipeLeft();\n                }\n            }\n        };\n        \n        document.addEventListener('touchstart', handleSwipeStart, { passive: true });\n        document.addEventListener('touchend', handleSwipeEnd, { passive: true });\n    }\n    \n    handleSwipeRight() {\n        // Navigate back if possible\n        if (window.history.length > 1) {\n            window.history.back();\n        }\n    }\n    \n    handleSwipeLeft() {\n        // Could be used for next page navigation or menu toggle\n        console.log('Swipe left detected');\n    }\n    \n    setupTouchFeedback() {\n        // Add haptic feedback for supported devices\n        const addHapticFeedback = (element, intensity = 'light') => {\n            element.addEventListener('touchstart', () => {\n                if (navigator.vibrate) {\n                    const vibrationPattern = {\n                        light: [10],\n                        medium: [50],\n                        heavy: [100]\n                    };\n                    navigator.vibrate(vibrationPattern[intensity] || vibrationPattern.light);\n                }\n            });\n        };\n        \n        // Add feedback to buttons and interactive elements\n        const interactiveElements = document.querySelectorAll('button, .btn, .card, .nav-link, .mobile-nav-item');\n        interactiveElements.forEach(element => {\n            addHapticFeedback(element);\n        });\n    }\n    \n    // ===== Mobile Notifications & Toasts =====\n    setupNotifications() {\n        this.requestNotificationPermission();\n    }\n    \n    async requestNotificationPermission() {\n        if (!('Notification' in window)) {\n            console.log('This browser does not support notifications');\n            return;\n        }\n        \n        if (Notification.permission === 'default') {\n            const permission = await Notification.requestPermission();\n            this.notificationPermission = permission;\n            \n            if (permission === 'granted') {\n                this.showToast('Notifications enabled!', 'success');\n            }\n        } else {\n            this.notificationPermission = Notification.permission;\n        }\n    }\n    \n    showToast(message, type = 'info', duration = 4000) {\n        const toastId = 'toast-' + Date.now();\n        const icons = {\n            success: 'fas fa-check-circle',\n            error: 'fas fa-exclamation-circle',\n            warning: 'fas fa-exclamation-triangle',\n            info: 'fas fa-info-circle'\n        };\n        \n        const toastHTML = `\n            <div class=\"mobile-toast ${type}\" id=\"${toastId}\">\n                <div class=\"toast-header\">\n                    <i class=\"${icons[type] || icons.info}\"></i>\n                    <span class=\"toast-title\">${type.charAt(0).toUpperCase() + type.slice(1)}</span>\n                    <button class=\"toast-close\" onclick=\"mobileApp.hideToast('${toastId}')\">\n                        <i class=\"fas fa-times\"></i>\n                    </button>\n                </div>\n                <div class=\"toast-body\">${message}</div>\n            </div>\n        `;\n        \n        document.body.insertAdjacentHTML('beforeend', toastHTML);\n        \n        const toast = document.getElementById(toastId);\n        this.activeToasts.push(toastId);\n        \n        // Show toast\n        setTimeout(() => {\n            toast.classList.add('show');\n        }, 100);\n        \n        // Auto-hide toast\n        setTimeout(() => {\n            this.hideToast(toastId);\n        }, duration);\n    }\n    \n    hideToast(toastId) {\n        const toast = document.getElementById(toastId);\n        if (toast) {\n            toast.classList.remove('show');\n            setTimeout(() => {\n                toast.remove();\n                this.activeToasts = this.activeToasts.filter(id => id !== toastId);\n            }, 300);\n        }\n    }\n    \n    // ===== Performance Optimizations =====\n    setupPerformanceOptimizations() {\n        this.setupVisibilityAPI();\n        this.setupIntersectionObserver();\n        this.setupImageOptimization();\n    }\n    \n    setupVisibilityAPI() {\n        document.addEventListener('visibilitychange', () => {\n            this.isVisible = !document.hidden;\n            \n            if (this.isVisible) {\n                // Resume animations and updates\n                console.log('App became visible - resuming operations');\n            } else {\n                // Pause non-essential operations\n                console.log('App hidden - pausing operations');\n            }\n        });\n    }\n    \n    setupIntersectionObserver() {\n        if (!('IntersectionObserver' in window)) return;\n        \n        const observer = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting) {\n                    entry.target.classList.add('mobile-content-loaded');\n                }\n            });\n        }, {\n            threshold: 0.1,\n            rootMargin: '50px'\n        });\n        \n        // Observe content elements\n        const contentElements = document.querySelectorAll('.mobile-content, .card, .question-card');\n        contentElements.forEach(element => {\n            observer.observe(element);\n        });\n    }\n    \n    setupImageOptimization() {\n        // Lazy load images\n        const images = document.querySelectorAll('img[data-src]');\n        \n        if ('IntersectionObserver' in window) {\n            const imageObserver = new IntersectionObserver((entries) => {\n                entries.forEach(entry => {\n                    if (entry.isIntersecting) {\n                        const img = entry.target;\n                        img.src = img.dataset.src;\n                        img.removeAttribute('data-src');\n                        imageObserver.unobserve(img);\n                    }\n                });\n            });\n            \n            images.forEach(img => imageObserver.observe(img));\n        } else {\n            // Fallback for older browsers\n            images.forEach(img => {\n                img.src = img.dataset.src;\n                img.removeAttribute('data-src');\n            });\n        }\n    }\n    \n    // ===== Offline Support =====\n    setupOfflineSupport() {\n        window.addEventListener('online', () => {\n            this.showToast('Connection restored!', 'success');\n            document.body.classList.remove('offline');\n        });\n        \n        window.addEventListener('offline', () => {\n            this.showToast('You are now offline', 'warning');\n            document.body.classList.add('offline');\n        });\n        \n        // Check initial connection state\n        if (!navigator.onLine) {\n            document.body.classList.add('offline');\n        }\n    }\n    \n    // ===== UI Component Initialization =====\n    applyMobileStyles() {\n        // Add mobile-specific CSS classes\n        document.body.classList.add('mobile-enhanced');\n        \n        if (this.isIOS) {\n            document.body.classList.add('ios-device');\n        }\n        \n        if (this.isAndroid) {\n            document.body.classList.add('android-device');\n        }\n        \n        if (this.isStandalone) {\n            document.body.classList.add('pwa-standalone');\n        }\n    }\n    \n    initializeUIComponents() {\n        // Initialize mobile-specific UI components\n        this.setupFloatingActionButton();\n        this.setupCardStackInterface();\n        this.enhanceFormInputs();\n    }\n    \n    setupFloatingActionButton() {\n        const currentPage = window.location.pathname;\n        let fabAction = null;\n        \n        // Define FAB action based on current page\n        if (currentPage.includes('quiz') || currentPage.includes('take_quiz')) {\n            fabAction = {\n                icon: 'fas fa-save',\n                action: () => this.saveQuizProgress(),\n                title: 'Save Progress'\n            };\n        } else if (currentPage.includes('dashboard')) {\n            fabAction = {\n                icon: 'fas fa-plus',\n                action: () => window.location.href = '/create_quiz',\n                title: 'Create Quiz'\n            };\n        }\n        \n        if (fabAction) {\n            const fabHTML = `\n                <button class=\"mobile-fab\" title=\"${fabAction.title}\" onclick=\"mobileApp.triggerFabAction()\">\n                    <i class=\"${fabAction.icon}\"></i>\n                </button>\n            `;\n            \n            document.body.insertAdjacentHTML('beforeend', fabHTML);\n            this.fabAction = fabAction.action;\n        }\n    }\n    \n    triggerFabAction() {\n        if (this.fabAction) {\n            this.fabAction();\n        }\n    }\n    \n    saveQuizProgress() {\n        // Trigger quiz auto-save\n        if (window.quizSystem && window.quizSystem.autoSave) {\n            window.quizSystem.autoSave();\n            this.showToast('Quiz progress saved!', 'success');\n        }\n    }\n    \n    setupCardStackInterface() {\n        const cards = document.querySelectorAll('.question-card');\n        \n        if (cards.length > 1) {\n            cards.forEach((card, index) => {\n                card.classList.add('mobile-card');\n                \n                if (index === 0) {\n                    card.classList.add('current');\n                } else if (index === 1) {\n                    card.classList.add('next');\n                } else {\n                    card.classList.add('hidden');\n                }\n            });\n        }\n    }\n    \n    enhanceFormInputs() {\n        // Enhance form inputs for mobile\n        const inputs = document.querySelectorAll('input, textarea, select');\n        \n        inputs.forEach(input => {\n            input.classList.add('mobile-focus');\n            \n            // Add input labels animation\n            const label = input.previousElementSibling;\n            if (label && label.tagName === 'LABEL') {\n                input.addEventListener('focus', () => {\n                    label.style.transform = 'translateY(-20px) scale(0.8)';\n                    label.style.color = 'var(--mobile-accent)';\n                });\n                \n                input.addEventListener('blur', () => {\n                    if (!input.value) {\n                        label.style.transform = '';\n                        label.style.color = '';\n                    }\n                });\n            }\n        });\n    }\n    \n    // ===== Utility Methods =====\n    showUpdatePrompt() {\n        const updateHTML = `\n            <div class=\"mobile-toast info\" id=\"updateToast\">\n                <div class=\"toast-header\">\n                    <i class=\"fas fa-download\"></i>\n                    <span class=\"toast-title\">Update Available</span>\n                    <button class=\"toast-close\" onclick=\"mobileApp.hideToast('updateToast')\">\n                        <i class=\"fas fa-times\"></i>\n                    </button>\n                </div>\n                <div class=\"toast-body\">\n                    A new version is available. Refresh to update.\n                    <button class=\"btn btn-sm btn-primary mt-2\" onclick=\"window.location.reload()\">\n                        Update Now\n                    </button>\n                </div>\n            </div>\n        `;\n        \n        document.body.insertAdjacentHTML('beforeend', updateHTML);\n        \n        setTimeout(() => {\n            document.getElementById('updateToast').classList.add('show');\n        }, 100);\n    }\n}\n\n// Initialize Mobile App Manager\nlet mobileApp;\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    mobileApp = new MobileAppManager();\n});\n\n// Export for global access\nwindow.mobileApp = mobileApp;","size_bytes":27653},"static/js/offline-manager.js":{"content":"/**\n * BigBossizzz Offline Manager\n * Comprehensive offline mode for quiz-taking with intelligent sync capabilities\n */\n\nclass OfflineManager {\n    constructor() {\n        this.isOnline = navigator.onLine;\n        this.syncQueue = [];\n        this.offlineQuizData = new Map();\n        this.syncInProgress = false;\n        this.serviceWorkerReady = false;\n        this.offlineStorage = {\n            quizzes: 'offline_quizzes',\n            answers: 'offline_answers',\n            attempts: 'offline_attempts',\n            sync_queue: 'offline_sync_queue',\n            user_data: 'offline_user_data'\n        };\n        \n        this.init();\n    }\n    \n    async init() {\n        console.log('[INFO] Initializing Offline Manager...');\n        \n        // Register service worker\n        await this.registerServiceWorker();\n        \n        // Setup online/offline detection\n        this.setupConnectivityDetection();\n        \n        // Load offline data\n        await this.loadOfflineData();\n        \n        // Setup periodic sync\n        this.setupPeriodicSync();\n        \n        // Setup UI indicators\n        this.setupOfflineUI();\n        \n        // Setup quiz offline functionality\n        this.setupQuizOfflineMode();\n        \n        // Restore sync queue\n        await this.restoreSyncQueue();\n        \n        console.log('[INFO] Offline Manager initialized successfully');\n    }\n    \n    async registerServiceWorker() {\n        if ('serviceWorker' in navigator) {\n            try {\n                const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/' });\n                console.log('[INFO] Root Service Worker registered for offline support');\n                \n                registration.addEventListener('updatefound', () => {\n                    console.log('[INFO] Service Worker update found');\n                });\n                \n                // Wait for service worker to be ready\n                await navigator.serviceWorker.ready;\n                this.serviceWorkerReady = true;\n                \n                // Setup message listener\n                navigator.serviceWorker.addEventListener('message', this.handleServiceWorkerMessage.bind(this));\n                \n            } catch (error) {\n                console.error('? Service Worker registration failed:', error);\n            }\n        }\n    }\n    \n    setupConnectivityDetection() {\n        // Listen for online/offline events\n        window.addEventListener('online', this.handleOnline.bind(this));\n        window.addEventListener('offline', this.handleOffline.bind(this));\n        \n        // Periodic connectivity check\n        setInterval(() => {\n            this.checkConnectivity();\n        }, 30000); // Check every 30 seconds\n        \n        // Initial check\n        this.checkConnectivity();\n    }\n    \n    async checkConnectivity() {\n        try {\n            // Try to fetch with proper timeout using AbortController\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 5000);\n            \n            const response = await fetch('/api/connectivity-check', {\n                method: 'HEAD',\n                cache: 'no-cache',\n                signal: controller.signal\n            });\n            \n            clearTimeout(timeoutId);\n            \n            const wasOnline = this.isOnline;\n            this.isOnline = response.ok;\n            \n            if (!wasOnline && this.isOnline) {\n                this.handleOnline();\n            } else if (wasOnline && !this.isOnline) {\\n                this.handleOffline();\\n            }\\n            \\n        } catch (error) {\\n            if (this.isOnline) {\\n                this.isOnline = false;\\n                this.handleOffline();\\n            }\\n        }\\n    }\\n    \\n    handleOnline() {\\n        console.log('? Connection restored - Going online');\\n        this.isOnline = true;\\n        this.updateOfflineIndicator();\\n        this.announceConnectionStatus('online');\\n        \\n        // Start syncing queued data\\n        this.startSync();\\n    }\\n    \\n    handleOffline() {\\n        console.log('? Connection lost - Going offline');\\n        this.isOnline = false;\\n        this.updateOfflineIndicator();\\n        this.announceConnectionStatus('offline');\\n        \\n        // Enable offline mode for current quiz\\n        this.enableQuizOfflineMode();\\n    }\\n    \\n    setupOfflineUI() {\\n        // Create offline indicator\\n        const offlineIndicator = document.createElement('div');\\n        offlineIndicator.id = 'offline-indicator';\\n        offlineIndicator.className = 'offline-indicator';\\n        offlineIndicator.innerHTML = `\\n            <div class=\\\"offline-status\\\">\\n                <i class=\\\"fas fa-wifi\\\" id=\\\"connection-icon\\\"></i>\\n                <span id=\\\"connection-text\\\">Online</span>\\n                <div class=\\\"sync-indicator\\\" id=\\\"sync-indicator\\\">\\n                    <i class=\\\"fas fa-sync-alt\\\"></i>\\n                    <span>Syncing...</span>\\n                </div>\\n            </div>\\n            <div class=\\\"offline-details\\\" id=\\\"offline-details\\\">\\n                <p>You're currently offline. Your quiz progress is being saved locally and will sync when connection is restored.</p>\\n                <button class=\\\"btn btn-sm btn-primary\\\" onclick=\\\"window.offlineManager.forcSync()\\\">Try Sync Now</button>\\n            </div>\\n        `;\\n        \\n        // Add styles\\n        const styles = document.createElement('style');\\n        styles.textContent = `\\n            .offline-indicator {\\n                position: fixed;\\n                top: 10px;\\n                right: 10px;\\n                background: var(--card-bg);\\n                border: 2px solid var(--border-color);\\n                border-radius: 8px;\\n                padding: 8px 12px;\\n                box-shadow: 0 4px 12px var(--shadow-color);\\n                z-index: 1060;\\n                font-size: 0.875rem;\\n                min-width: 120px;\\n                transition: all 0.3s ease;\\n            }\\n            \\n            .offline-indicator.offline {\\n                border-color: var(--btn-warning-bg);\\n                background: var(--warning-bg);\\n            }\\n            \\n            .offline-indicator.syncing {\\n                border-color: var(--btn-info-bg);\\n            }\\n            \\n            .offline-status {\\n                display: flex;\\n                align-items: center;\\n                gap: 6px;\\n                cursor: pointer;\\n            }\\n            \\n            .offline-details {\\n                display: none;\\n                margin-top: 8px;\\n                padding-top: 8px;\\n                border-top: 1px solid var(--border-color);\\n                font-size: 0.8rem;\\n            }\\n            \\n            .offline-indicator.offline .offline-details {\\n                display: block;\\n            }\\n            \\n            .sync-indicator {\\n                display: none;\\n                margin-left: auto;\\n                color: var(--btn-info-bg);\\n            }\\n            \\n            .sync-indicator.active {\\n                display: flex;\\n                align-items: center;\\n                gap: 4px;\\n            }\\n            \\n            .sync-indicator.active i {\\n                animation: spin 1s linear infinite;\\n            }\\n            \\n            #connection-icon.offline {\\n                color: var(--btn-warning-bg);\\n            }\\n            \\n            #connection-icon.online {\\n                color: var(--btn-success-bg);\\n            }\\n            \\n            @keyframes spin {\\n                from { transform: rotate(0deg); }\\n                to { transform: rotate(360deg); }\\n            }\\n        `;\\n        \\n        document.head.appendChild(styles);\\n        document.body.appendChild(offlineIndicator);\\n        \\n        // Add click handler for status\\n        offlineIndicator.querySelector('.offline-status').addEventListener('click', () => {\\n            offlineIndicator.classList.toggle('expanded');\\n        });\\n        \\n        this.updateOfflineIndicator();\\n    }\\n    \\n    updateOfflineIndicator() {\\n        const indicator = document.getElementById('offline-indicator');\\n        const icon = document.getElementById('connection-icon');\\n        const text = document.getElementById('connection-text');\\n        \\n        if (indicator && icon && text) {\\n            if (this.isOnline) {\\n                indicator.classList.remove('offline');\\n                icon.className = 'fas fa-wifi online';\\n                text.textContent = 'Online';\\n            } else {\\n                indicator.classList.add('offline');\\n                icon.className = 'fas fa-wifi-slash offline';\\n                text.textContent = 'Offline';\\n            }\\n        }\\n    }\\n    \\n    updateSyncIndicator(show) {\\n        const syncIndicator = document.getElementById('sync-indicator');\\n        if (syncIndicator) {\\n            if (show) {\\n                syncIndicator.classList.add('active');\\n                document.getElementById('offline-indicator').classList.add('syncing');\\n            } else {\\n                syncIndicator.classList.remove('active');\\n                document.getElementById('offline-indicator').classList.remove('syncing');\\n            }\\n        }\\n    }\\n    \\n    announceConnectionStatus(status) {\\n        if (window.accessibilityManager) {\\n            const message = status === 'online' ? \\n                'Connection restored. Your offline data will now sync.' :\\n                'Connection lost. Offline mode activated. Your progress will be saved locally.';\\n            window.accessibilityManager.makeAnnouncement(message, 'assertive');\\n        }\\n    }\\n    \\n    setupQuizOfflineMode() {\\n        // Intercept quiz form submissions\\n        document.addEventListener('submit', this.handleQuizSubmission.bind(this));\\n        \\n        // Auto-save quiz progress\\n        document.addEventListener('change', this.handleQuizChange.bind(this));\\n        \\n        // Periodic auto-save\\n        setInterval(() => {\\n            this.autoSaveQuizProgress();\\n        }, 30000); // Save every 30 seconds\\n    }\\n    \\n    enableQuizOfflineMode() {\\n        const quizContainer = document.querySelector('.quiz-container');\\n        if (quizContainer) {\\n            // Show offline mode indicator\\n            this.showQuizOfflineNotification();\\n            \\n            // Pre-cache current quiz data\\n            this.cacheCurrentQuizData();\\n        }\\n    }\\n    \\n    showQuizOfflineNotification() {\\n        const existingNotification = document.querySelector('.quiz-offline-notification');\\n        if (existingNotification) return;\\n        \\n        const notification = document.createElement('div');\\n        notification.className = 'quiz-offline-notification alert alert-warning';\\n        notification.innerHTML = `\\n            <div class=\\\"d-flex align-items-center\\\">\\n                <i class=\\\"fas fa-wifi-slash me-2\\\"></i>\\n                <div>\\n                    <strong>Offline Mode Active</strong><br>\\n                    <small>Your quiz progress is being saved locally and will sync when connection is restored.</small>\\n                </div>\\n            </div>\\n        `;\\n        \\n        const quizContainer = document.querySelector('.quiz-container');\\n        if (quizContainer) {\\n            quizContainer.insertBefore(notification, quizContainer.firstChild);\\n        }\\n    }\\n    \\n    async handleQuizSubmission(event) {\\n        const form = event.target;\\n        if (!form.classList.contains('quiz-form') && !form.action.includes('/quiz/')) {\\n            return;\\n        }\\n        \\n        if (!this.isOnline) {\\n            event.preventDefault();\\n            await this.saveQuizSubmissionOffline(form);\\n            this.showOfflineSubmissionMessage();\\n        }\\n    }\\n    \\n    async handleQuizChange(event) {\\n        const input = event.target;\\n        if (input.name && input.name.startsWith('question_')) {\\n            await this.saveQuizAnswerOffline(input);\\n        }\\n    }\\n    \\n    async saveQuizSubmissionOffline(form) {\\n        const formData = new FormData(form);\\n        const submissionData = {\\n            id: `submission_${Date.now()}`,\\n            url: form.action,\\n            method: form.method || 'POST',\\n            data: Object.fromEntries(formData),\\n            timestamp: new Date().toISOString(),\\n            type: 'quiz_submission'\\n        };\\n        \\n        // Add to sync queue\\n        this.syncQueue.push(submissionData);\\n        await this.saveSyncQueue();\\n        \\n        console.log('? Quiz submission saved offline:', submissionData.id);\\n    }\\n    \\n    async saveQuizAnswerOffline(input) {\\n        const quizId = this.getCurrentQuizId();\\n        if (!quizId) return;\\n        \\n        const answerData = {\\n            quizId: quizId,\\n            questionId: input.name.replace('question_', ''),\\n            answer: input.value,\\n            timestamp: new Date().toISOString()\\n        };\\n        \\n        // Store in local storage\\n        const offlineAnswers = JSON.parse(localStorage.getItem(this.offlineStorage.answers) || '{}');\\n        if (!offlineAnswers[quizId]) {\\n            offlineAnswers[quizId] = {};\\n        }\\n        offlineAnswers[quizId][answerData.questionId] = answerData;\\n        \\n        localStorage.setItem(this.offlineStorage.answers, JSON.stringify(offlineAnswers));\\n        \\n        console.log('? Quiz answer saved offline:', answerData);\\n    }\\n    \\n    async autoSaveQuizProgress() {\\n        if (this.isOnline) return;\\n        \\n        const quizForm = document.querySelector('.quiz-form, form[action*=\\\"/quiz/\\\"]');\\n        if (!quizForm) return;\\n        \\n        const formData = new FormData(quizForm);\\n        const progressData = {\\n            quizId: this.getCurrentQuizId(),\\n            progress: Object.fromEntries(formData),\\n            timestamp: new Date().toISOString(),\\n            percentage: this.calculateQuizProgress(quizForm)\\n        };\\n        \\n        localStorage.setItem(`quiz_progress_${progressData.quizId}`, JSON.stringify(progressData));\\n        console.log('? Quiz progress auto-saved:', progressData.percentage + '%');\\n    }\\n    \\n    calculateQuizProgress(form) {\\n        const totalQuestions = form.querySelectorAll('[name^=\\\"question_\\\"]').length;\\n        const answeredQuestions = form.querySelectorAll('[name^=\\\"question_\\\"]:checked, [name^=\\\"question_\\\"][value!=\\\"\\\"]').length;\\n        return totalQuestions > 0 ? Math.round((answeredQuestions / totalQuestions) * 100) : 0;\\n    }\\n    \\n    getCurrentQuizId() {\\n        // Extract quiz ID from URL or form\\n        const match = window.location.pathname.match(/\\\\/quiz\\\\/(\\\\d+)/);\\n        return match ? match[1] : null;\\n    }\\n    \\n    async cacheCurrentQuizData() {\\n        const quizId = this.getCurrentQuizId();\\n        if (!quizId) return;\\n        \\n        try {\\n            // Cache quiz questions and structure\\n            const quizData = {\\n                id: quizId,\\n                questions: this.extractQuizQuestions(),\\n                timestamp: new Date().toISOString()\\n            };\\n            \\n            const offlineQuizzes = JSON.parse(localStorage.getItem(this.offlineStorage.quizzes) || '{}');\\n            offlineQuizzes[quizId] = quizData;\\n            localStorage.setItem(this.offlineStorage.quizzes, JSON.stringify(offlineQuizzes));\\n            \\n            console.log('? Quiz data cached for offline use:', quizId);\\n        } catch (error) {\\n            console.error('? Failed to cache quiz data:', error);\\n        }\\n    }\\n    \\n    extractQuizQuestions() {\\n        const questions = [];\\n        const questionElements = document.querySelectorAll('.question-card, .quiz-question');\\n        \\n        questionElements.forEach(element => {\\n            const questionData = {\\n                id: element.dataset.questionId || element.querySelector('[name^=\\\"question_\\\"]')?.name.replace('question_', ''),\\n                text: element.querySelector('.question-text')?.textContent || '',\\n                type: this.detectQuestionType(element),\\n                options: this.extractQuestionOptions(element)\\n            };\\n            questions.push(questionData);\\n        });\\n        \\n        return questions;\\n    }\\n    \\n    detectQuestionType(element) {\\n        if (element.querySelector('input[type=\\\"radio\\\"]')) return 'multiple_choice';\\n        if (element.querySelector('input[type=\\\"checkbox\\\"]')) return 'multiple_select';\\n        if (element.querySelector('textarea')) return 'text';\\n        if (element.querySelector('input[type=\\\"file\\\"]')) return 'file_upload';\\n        return 'text';\\n    }\\n    \\n    extractQuestionOptions(element) {\\n        const options = [];\\n        const optionElements = element.querySelectorAll('.quiz-option, .option');\\n        \\n        optionElements.forEach(option => {\\n            const input = option.querySelector('input');\\n            if (input) {\\n                options.push({\\n                    value: input.value,\\n                    text: option.textContent.trim(),\\n                    id: input.id\\n                });\\n            }\\n        });\\n        \\n        return options;\\n    }\\n    \\n    showOfflineSubmissionMessage() {\\n        const message = document.createElement('div');\\n        message.className = 'alert alert-info';\\n        message.innerHTML = `\\n            <i class=\\\"fas fa-cloud-upload-alt me-2\\\"></i>\\n            <strong>Quiz Submitted Offline</strong><br>\\n            Your answers have been saved and will be submitted automatically when connection is restored.\\n        `;\\n        \\n        const quizContainer = document.querySelector('.quiz-container');\\n        if (quizContainer) {\\n            quizContainer.appendChild(message);\\n            \\n            // Remove message after 5 seconds\\n            setTimeout(() => {\\n                if (message.parentNode) {\\n                    message.parentNode.removeChild(message);\\n                }\\n            }, 5000);\\n        }\\n    }\\n    \\n    async startSync() {\\n        if (this.syncInProgress || !this.isOnline) {\\n            return;\\n        }\\n        \\n        this.syncInProgress = true;\\n        this.updateSyncIndicator(true);\\n        \\n        try {\\n            console.log('? Starting sync process...');\\n            \\n            // Sync quiz submissions\\n            await this.syncQuizSubmissions();\\n            \\n            // Sync saved progress\\n            await this.syncSavedProgress();\\n            \\n            // Clear sync queue\\n            await this.clearSyncQueue();\\n            \\n            console.log('? Sync completed successfully');\\n            this.showSyncSuccessMessage();\\n            \\n        } catch (error) {\\n            console.error('? Sync failed:', error);\\n            this.showSyncErrorMessage();\\n        } finally {\\n            this.syncInProgress = false;\\n            this.updateSyncIndicator(false);\\n        }\\n    }\\n    \\n    async syncQuizSubmissions() {\\n        const submissionsToSync = this.syncQueue.filter(item => item.type === 'quiz_submission');\\n        \\n        for (const submission of submissionsToSync) {\\n            try {\\n                const response = await fetch(submission.url, {\\n                    method: submission.method,\\n                    headers: {\\n                        'Content-Type': 'application/x-www-form-urlencoded',\\n                        'X-CSRFToken': this.getCSRFToken()\\n                    },\\n                    body: new URLSearchParams(submission.data)\\n                });\\n                \\n                if (response.ok) {\\n                    console.log('? Synced submission:', submission.id);\\n                    // Remove from sync queue\\n                    const index = this.syncQueue.findIndex(item => item.id === submission.id);\\n                    if (index > -1) {\\n                        this.syncQueue.splice(index, 1);\\n                    }\\n                } else {\\n                    console.error('? Failed to sync submission:', response.status);\\n                }\\n                \\n            } catch (error) {\\n                console.error('? Network error syncing submission:', error);\\n            }\\n        }\\n    }\\n    \\n    async syncSavedProgress() {\\n        const progressKeys = Object.keys(localStorage)\\n            .filter(key => key.startsWith('quiz_progress_'));\\n        \\n        for (const key of progressKeys) {\\n            try {\\n                const progressData = JSON.parse(localStorage.getItem(key));\\n                \\n                // Send progress update to server\\n                const response = await fetch('/api/quiz/sync-progress', {\\n                    method: 'POST',\\n                    headers: {\\n                        'Content-Type': 'application/json',\\n                        'X-CSRFToken': this.getCSRFToken()\\n                    },\\n                    body: JSON.stringify(progressData)\\n                });\\n                \\n                if (response.ok) {\\n                    console.log('? Synced progress for quiz:', progressData.quizId);\\n                    localStorage.removeItem(key);\\n                }\\n                \\n            } catch (error) {\\n                console.error('? Failed to sync progress:', error);\\n            }\\n        }\\n    }\\n    \\n    async forcSync() {\\n        if (this.isOnline) {\\n            await this.startSync();\\n        } else {\\n            this.showSyncErrorMessage('Cannot sync while offline');\\n        }\\n    }\\n    \\n    async loadOfflineData() {\\n        try {\\n            const savedQueue = localStorage.getItem(this.offlineStorage.sync_queue);\\n            if (savedQueue) {\\n                this.syncQueue = JSON.parse(savedQueue);\\n            }\\n        } catch (error) {\\n            console.error('? Failed to load offline data:', error);\\n        }\\n    }\\n    \\n    async saveSyncQueue() {\\n        try {\\n            localStorage.setItem(this.offlineStorage.sync_queue, JSON.stringify(this.syncQueue));\\n        } catch (error) {\\n            console.error('? Failed to save sync queue:', error);\\n        }\\n    }\\n    \\n    async clearSyncQueue() {\\n        this.syncQueue = [];\\n        localStorage.removeItem(this.offlineStorage.sync_queue);\\n    }\\n    \\n    async restoreSyncQueue() {\\n        if (this.isOnline && this.syncQueue.length > 0) {\\n            setTimeout(() => {\\n                this.startSync();\\n            }, 2000); // Wait 2 seconds before starting sync\\n        }\\n    }\\n    \\n    setupPeriodicSync() {\\n        // Try to sync every 5 minutes when online\\n        setInterval(() => {\\n            if (this.isOnline && this.syncQueue.length > 0 && !this.syncInProgress) {\\n                this.startSync();\\n            }\\n        }, 300000); // 5 minutes\\n    }\\n    \\n    handleServiceWorkerMessage(event) {\\n        const { type, data } = event.data;\\n        \\n        switch (type) {\\n            case 'CACHE_UPDATED':\\n                console.log('? Cache updated by service worker');\\n                break;\\n            case 'OFFLINE_FALLBACK':\\n                console.log('? Service worker served offline fallback');\\n                break;\\n        }\\n    }\\n    \\n    showSyncSuccessMessage() {\\n        if (window.accessibilityManager) {\\n            window.accessibilityManager.makeAnnouncement('Offline data synced successfully', 'polite');\\n        }\\n    }\\n    \\n    showSyncErrorMessage(customMessage) {\\n        const message = customMessage || 'Failed to sync offline data. Will retry automatically.';\\n        if (window.accessibilityManager) {\\n            window.accessibilityManager.makeAnnouncement(message, 'assertive');\\n        }\\n    }\\n    \\n    getCSRFToken() {\\n        const tokenElement = document.querySelector('[name=csrf-token]');\\n        return tokenElement ? tokenElement.getAttribute('content') : '';\\n    }\\n    \\n    // Public API\\n    isOffline() {\\n        return !this.isOnline;\\n    }\\n    \\n    getSyncQueueSize() {\\n        return this.syncQueue.length;\\n    }\\n    \\n    getOfflineData() {\\n        return {\\n            quizzes: JSON.parse(localStorage.getItem(this.offlineStorage.quizzes) || '{}'),\\n            answers: JSON.parse(localStorage.getItem(this.offlineStorage.answers) || '{}'),\\n            syncQueue: this.syncQueue\\n        };\\n    }\\n    \\n    clearOfflineData() {\\n        Object.values(this.offlineStorage).forEach(key => {\\n            localStorage.removeItem(key);\\n        });\\n        this.syncQueue = [];\\n        console.log('?? Offline data cleared');\\n    }\\n}\\n\\n// Auto-initialize offline manager\\ndocument.addEventListener('DOMContentLoaded', () => {\\n    window.offlineManager = new OfflineManager();\\n});\\n\\n// Export for use in other modules\\nif (typeof module !== 'undefined' && module.exports) {\\n    module.exports = OfflineManager;\\n}","size_bytes":25235},"static/js/offline-service-worker.js":{"content":"/**\n * BigBossizzz Offline Service Worker\n * Handles caching and offline functionality for quiz platform\n */\n\nconst CACHE_NAME = 'bigbossizzz-offline-v1';\nconst STATIC_CACHE = 'bigbossizzz-static-v1';\nconst DYNAMIC_CACHE = 'bigbossizzz-dynamic-v1';\n\n// Resources to cache for offline use\nconst STATIC_ASSETS = [\n    '/',\n    '/static/css/theme-system.css',\n    '/static/css/accessibility-features.css',\n    '/static/css/mobile-enhancements.css',\n    '/static/js/theme-manager.js',\n    '/static/js/accessibility-manager.js',\n    '/static/js/offline-manager.js',\n    '/static/js/mobile-app.js',\n    '/static/manifest.json',\n    'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css',\n    'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css'\n];\n\n// Install event - cache static assets\nself.addEventListener('install', event => {\n    console.log('Service Worker installing...');\n    \n    event.waitUntil(\n        caches.open(STATIC_CACHE)\n            .then(cache => {\n                console.log('Caching static assets');\n                return cache.addAll(STATIC_ASSETS);\n            })\n            .then(() => {\n                console.log('Static assets cached successfully');\n                return self.skipWaiting();\n            })\n            .catch(error => {\n                console.error('Failed to cache static assets:', error);\n            })\n    );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', event => {\n    console.log('Service Worker activating...');\n    \n    event.waitUntil(\n        caches.keys()\n            .then(cacheNames => {\n                return Promise.all(\n                    cacheNames.map(cacheName => {\n                        if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\n                            console.log('Deleting old cache:', cacheName);\n                            return caches.delete(cacheName);\n                        }\n                    })\n                );\n            })\n            .then(() => {\n                console.log('Service Worker activated');\n                return self.clients.claim();\n            })\n    );\n});\n\n// Fetch event - handle requests with caching strategy\nself.addEventListener('fetch', event => {\n    const { request } = event;\n    const url = new URL(request.url);\n    \n    // Skip non-GET requests and chrome-extension requests\n    if (request.method !== 'GET' || url.protocol === 'chrome-extension:') {\n        return;\n    }\n    \n    // Handle different types of requests\n    if (isStaticAsset(request)) {\n        event.respondWith(handleStaticAsset(request));\n    } else if (isQuizRequest(request)) {\n        event.respondWith(handleQuizRequest(request));\n    } else if (isAPIRequest(request)) {\n        event.respondWith(handleAPIRequest(request));\n    } else {\n        event.respondWith(handleOtherRequests(request));\n    }\n});\n\n// Check if request is for static assets\nfunction isStaticAsset(request) {\n    const url = new URL(request.url);\n    return url.pathname.startsWith('/static/') || \n           url.hostname.includes('cdn.jsdelivr.net') ||\n           url.hostname.includes('cdnjs.cloudflare.com');\n}\n\n// Check if request is quiz-related\nfunction isQuizRequest(request) {\n    const url = new URL(request.url);\n    return url.pathname.includes('/quiz/') || \n           url.pathname.includes('/take-quiz/');\n}\n\n// Check if request is API call\nfunction isAPIRequest(request) {\n    const url = new URL(request.url);\n    return url.pathname.startsWith('/api/');\n}\n\n// Handle static assets - Cache First strategy\nasync function handleStaticAsset(request) {\n    try {\n        const cache = await caches.open(STATIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        \n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n        \n    } catch (error) {\n        console.error('? Failed to handle static asset:', error);\n        \n        // Return cached version if available\n        const cache = await caches.open(STATIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return offline fallback\n        return new Response('Offline - Asset not available', {\n            status: 503,\n            statusText: 'Service Unavailable'\n        });\n    }\n}\n\n// Handle quiz requests - Network First strategy with offline support\nasync function handleQuizRequest(request) {\n    try {\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            // Cache successful quiz responses\n            const cache = await caches.open(DYNAMIC_CACHE);\n            cache.put(request, networkResponse.clone());\n            return networkResponse;\n        }\n        \n        // If network fails, try cache\n        const cache = await caches.open(DYNAMIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return offline quiz page\n        return getOfflineQuizPage();\n        \n    } catch (error) {\n        console.error('? Network error for quiz request:', error);\n        \n        // Try to serve from cache\n        const cache = await caches.open(DYNAMIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return offline quiz page\n        return getOfflineQuizPage();\n    }\n}\n\n// Handle API requests - special offline handling\nasync function handleAPIRequest(request) {\n    const url = new URL(request.url);\n    \n    // Connectivity check endpoint\n    if (url.pathname === '/api/connectivity-check') {\n        return new Response('OK', { status: 200 });\n    }\n    \n    try {\n        const networkResponse = await fetch(request);\n        return networkResponse;\n        \n    } catch (error) {\n        console.error('? API request failed:', error);\n        \n        // For quiz-related APIs in offline mode\n        if (url.pathname.includes('/quiz/') || url.pathname.includes('/api/quiz/')) {\n            return handleOfflineQuizAPI(request);\n        }\n        \n        // Return offline API response\n        return new Response(JSON.stringify({\n            error: 'Offline - API not available',\n            offline: true,\n            timestamp: new Date().toISOString()\n        }), {\n            status: 503,\n            statusText: 'Service Unavailable',\n            headers: { 'Content-Type': 'application/json' }\n        });\n    }\n}\n\n// Handle other requests - Cache First with Network Fallback\nasync function handleOtherRequests(request) {\n    try {\n        const cache = await caches.open(DYNAMIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        \n        if (cachedResponse) {\n            // Serve from cache and try to update in background\n            fetch(request)\n                .then(networkResponse => {\n                    if (networkResponse.ok) {\n                        cache.put(request, networkResponse.clone());\n                    }\n                })\n                .catch(() => {\n                    // Network failed, but we already have cached version\n                });\n            \n            return cachedResponse;\n        }\n        \n        const networkResponse = await fetch(request);\n        if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n        \n    } catch (error) {\n        console.error('? Request failed:', error);\n        \n        // Try cache one more time\n        const cache = await caches.open(DYNAMIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return offline page\n        return getOfflinePage();\n    }\n}\n\n// Generate offline quiz page\nfunction getOfflineQuizPage() {\n    const html = `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Offline Quiz - BigBossizzz</title>\n        <style>\n            body {\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                margin: 0;\n                padding: 20px;\n                background: #f8f9fa;\n                color: #333;\n            }\n            .container {\n                max-width: 800px;\n                margin: 0 auto;\n                background: white;\n                padding: 30px;\n                border-radius: 8px;\n                box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            }\n            .offline-icon {\n                font-size: 4rem;\n                text-align: center;\n                margin-bottom: 20px;\n                color: #ffc107;\n            }\n            h1 {\n                text-align: center;\n                color: #495057;\n                margin-bottom: 20px;\n            }\n            .message {\n                text-align: center;\n                margin-bottom: 30px;\n                line-height: 1.6;\n            }\n            .btn {\n                display: inline-block;\n                padding: 12px 24px;\n                background: #007bff;\n                color: white;\n                text-decoration: none;\n                border-radius: 4px;\n                margin: 0 10px;\n            }\n            .btn:hover {\n                background: #0056b3;\n            }\n            .features {\n                margin-top: 30px;\n                padding-top: 20px;\n                border-top: 1px solid #dee2e6;\n            }\n            .feature {\n                margin-bottom: 15px;\n                padding: 10px;\n                background: #e9ecef;\n                border-radius: 4px;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"container\">\n            <div class=\"offline-icon\">?</div>\n            <h1>Offline Mode Active</h1>\n            <div class=\"message\">\n                <p>You're currently offline, but don't worry! BigBossizzz has you covered.</p>\n                <p>Your quiz progress is being saved locally and will sync automatically when your connection is restored.</p>\n            </div>\n            \n            <div style=\"text-align: center;\">\n                <a href=\"javascript:location.reload()\" class=\"btn\">Try Again</a>\n                <a href=\"/\" class=\"btn\">Go Home</a>\n            </div>\n            \n            <div class=\"features\">\n                <h3>Offline Features Available:</h3>\n                <div class=\"feature\">\n                    ? Continue taking your current quiz\n                </div>\n                <div class=\"feature\">\n                    ? All answers are saved locally\n                </div>\n                <div class=\"feature\">\n                    ? Automatic sync when connection returns\n                </div>\n                <div class=\"feature\">\n                    ? Theme and accessibility preferences maintained\n                </div>\n            </div>\n        </div>\n        \n        <script>\n            // Check for connection every 5 seconds\n            setInterval(() => {\n                if (navigator.onLine) {\n                    location.reload();\n                }\n            }, 5000);\n            \n            // Listen for online event\n            window.addEventListener('online', () => {\n                location.reload();\n            });\n        </script>\n    </body>\n    </html>\n    `;\n    \n    return new Response(html, {\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\n// Generate offline page for other content\nfunction getOfflinePage() {\n    const html = `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Offline - BigBossizzz</title>\n        <style>\n            body {\n                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                margin: 0;\n                padding: 20px;\n                background: #f8f9fa;\n                color: #333;\n                text-align: center;\n            }\n            .container {\n                max-width: 600px;\n                margin: 100px auto;\n                background: white;\n                padding: 40px;\n                border-radius: 8px;\n                box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n            }\n            .offline-icon {\n                font-size: 5rem;\n                margin-bottom: 20px;\n                color: #ffc107;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"container\">\n            <div class=\"offline-icon\">?</div>\n            <h1>You're Offline</h1>\n            <p>This page isn't available offline. Please check your connection and try again.</p>\n            <button onclick=\"location.reload()\" style=\"padding: 10px 20px; margin-top: 20px;\">Try Again</button>\n        </div>\n        \n        <script>\n            window.addEventListener('online', () => {\n                location.reload();\n            });\n        </script>\n    </body>\n    </html>\n    `;\n    \n    return new Response(html, {\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\n// Handle offline quiz API requests\nfunction handleOfflineQuizAPI(request) {\n    const url = new URL(request.url);\n    \n    // Quiz sync endpoint\n    if (url.pathname === '/api/quiz/sync-progress') {\n        return new Response(JSON.stringify({\n            success: true,\n            message: 'Progress will be synced when online',\n            offline: true\n        }), {\n            headers: { 'Content-Type': 'application/json' }\n        });\n    }\n    \n    // Default offline API response\n    return new Response(JSON.stringify({\n        error: 'API temporarily unavailable offline',\n        offline: true,\n        retry: true\n    }), {\n        status: 503,\n        headers: { 'Content-Type': 'application/json' }\n    });\n}\n\n// Message handling from main thread\nself.addEventListener('message', event => {\n    const { type, data } = event.data;\n    \n    switch (type) {\n        case 'SKIP_WAITING':\n            self.skipWaiting();\n            break;\n            \n        case 'CACHE_QUIZ_DATA':\n            cacheQuizData(data);\n            break;\n            \n        case 'GET_CACHE_INFO':\n            getCacheInfo().then(info => {\n                event.ports[0].postMessage(info);\n            });\n            break;\n    }\n});\n\n// Cache quiz data for offline use\nasync function cacheQuizData(quizData) {\n    try {\n        const cache = await caches.open(DYNAMIC_CACHE);\n        const response = new Response(JSON.stringify(quizData), {\n            headers: { 'Content-Type': 'application/json' }\n        });\n        \n        await cache.put(`/api/quiz/${quizData.id}/offline`, response);\n        console.log('[INFO] Quiz data cached for offline use:', quizData.id);\n        \n    } catch (error) {\n        console.error('? Failed to cache quiz data:', error);\n    }\n}\n\n// Get cache information\nasync function getCacheInfo() {\n    try {\n        const cacheNames = await caches.keys();\n        const info = {\n            caches: cacheNames.length,\n            static_assets: 0,\n            dynamic_content: 0\n        };\n        \n        for (const cacheName of cacheNames) {\n            const cache = await caches.open(cacheName);\n            const keys = await cache.keys();\n            \n            if (cacheName === STATIC_CACHE) {\n                info.static_assets = keys.length;\n            } else if (cacheName === DYNAMIC_CACHE) {\n                info.dynamic_content = keys.length;\n            }\n        }\n        \n        return info;\n        \n    } catch (error) {\n        console.error('? Failed to get cache info:', error);\n        return { error: 'Failed to get cache info' };\n    }\n}\n\nconsole.log('[INFO] BigBossizzz Service Worker loaded');","size_bytes":16246},"static/js/sw.js":{"content":"/**\n * BigBossizzz Service Worker\n * Provides offline functionality and caching for PWA\n */\n\nconst CACHE_NAME = 'bigbossizzz-v1.2.0';\nconst OFFLINE_URL = '/offline';\n\n// Assets to cache immediately\nconst STATIC_CACHE_URLS = [\n    '/',\n    '/offline',\n    '/static/css/bootstrap.min.css',\n    '/static/css/custom.css', \n    '/static/css/mobile-enhancements.css',\n    '/static/js/bootstrap.bundle.min.js',\n    '/static/js/mobile-app.js',\n    '/static/js/proctoring.js',\n    '/static/images/icon-192x192.png',\n    '/static/images/icon-512x512.png',\n    'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css'\n];\n\n// Assets to cache on first request\nconst DYNAMIC_CACHE_URLS = [\n    '/participant_dashboard',\n    '/host_dashboard', \n    '/admin/dashboard',\n    '/available_quizzes',\n    '/profile',\n    '/quiz_results'\n];\n\n// Network-first resources (always try network first)\nconst NETWORK_FIRST_URLS = [\n    '/api/',\n    '/take_quiz/',\n    '/submit_quiz'\n];\n\nself.addEventListener('install', (event) => {\n    console.log('[INFO] Service Worker installing...');\n    \n    event.waitUntil(\n        caches.open(CACHE_NAME)\n            .then((cache) => {\n                console.log('[INFO] Caching static assets...');\n                return cache.addAll(STATIC_CACHE_URLS);\n            })\n            .then(() => {\n                console.log('[INFO] Static assets cached successfully');\n                return self.skipWaiting();\n            })\n            .catch((error) => {\n                console.error('[ERROR] Cache installation failed:', error);\n            })\n    );\n});\n\nself.addEventListener('activate', (event) => {\n    console.log('[INFO] Service Worker activating...');\n    \n    event.waitUntil(\n        caches.keys()\n            .then((cacheNames) => {\n                return Promise.all(\n                    cacheNames.map((cacheName) => {\n                        if (cacheName !== CACHE_NAME) {\n                            console.log('[DEBUG] Deleting old cache:', cacheName);\n                            return caches.delete(cacheName);\n                        }\n                    })\n                );\n            })\n            .then(() => {\n                console.log('[INFO] Service Worker activated');\n                return self.clients.claim();\n            })\n    );\n});\n\nself.addEventListener('fetch', (event) => {\n    const requestUrl = new URL(event.request.url);\n    \n    // Skip cross-origin requests\n    if (requestUrl.origin !== location.origin) {\n        return;\n    }\n    \n    // Handle different request types\n    if (event.request.method === 'GET') {\n        if (isNetworkFirst(requestUrl.pathname)) {\n            event.respondWith(networkFirst(event.request));\n        } else if (isStaticAsset(requestUrl.pathname)) {\n            event.respondWith(cacheFirst(event.request));\n        } else {\n            event.respondWith(staleWhileRevalidate(event.request));\n        }\n    }\n});\n\n// Cache strategies\nasync function networkFirst(request) {\n    try {\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n    } catch (error) {\n        console.log('[WARN] Network failed, trying cache:', request.url);\n        \n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return offline page for navigation requests\n        if (request.mode === 'navigate') {\n            return caches.match(OFFLINE_URL);\n        }\n        \n        throw error;\n    }\n}\n\nasync function cacheFirst(request) {\n    const cachedResponse = await caches.match(request);\n    \n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    \n    try {\n        const networkResponse = await fetch(request);\n        \n        if (networkResponse.ok) {\n            const cache = await caches.open(CACHE_NAME);\n            cache.put(request, networkResponse.clone());\n        }\n        \n        return networkResponse;\n    } catch (error) {\n        console.error('? Failed to fetch:', request.url, error);\n        throw error;\n    }\n}\n\nasync function staleWhileRevalidate(request) {\n    const cache = await caches.open(CACHE_NAME);\n    const cachedResponse = await cache.match(request);\n    \n    const fetchPromise = fetch(request).then((networkResponse) => {\n        if (networkResponse.ok) {\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n    }).catch((error) => {\n        console.log('[WARN] Network failed for:', request.url);\n        return cachedResponse;\n    });\n    \n    return cachedResponse || fetchPromise;\n}\n\n// Helper functions\nfunction isNetworkFirst(pathname) {\n    return NETWORK_FIRST_URLS.some(url => pathname.startsWith(url));\n}\n\nfunction isStaticAsset(pathname) {\n    return pathname.startsWith('/static/') || \n           pathname.endsWith('.css') || \n           pathname.endsWith('.js') || \n           pathname.endsWith('.png') || \n           pathname.endsWith('.jpg') || \n           pathname.endsWith('.svg');\n}\n\n// Background sync for offline quiz submissions\nself.addEventListener('sync', (event) => {\n    if (event.tag === 'quiz-submission') {\n        event.waitUntil(syncQuizSubmissions());\n    }\n});\n\nasync function syncQuizSubmissions() {\n    try {\n        const cache = await caches.open('quiz-submissions');\n        const requests = await cache.keys();\n        \n        for (const request of requests) {\n            try {\n                const response = await fetch(request);\n                if (response.ok) {\n                    await cache.delete(request);\n                    console.log('[INFO] Quiz submission synced:', request.url);\n                }\n            } catch (error) {\n                console.log('[ERROR] Failed to sync quiz submission:', error);\n            }\n        }\n    } catch (error) {\n        console.error('? Background sync failed:', error);\n    }\n}\n\n// Push notifications\nself.addEventListener('push', (event) => {\n    if (!event.data) return;\n    \n    const data = event.data.json();\n    const options = {\n        body: data.body,\n        icon: '/static/images/icon-192x192.png',\n        badge: '/static/images/icon-72x72.png',\n        data: data.url,\n        actions: [\n            {\n                action: 'open',\n                title: 'Open',\n                icon: '/static/images/icon-72x72.png'\n            },\n            {\n                action: 'close',\n                title: 'Close'\n            }\n        ],\n        requireInteraction: true,\n        renotify: true,\n        tag: data.tag || 'bigbossizzz-notification'\n    };\n    \n    event.waitUntil(\n        self.registration.showNotification(data.title, options)\n    );\n});\n\n// Notification click handling\nself.addEventListener('notificationclick', (event) => {\n    event.notification.close();\n    \n    if (event.action === 'open' || !event.action) {\n        const urlToOpen = event.notification.data || '/';\n        \n        event.waitUntil(\n            clients.matchAll({ type: 'window' }).then((clientsArr) => {\n                const hadWindowToFocus = clientsArr.some((windowClient) => {\n                    if (windowClient.url === urlToOpen) {\n                        windowClient.focus();\n                        return true;\n                    }\n                    return false;\n                });\n                \n                if (!hadWindowToFocus) {\n                    clients.openWindow(urlToOpen);\n                }\n            })\n        );\n    }\n});\n\n// Share target handling\nself.addEventListener('fetch', (event) => {\n    if (event.request.method === 'POST' && event.request.url.endsWith('/share-target')) {\n        event.respondWith(handleShareTarget(event.request));\n    }\n});\n\nasync function handleShareTarget(request) {\n    const formData = await request.formData();\n    const title = formData.get('title') || '';\n    const text = formData.get('text') || '';\n    const url = formData.get('url') || '';\n    \n    // Store shared content for the app to process\n    const shareData = { title, text, url, timestamp: Date.now() };\n    \n    const cache = await caches.open('shared-content');\n    await cache.put('/shared-content', new Response(JSON.stringify(shareData)));\n    \n    return Response.redirect('/?shared=1', 303);\n}\n\n// Periodic background sync\nself.addEventListener('periodicsync', (event) => {\n    if (event.tag === 'quiz-data-sync') {\n        event.waitUntil(syncQuizData());\n    }\n});\n\nasync function syncQuizData() {\n    try {\n        // Sync quiz data, results, and user progress\n        console.log('[INFO] Syncing quiz data...');\n        \n        const response = await fetch('/api/sync-quiz-data', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        \n        if (response.ok) {\n            console.log('[INFO] Quiz data synced successfully');\n        }\n    } catch (error) {\n        console.error('? Quiz data sync failed:', error);\n    }\n}\n\n// Error handling\nself.addEventListener('error', (event) => {\n    console.error('? Service Worker error:', event.error);\n});\n\nself.addEventListener('unhandledrejection', (event) => {\n    console.error('? Service Worker unhandled rejection:', event.reason);\n});\n\nconsole.log('[INFO] BigBossizzz Service Worker loaded successfully');\n// Cache cleared at 1757693624","size_bytes":9541},"static/js/theme-manager.js":{"content":"/**\n * BigBossizzz Theme Manager\n * Comprehensive theme management with user preferences and accessibility\n */\n\nclass ThemeManager {\n    constructor() {\n        this.currentTheme = 'auto';\n        this.themes = {\n            'auto': {\n                name: 'Auto',\n                icon: 'fas fa-adjust',\n                description: 'Follow system preference'\n            },\n            'light': {\n                name: 'Light',\n                icon: 'fas fa-sun',\n                description: 'Light theme'\n            },\n            'dark': {\n                name: 'Dark',\n                icon: 'fas fa-moon',\n                description: 'Dark theme'\n            }\n        };\n        \n        this.init();\n    }\n    \n    init() {\n        console.log('[INFO] Initializing Theme Manager...');\n        \n        // Load saved theme preference\n        this.loadThemePreference();\n        \n        // Apply initial theme\n        this.applyTheme(this.currentTheme);\n        \n        // Create theme toggle UI\n        this.createThemeToggle();\n        \n        // Listen for system theme changes\n        this.listenForSystemThemeChanges();\n        \n        // Save preference to user profile if logged in\n        this.saveThemeToProfile();\n        \n        console.log('[INFO] Theme Manager initialized successfully');\n    }\n    \n    loadThemePreference() {\n        // Try to load from user profile first\n        const profileTheme = this.getUserProfileTheme();\n        if (profileTheme) {\n            this.currentTheme = profileTheme;\n            return;\n        }\n        \n        // Fall back to localStorage\n        const savedTheme = localStorage.getItem('bigbossizzz-theme');\n        if (savedTheme && this.themes[savedTheme]) {\n            this.currentTheme = savedTheme;\n            return;\n        }\n        \n        // Default to auto (system preference)\n        this.currentTheme = 'auto';\n    }\n    \n    getUserProfileTheme() {\n        // Check if user preference is available in the page\n        const themeElement = document.querySelector('[data-user-theme]');\n        return themeElement ? themeElement.dataset.userTheme : null;\n    }\n    \n    applyTheme(theme) {\n        console.log(`[INFO] Applying theme: ${theme}`);\n        \n        // Remove existing theme classes\n        document.documentElement.removeAttribute('data-theme');\n        \n        // Apply new theme\n        if (theme !== 'auto') {\n            document.documentElement.setAttribute('data-theme', theme);\n        }\n        \n        // Store current theme\n        this.currentTheme = theme;\n        \n        // Save to localStorage\n        localStorage.setItem('bigbossizzz-theme', theme);\n        \n        // Update theme toggle UI\n        this.updateThemeToggleUI();\n        \n        // Announce theme change for screen readers\n        this.announceThemeChange(theme);\n        \n        // Save to user profile\n        this.saveThemeToProfile();\n        \n        // Dispatch theme change event\n        window.dispatchEvent(new CustomEvent('themeChanged', {\n            detail: { theme: theme, effectiveTheme: this.getEffectiveTheme() }\n        }));\n    }\n    \n    getEffectiveTheme() {\n        if (this.currentTheme === 'auto') {\n            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n        }\n        return this.currentTheme;\n    }\n    \n    createThemeToggle() {\n        // Create theme toggle button\n        const themeToggle = document.createElement('div');\n        themeToggle.className = 'theme-toggle';\n        themeToggle.setAttribute('role', 'button');\n        themeToggle.setAttribute('tabindex', '0');\n        themeToggle.setAttribute('aria-label', 'Theme selector');\n        themeToggle.setAttribute('aria-expanded', 'false');\n        themeToggle.innerHTML = `\n            <i class=\"${this.themes[this.currentTheme].icon}\" aria-hidden=\"true\"></i>\n            <div class=\"theme-toggle-dropdown\" id=\"themeDropdown\">\n                ${Object.entries(this.themes).map(([key, theme]) => `\n                    <div class=\"theme-option\" data-theme=\"${key}\" role=\"menuitem\" tabindex=\"0\"\n                         aria-label=\"Switch to ${theme.name} theme\">\n                        <i class=\"${theme.icon}\" aria-hidden=\"true\"></i>\n                        <span>${theme.name}</span>\n                    </div>\n                `).join('')}\n            </div>\n        `;\n        \n        // Add event listeners\n        themeToggle.addEventListener('click', this.toggleThemeDropdown.bind(this));\n        themeToggle.addEventListener('keydown', this.handleThemeToggleKeydown.bind(this));\n        \n        // Add option event listeners\n        const dropdown = themeToggle.querySelector('.theme-toggle-dropdown');\n        dropdown.addEventListener('click', this.handleThemeOptionClick.bind(this));\n        dropdown.addEventListener('keydown', this.handleThemeOptionKeydown.bind(this));\n        \n        // Close dropdown when clicking outside\n        document.addEventListener('click', (e) => {\n            if (!themeToggle.contains(e.target)) {\n                this.closeThemeDropdown();\n            }\n        });\n        \n        // Add to page\n        document.body.appendChild(themeToggle);\n        \n        // Update initial UI state\n        this.updateThemeToggleUI();\n    }\n    \n    toggleThemeDropdown() {\n        const dropdown = document.getElementById('themeDropdown');\n        const isOpen = dropdown.classList.contains('show');\n        \n        if (isOpen) {\n            this.closeThemeDropdown();\n        } else {\n            this.openThemeDropdown();\n        }\n    }\n    \n    openThemeDropdown() {\n        const dropdown = document.getElementById('themeDropdown');\n        const toggle = dropdown.parentElement;\n        \n        dropdown.classList.add('show');\n        toggle.setAttribute('aria-expanded', 'true');\n        \n        // Focus first option\n        const firstOption = dropdown.querySelector('.theme-option');\n        if (firstOption) {\n            firstOption.focus();\n        }\n    }\n    \n    closeThemeDropdown() {\n        const dropdown = document.getElementById('themeDropdown');\n        const toggle = dropdown.parentElement;\n        \n        dropdown.classList.remove('show');\n        toggle.setAttribute('aria-expanded', 'false');\n    }\n    \n    handleThemeToggleKeydown(event) {\n        if (event.key === 'Enter' || event.key === ' ') {\n            event.preventDefault();\n            this.toggleThemeDropdown();\n        } else if (event.key === 'Escape') {\n            this.closeThemeDropdown();\n        }\n    }\n    \n    handleThemeOptionClick(event) {\n        const option = event.target.closest('.theme-option');\n        if (option) {\n            const theme = option.dataset.theme;\n            this.applyTheme(theme);\n            this.closeThemeDropdown();\n        }\n    }\n    \n    handleThemeOptionKeydown(event) {\n        const options = Array.from(event.currentTarget.querySelectorAll('.theme-option'));\n        const currentIndex = options.indexOf(event.target);\n        \n        switch (event.key) {\n            case 'Enter':\n            case ' ':\n                event.preventDefault();\n                const theme = event.target.dataset.theme;\n                this.applyTheme(theme);\n                this.closeThemeDropdown();\n                break;\n                \n            case 'ArrowDown':\n                event.preventDefault();\n                const nextIndex = (currentIndex + 1) % options.length;\n                options[nextIndex].focus();\n                break;\n                \n            case 'ArrowUp':\n                event.preventDefault();\n                const prevIndex = (currentIndex - 1 + options.length) % options.length;\n                options[prevIndex].focus();\n                break;\n                \n            case 'Escape':\n                event.preventDefault();\n                this.closeThemeDropdown();\n                document.querySelector('.theme-toggle').focus();\n                break;\n                \n            case 'Home':\n                event.preventDefault();\n                options[0].focus();\n                break;\n                \n            case 'End':\n                event.preventDefault();\n                options[options.length - 1].focus();\n                break;\n        }\n    }\n    \n    updateThemeToggleUI() {\n        const toggle = document.querySelector('.theme-toggle');\n        if (!toggle) return;\n        \n        // Update main icon\n        const mainIcon = toggle.querySelector('i');\n        if (mainIcon) {\n            mainIcon.className = this.themes[this.currentTheme].icon;\n        }\n        \n        // Update active option\n        const options = toggle.querySelectorAll('.theme-option');\n        options.forEach(option => {\n            option.classList.toggle('active', option.dataset.theme === this.currentTheme);\n        });\n        \n        // Update aria-label\n        toggle.setAttribute('aria-label', \n            `Current theme: ${this.themes[this.currentTheme].name}. Click to change theme.`);\n    }\n    \n    listenForSystemThemeChanges() {\n        // Listen for system theme changes when in auto mode\n        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n        mediaQuery.addEventListener('change', (e) => {\n            if (this.currentTheme === 'auto') {\n                console.log('[INFO] System theme changed, updating...');\n                this.announceThemeChange('auto');\n                window.dispatchEvent(new CustomEvent('themeChanged', {\n                    detail: { theme: 'auto', effectiveTheme: e.matches ? 'dark' : 'light' }\n                }));\n            }\n        });\n    }\n    \n    announceThemeChange(theme) {\n        // Create announcement for screen readers\n        const announcement = document.createElement('div');\n        announcement.setAttribute('aria-live', 'polite');\n        announcement.setAttribute('aria-atomic', 'true');\n        announcement.className = 'sr-only';\n        \n        const effectiveTheme = this.getEffectiveTheme();\n        announcement.textContent = `Theme changed to ${this.themes[theme].name}. \n            ${theme === 'auto' ? `Currently using ${effectiveTheme} mode.` : ''}`;\n        \n        document.body.appendChild(announcement);\n        \n        // Remove after announcement\n        setTimeout(() => {\n            if (announcement.parentNode) {\n                announcement.parentNode.removeChild(announcement);\n            }\n        }, 1000);\n    }\n    \n    async saveThemeToProfile() {\n        // Save theme preference to user profile\n        try {\n            const response = await fetch('/api/user/theme-preference', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRFToken': this.getCSRFToken()\n                },\n                body: JSON.stringify({\n                    theme: this.currentTheme\n                })\n            });\n            \n            if (response.ok) {\n                console.log('[INFO] Theme preference saved to profile');\n            }\n        } catch (error) {\n            console.error('[ERROR] Could not save theme preference:', error);\n            // Silent fail - user not logged in or network issue\n        }\n    }\n    \n    getCSRFToken() {\n        const tokenElement = document.querySelector('[name=csrf-token]');\n        return tokenElement ? tokenElement.getAttribute('content') : '';\n    }\n    \n    // Public API methods\n    setTheme(theme) {\n        if (this.themes[theme]) {\n            this.applyTheme(theme);\n        }\n    }\n    \n    getCurrentTheme() {\n        return this.currentTheme;\n    }\n    \n    getEffectiveCurrentTheme() {\n        return this.getEffectiveTheme();\n    }\n    \n    getAvailableThemes() {\n        return Object.keys(this.themes);\n    }\n    \n    // Accessibility helpers\n    getThemeForContrast() {\n        // Return high contrast theme if user prefers high contrast\n        if (window.matchMedia('(prefers-contrast: high)').matches) {\n            return this.getEffectiveTheme() === 'dark' ? 'dark-high-contrast' : 'light-high-contrast';\n        }\n        return this.getEffectiveTheme();\n    }\n    \n    supportsTheme(theme) {\n        return this.themes.hasOwnProperty(theme);\n    }\n}\n\n// Auto-initialize theme manager when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.themeManager = new ThemeManager();\n});\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ThemeManager;\n}","size_bytes":12578},"static/js/voice-commands.js":{"content":"/**\n * BigBossizzz Voice Commands\n * Accessibility-focused voice control system for quiz navigation and interaction\n */\n\nclass VoiceCommandsManager {\n    constructor() {\n        this.recognition = null;\n        this.isListening = false;\n        this.isSupported = false;\n        this.commands = new Map();\n        this.currentContext = 'general';\n        this.confidenceThreshold = 0.7;\n        this.voiceIndicator = null;\n        this.lastCommand = null;\n        this.commandHistory = [];\n        \n        this.init();\n    }\n    \n    init() {\n        console.log('[INFO] Initializing Voice Commands Manager...');\n        \n        // Check browser support\n        this.checkSupport();\n        \n        if (!this.isSupported) {\n            console.log('[WARN] Voice commands not supported in this browser');\n            return;\n        }\n        \n        // Setup speech recognition\n        this.setupSpeechRecognition();\n        \n        // Define voice commands\n        this.defineCommands();\n        \n        // Setup voice indicator UI\n        this.setupVoiceIndicator();\n        \n        // Setup keyboard shortcuts for voice control\n        this.setupKeyboardShortcuts();\n        \n        // Setup context detection\n        this.setupContextDetection();\n        \n        console.log('[INFO] Voice Commands Manager initialized successfully');\n    }\n    \n    checkSupport() {\n        this.isSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;\n        \n        if (this.isSupported) {\n            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n            this.recognition = new SpeechRecognition();\n        }\n    }\n    \n    setupSpeechRecognition() {\n        if (!this.recognition) return;\n        \n        // Configure speech recognition\n        this.recognition.continuous = false;\\n        this.recognition.interimResults = false;\\n        this.recognition.lang = 'en-US';\\n        this.recognition.maxAlternatives = 3;\\n        \\n        // Event listeners\\n        this.recognition.onstart = this.handleRecognitionStart.bind(this);\\n        this.recognition.onresult = this.handleRecognitionResult.bind(this);\\n        this.recognition.onerror = this.handleRecognitionError.bind(this);\\n        this.recognition.onend = this.handleRecognitionEnd.bind(this);\\n    }\\n    \\n    defineCommands() {\\n        // General navigation commands\\n        this.addCommand('general', [\\n            'go home', 'home', 'homepage'\\n        ], () => {\\n            window.location.href = '/';\\n            this.announce('Going to homepage');\\n        });\\n        \\n        this.addCommand('general', [\\n            'go to dashboard', 'dashboard', 'my dashboard'\\n        ], () => {\\n            const dashboardLink = document.querySelector('a[href*=\\\"dashboard\\\"]');\\n            if (dashboardLink) {\\n                dashboardLink.click();\\n                this.announce('Opening dashboard');\\n            } else {\\n                this.announce('Dashboard not found');\\n            }\\n        });\\n        \\n        this.addCommand('general', [\\n            'help', 'show help', 'voice help', 'commands'\\n        ], () => {\\n            this.showVoiceHelp();\\n        });\\n        \\n        this.addCommand('general', [\\n            'stop listening', 'stop voice', 'turn off voice'\\n        ], () => {\\n            this.stopListening();\\n            this.announce('Voice commands disabled');\\n        });\\n        \\n        this.addCommand('general', [\\n            'read page', 'read content', 'speak page'\\n        ], () => {\\n            this.readPageContent();\\n        });\\n        \\n        // Quiz-specific commands\\n        this.addCommand('quiz', [\\n            'submit answer', 'submit', 'next question', 'continue'\\n        ], () => {\\n            this.submitCurrentAnswer();\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'previous question', 'go back', 'back'\\n        ], () => {\\n            this.goToPreviousQuestion();\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'select option one', 'choose one', 'option a', 'first option'\\n        ], () => {\\n            this.selectQuizOption(0);\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'select option two', 'choose two', 'option b', 'second option'\\n        ], () => {\\n            this.selectQuizOption(1);\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'select option three', 'choose three', 'option c', 'third option'\\n        ], () => {\\n            this.selectQuizOption(2);\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'select option four', 'choose four', 'option d', 'fourth option'\\n        ], () => {\\n            this.selectQuizOption(3);\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'read question', 'repeat question', 'what is the question'\\n        ], () => {\\n            this.readCurrentQuestion();\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'read options', 'list options', 'what are the options'\\n        ], () => {\\n            this.readQuizOptions();\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'finish quiz', 'submit quiz', 'end quiz'\\n        ], () => {\\n            this.finishQuiz();\\n        });\\n        \\n        this.addCommand('quiz', [\\n            'time left', 'how much time', 'check timer'\\n        ], () => {\\n            this.announceTimeLeft();\\n        });\\n        \\n        // Form commands\\n        this.addCommand('form', [\\n            'submit form', 'send form', 'save form'\\n        ], () => {\\n            this.submitCurrentForm();\\n        });\\n        \\n        this.addCommand('form', [\\n            'clear form', 'reset form', 'clear all'\\n        ], () => {\\n            this.clearCurrentForm();\\n        });\\n        \\n        // Accessibility commands\\n        this.addCommand('general', [\\n            'increase text size', 'bigger text', 'zoom in'\\n        ], () => {\\n            this.adjustTextSize(1.1);\\n        });\\n        \\n        this.addCommand('general', [\\n            'decrease text size', 'smaller text', 'zoom out'\\n        ], () => {\\n            this.adjustTextSize(0.9);\\n        });\\n        \\n        this.addCommand('general', [\\n            'toggle theme', 'switch theme', 'dark mode', 'light mode'\\n        ], () => {\\n            if (window.themeManager) {\\n                const currentTheme = window.themeManager.getCurrentTheme();\\n                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\\n                window.themeManager.setTheme(newTheme);\\n                this.announce(`Switched to ${newTheme} theme`);\\n            }\\n        });\\n        \\n        // Navigation commands\\n        this.addCommand('general', [\\n            'scroll up', 'scroll to top'\\n        ], () => {\\n            window.scrollTo({ top: 0, behavior: 'smooth' });\\n            this.announce('Scrolled to top');\\n        });\\n        \\n        this.addCommand('general', [\\n            'scroll down', 'scroll to bottom'\\n        ], () => {\\n            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });\\n            this.announce('Scrolled to bottom');\\n        });\\n    }\\n    \\n    addCommand(context, phrases, action) {\\n        if (!this.commands.has(context)) {\\n            this.commands.set(context, new Map());\\n        }\\n        \\n        const contextCommands = this.commands.get(context);\\n        phrases.forEach(phrase => {\\n            contextCommands.set(phrase.toLowerCase(), action);\\n        });\\n    }\\n    \\n    setupVoiceIndicator() {\\n        // Create voice activation button\\n        const voiceButton = document.createElement('button');\\n        voiceButton.id = 'voice-activation-btn';\\n        voiceButton.className = 'voice-activation-btn';\\n        voiceButton.setAttribute('aria-label', 'Activate voice commands');\\n        voiceButton.innerHTML = `\\n            <i class=\\\"fas fa-microphone\\\" id=\\\"voice-icon\\\"></i>\\n            <span class=\\\"voice-status\\\" id=\\\"voice-status\\\">Click to activate</span>\\n        `;\\n        \\n        // Add styles\\n        const styles = document.createElement('style');\\n        styles.textContent = `\\n            .voice-activation-btn {\\n                position: fixed;\\n                bottom: 20px;\\n                right: 20px;\\n                background: var(--btn-primary-bg);\\n                color: white;\\n                border: none;\\n                border-radius: 50px;\\n                padding: 12px 20px;\\n                cursor: pointer;\\n                box-shadow: 0 4px 12px var(--shadow-color);\\n                z-index: 1055;\\n                transition: all 0.3s ease;\\n                font-size: 0.9rem;\\n                display: flex;\\n                align-items: center;\\n                gap: 8px;\\n                min-width: 120px;\\n            }\\n            \\n            .voice-activation-btn:hover {\\n                transform: translateY(-2px);\\n                box-shadow: 0 6px 16px var(--shadow-hover);\\n            }\\n            \\n            .voice-activation-btn.listening {\\n                background: var(--btn-danger-bg);\\n                animation: pulse-listening 1.5s infinite;\\n            }\\n            \\n            .voice-activation-btn.processing {\\n                background: var(--btn-warning-bg);\\n            }\\n            \\n            .voice-activation-btn:disabled {\\n                background: var(--btn-secondary-bg);\\n                cursor: not-allowed;\\n                opacity: 0.6;\\n            }\\n            \\n            @keyframes pulse-listening {\\n                0% { transform: scale(1); }\\n                50% { transform: scale(1.05); }\\n                100% { transform: scale(1); }\\n            }\\n            \\n            .voice-status {\\n                font-size: 0.8rem;\\n                white-space: nowrap;\\n            }\\n            \\n            @media (max-width: 768px) {\\n                .voice-activation-btn {\\n                    bottom: 80px;\\n                    right: 10px;\\n                    padding: 10px 16px;\\n                    min-width: 100px;\\n                }\\n                \\n                .voice-status {\\n                    display: none;\\n                }\\n            }\\n        `;\\n        \\n        document.head.appendChild(styles);\\n        document.body.appendChild(voiceButton);\\n        \\n        // Add click handler\\n        voiceButton.addEventListener('click', () => {\\n            if (this.isListening) {\\n                this.stopListening();\\n            } else {\\n                this.startListening();\\n            }\\n        });\\n        \\n        this.voiceIndicator = voiceButton;\\n    }\\n    \\n    setupKeyboardShortcuts() {\\n        document.addEventListener('keydown', (e) => {\\n            // Ctrl + Shift + V: Toggle voice commands\\n            if (e.ctrlKey && e.shiftKey && e.key === 'V') {\\n                e.preventDefault();\\n                if (this.isListening) {\\n                    this.stopListening();\\n                } else {\\n                    this.startListening();\\n                }\\n            }\\n            \\n            // Escape: Stop listening\\n            if (e.key === 'Escape' && this.isListening) {\\n                this.stopListening();\\n            }\\n        });\\n    }\\n    \\n    setupContextDetection() {\\n        // Detect page context changes\\n        const observer = new MutationObserver(() => {\\n            this.updateContext();\\n        });\\n        \\n        observer.observe(document.body, {\\n            childList: true,\\n            subtree: true\\n        });\\n        \\n        // Initial context detection\\n        this.updateContext();\\n    }\\n    \\n    updateContext() {\\n        if (document.querySelector('.quiz-container, .quiz-form')) {\\n            this.currentContext = 'quiz';\\n        } else if (document.querySelector('form')) {\\n            this.currentContext = 'form';\\n        } else {\\n            this.currentContext = 'general';\\n        }\\n        \\n        console.log('? Voice context updated:', this.currentContext);\\n    }\\n    \\n    startListening() {\\n        if (!this.isSupported || this.isListening) return;\\n        \\n        try {\\n            this.recognition.start();\\n            console.log('? Voice recognition started');\\n        } catch (error) {\\n            console.error('? Failed to start voice recognition:', error);\\n            this.announce('Failed to start voice recognition');\\n        }\\n    }\\n    \\n    stopListening() {\\n        if (!this.isSupported || !this.isListening) return;\\n        \\n        try {\\n            this.recognition.stop();\\n            console.log('? Voice recognition stopped');\\n        } catch (error) {\\n            console.error('? Failed to stop voice recognition:', error);\\n        }\\n    }\\n    \\n    handleRecognitionStart() {\\n        this.isListening = true;\\n        this.updateVoiceIndicator('listening');\\n        this.announce('Listening for voice command');\\n    }\\n    \\n    handleRecognitionResult(event) {\\n        const results = Array.from(event.results[0]);\\n        const bestResult = results.reduce((best, current) => \\n            current.confidence > best.confidence ? current : best\\n        );\\n        \\n        if (bestResult.confidence >= this.confidenceThreshold) {\\n            const command = bestResult.transcript.toLowerCase().trim();\\n            console.log('? Voice command recognized:', command, `(${Math.round(bestResult.confidence * 100)}%)`);\\n            \\n            this.executeCommand(command);\\n        } else {\\n            console.log('? Voice command unclear:', bestResult.transcript, `(${Math.round(bestResult.confidence * 100)}%)`);\\n            this.announce('Command not recognized. Please try again.');\\n        }\\n    }\\n    \\n    handleRecognitionError(event) {\\n        console.error('? Voice recognition error:', event.error);\\n        \\n        let errorMessage = 'Voice recognition error';\\n        switch (event.error) {\\n            case 'no-speech':\\n                errorMessage = 'No speech detected';\\n                break;\\n            case 'audio-capture':\\n                errorMessage = 'Microphone not available';\\n                break;\\n            case 'not-allowed':\\n                errorMessage = 'Microphone permission denied';\\n                break;\\n            case 'network':\\n                errorMessage = 'Network error';\\n                break;\\n        }\\n        \\n        this.announce(errorMessage);\\n        this.updateVoiceIndicator('error');\\n    }\\n    \\n    handleRecognitionEnd() {\\n        this.isListening = false;\\n        this.updateVoiceIndicator('idle');\\n    }\\n    \\n    executeCommand(command) {\\n        this.updateVoiceIndicator('processing');\\n        \\n        // Store command in history\\n        this.commandHistory.push({\\n            command,\\n            context: this.currentContext,\\n            timestamp: new Date()\\n        });\\n        \\n        // Keep only last 20 commands\\n        if (this.commandHistory.length > 20) {\\n            this.commandHistory.shift();\\n        }\\n        \\n        // Try to find and execute command\\n        let executed = false;\\n        \\n        // Check context-specific commands first\\n        if (this.commands.has(this.currentContext)) {\\n            const contextCommands = this.commands.get(this.currentContext);\\n            for (const [phrase, action] of contextCommands) {\\n                if (command.includes(phrase)) {\\n                    action();\\n                    this.lastCommand = phrase;\\n                    executed = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Fall back to general commands\\n        if (!executed && this.commands.has('general')) {\\n            const generalCommands = this.commands.get('general');\\n            for (const [phrase, action] of generalCommands) {\\n                if (command.includes(phrase)) {\\n                    action();\\n                    this.lastCommand = phrase;\\n                    executed = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (!executed) {\\n            this.announce(`Command \\\"${command}\\\" not recognized. Say \\\"help\\\" for available commands.`);\\n        }\\n        \\n        setTimeout(() => {\\n            this.updateVoiceIndicator('idle');\\n        }, 1000);\\n    }\\n    \\n    updateVoiceIndicator(state) {\\n        if (!this.voiceIndicator) return;\\n        \\n        const icon = this.voiceIndicator.querySelector('#voice-icon');\\n        const status = this.voiceIndicator.querySelector('#voice-status');\\n        \\n        // Remove all state classes\\n        this.voiceIndicator.classList.remove('listening', 'processing', 'error');\\n        \\n        switch (state) {\\n            case 'listening':\\n                this.voiceIndicator.classList.add('listening');\\n                icon.className = 'fas fa-microphone';\\n                status.textContent = 'Listening...';\\n                this.voiceIndicator.setAttribute('aria-label', 'Voice commands active - listening');\\n                break;\\n                \\n            case 'processing':\\n                this.voiceIndicator.classList.add('processing');\\n                icon.className = 'fas fa-cog fa-spin';\\n                status.textContent = 'Processing...';\\n                this.voiceIndicator.setAttribute('aria-label', 'Processing voice command');\\n                break;\\n                \\n            case 'error':\\n                this.voiceIndicator.classList.add('error');\\n                icon.className = 'fas fa-exclamation-triangle';\\n                status.textContent = 'Error';\\n                this.voiceIndicator.setAttribute('aria-label', 'Voice command error');\\n                break;\\n                \\n            case 'idle':\\n            default:\\n                icon.className = 'fas fa-microphone';\\n                status.textContent = 'Click to activate';\\n                this.voiceIndicator.setAttribute('aria-label', 'Click to activate voice commands');\\n                break;\\n        }\\n    }\\n    \\n    // Quiz-specific command implementations\\n    submitCurrentAnswer() {\\n        const submitButton = document.querySelector('.quiz-submit-btn, button[type=\\\"submit\\\"], .btn-primary');\\n        if (submitButton) {\\n            submitButton.click();\\n            this.announce('Answer submitted');\\n        } else {\\n            this.announce('No submit button found');\\n        }\\n    }\\n    \\n    goToPreviousQuestion() {\\n        const prevButton = document.querySelector('.prev-question, .btn-secondary');\\n        if (prevButton) {\\n            prevButton.click();\\n            this.announce('Going to previous question');\\n        } else {\\n            this.announce('No previous question available');\\n        }\\n    }\\n    \\n    selectQuizOption(index) {\\n        const options = document.querySelectorAll('.quiz-option input, input[type=\\\"radio\\\"], input[type=\\\"checkbox\\\"]');\\n        if (options[index]) {\\n            options[index].click();\\n            const label = options[index].closest('label') || \\n                         document.querySelector(`label[for=\\\"${options[index].id}\\\"]`);\\n            const optionText = label ? label.textContent.trim() : `Option ${index + 1}`;\\n            this.announce(`Selected: ${optionText}`);\\n        } else {\\n            this.announce(`Option ${index + 1} not available`);\\n        }\\n    }\\n    \\n    readCurrentQuestion() {\\n        const question = document.querySelector('.question-text, .quiz-question h3, .question-content');\\n        if (question) {\\n            const questionText = question.textContent.trim();\\n            this.speak(`Question: ${questionText}`);\\n        } else {\\n            this.announce('No question found');\\n        }\\n    }\\n    \\n    readQuizOptions() {\\n        const options = document.querySelectorAll('.quiz-option, .option-text');\\n        if (options.length > 0) {\\n            let optionsText = 'Available options: ';\\n            options.forEach((option, index) => {\\n                const text = option.textContent.trim();\\n                optionsText += `Option ${index + 1}: ${text}. `;\\n            });\\n            this.speak(optionsText);\\n        } else {\\n            this.announce('No options found');\\n        }\\n    }\\n    \\n    finishQuiz() {\\n        const finishButton = document.querySelector('.finish-quiz, .submit-quiz, button[value=\\\"finish\\\"]');\\n        if (finishButton) {\\n            finishButton.click();\\n            this.announce('Quiz finished');\\n        } else {\\n            this.announce('Cannot finish quiz');\\n        }\\n    }\\n    \\n    announceTimeLeft() {\\n        const timer = document.querySelector('.quiz-timer, .time-left, #timer');\\n        if (timer) {\\n            const timeText = timer.textContent.trim();\\n            this.announce(`Time remaining: ${timeText}`);\\n        } else {\\n            this.announce('Timer not found');\\n        }\\n    }\\n    \\n    // Form command implementations\\n    submitCurrentForm() {\\n        const form = document.querySelector('form');\\n        if (form) {\\n            form.submit();\\n            this.announce('Form submitted');\\n        } else {\\n            this.announce('No form found');\\n        }\\n    }\\n    \\n    clearCurrentForm() {\\n        const form = document.querySelector('form');\\n        if (form) {\\n            form.reset();\\n            this.announce('Form cleared');\\n        } else {\\n            this.announce('No form found');\\n        }\\n    }\\n    \\n    // Accessibility implementations\\n    adjustTextSize(factor) {\\n        const currentSize = parseFloat(getComputedStyle(document.documentElement).fontSize);\\n        const newSize = currentSize * factor;\\n        document.documentElement.style.fontSize = `${newSize}px`;\\n        this.announce(`Text size adjusted to ${Math.round(newSize)}px`);\\n    }\\n    \\n    readPageContent() {\\n        const mainContent = document.querySelector('main, .main-content, .content, #main-content');\\n        if (mainContent) {\\n            const text = this.extractReadableText(mainContent);\\n            this.speak(text.substring(0, 500) + (text.length > 500 ? '... Content continues' : ''));\\n        } else {\\n            this.announce('No main content found');\\n        }\\n    }\\n    \\n    extractReadableText(element) {\\n        // Get text content while excluding non-readable elements\\n        const clone = element.cloneNode(true);\\n        const excludeSelectors = ['script', 'style', '.sr-only', '.d-none', '[aria-hidden=\\\"true\\\"]'];\\n        \\n        excludeSelectors.forEach(selector => {\\n            const elements = clone.querySelectorAll(selector);\\n            elements.forEach(el => el.remove());\\n        });\\n        \\n        return clone.textContent.replace(/\\\\s+/g, ' ').trim();\\n    }\\n    \\n    showVoiceHelp() {\\n        const helpCommands = {\\n            'General': [\\n                'Go home - Navigate to homepage',\\n                'Dashboard - Open dashboard',\\n                'Help - Show this help',\\n                'Stop listening - Disable voice commands',\\n                'Read page - Read page content aloud',\\n                'Toggle theme - Switch between dark and light theme',\\n                'Scroll up/down - Navigate page'\\n            ],\\n            'Quiz': [\\n                'Submit answer - Submit current answer',\\n                'Next question - Continue to next question',\\n                'Previous question - Go back',\\n                'Select option [1-4] - Choose quiz option',\\n                'Read question - Read current question aloud',\\n                'Read options - List all available options',\\n                'Time left - Check remaining time',\\n                'Finish quiz - Complete the quiz'\\n            ]\\n        };\\n        \\n        let helpText = 'Available voice commands: ';\\n        \\n        if (this.currentContext === 'quiz' && helpCommands.Quiz) {\\n            helpText += 'Quiz commands: ' + helpCommands.Quiz.join('. ') + '. ';\\n        }\\n        \\n        helpText += 'General commands: ' + helpCommands.General.join('. ');\\n        \\n        this.speak(helpText);\\n    }\\n    \\n    // Text-to-speech helpers\\n    speak(text) {\\n        if ('speechSynthesis' in window) {\\n            speechSynthesis.cancel(); // Stop any ongoing speech\\n            \\n            const utterance = new SpeechSynthesisUtterance(text);\\n            utterance.rate = 0.9;\\n            utterance.pitch = 1;\\n            utterance.volume = 0.8;\\n            \\n            speechSynthesis.speak(utterance);\\n        } else {\\n            this.announce(text);\\n        }\\n    }\\n    \\n    announce(message) {\\n        console.log('? Voice announcement:', message);\\n        \\n        if (window.accessibilityManager) {\\n            window.accessibilityManager.makeAnnouncement(message, 'assertive');\\n        }\\n        \\n        // Visual feedback\\n        this.showTemporaryMessage(message);\\n    }\\n    \\n    showTemporaryMessage(message) {\\n        const messageDiv = document.createElement('div');\\n        messageDiv.className = 'voice-message';\\n        messageDiv.textContent = message;\\n        \\n        const styles = `\\n            position: fixed;\\n            bottom: 80px;\\n            right: 20px;\\n            background: var(--card-bg);\\n            color: var(--text-primary);\\n            padding: 8px 12px;\\n            border-radius: 4px;\\n            box-shadow: 0 2px 8px var(--shadow-color);\\n            z-index: 1060;\\n            font-size: 0.875rem;\\n            max-width: 300px;\\n            border: 1px solid var(--border-color);\\n        `;\\n        \\n        messageDiv.style.cssText = styles;\\n        document.body.appendChild(messageDiv);\\n        \\n        setTimeout(() => {\\n            if (messageDiv.parentNode) {\\n                messageDiv.parentNode.removeChild(messageDiv);\\n            }\\n        }, 3000);\\n    }\\n    \\n    // Public API\\n    isVoiceSupported() {\\n        return this.isSupported;\\n    }\\n    \\n    getCurrentContext() {\\n        return this.currentContext;\\n    }\\n    \\n    getCommandHistory() {\\n        return this.commandHistory;\\n    }\\n    \\n    addCustomCommand(context, phrases, action) {\\n        this.addCommand(context, phrases, action);\\n    }\\n    \\n    toggleListening() {\\n        if (this.isListening) {\\n            this.stopListening();\\n        } else {\\n            this.startListening();\\n        }\\n    }\\n}\\n\\n// Auto-initialize voice commands manager\\ndocument.addEventListener('DOMContentLoaded', () => {\\n    window.voiceCommands = new VoiceCommandsManager();\\n});\\n\\n// Export for use in other modules\\nif (typeof module !== 'undefined' && module.exports) {\\n    module.exports = VoiceCommandsManager;\\n}","size_bytes":27069},"sw.js":{"content":"/**\n * BigBossizzz Root Service Worker\n * Handles caching and offline functionality for the entire application\n */\n\nconst CACHE_NAME = 'bigbossizzz-offline-v1';\nconst STATIC_CACHE = 'bigbossizzz-static-v1';\nconst DYNAMIC_CACHE = 'bigbossizzz-dynamic-v1';\n\n// Resources to cache for offline use\nconst STATIC_ASSETS = [\n    '/',\n    '/static/css/theme-system.css',\n    '/static/css/accessibility-features.css',\n    '/static/css/mobile-enhancements.css',\n    '/static/js/theme-manager.js',\n    '/static/js/accessibility-manager.js',\n    '/static/js/offline-manager.js',\n    '/static/js/mobile-app.js',\n    '/static/js/voice-commands.js'\n];\n\n// Install event - cache static assets\nself.addEventListener('install', event => {\n    console.log('üîß Root Service Worker installing...');\n    \n    event.waitUntil(\n        caches.open(STATIC_CACHE)\n            .then(cache => {\n                console.log('üì¶ Caching static assets');\n                return cache.addAll(STATIC_ASSETS.filter(url => !url.includes('cdn')));\n            })\n            .then(() => {\n                console.log('‚úÖ Static assets cached successfully');\n                return self.skipWaiting();\n            })\n            .catch(error => {\n                console.error('‚ùå Failed to cache static assets:', error);\n            })\n    );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', event => {\n    console.log('üöÄ Root Service Worker activating...');\n    \n    event.waitUntil(\n        caches.keys()\n            .then(cacheNames => {\n                return Promise.all(\n                    cacheNames.map(cacheName => {\n                        if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {\n                            console.log('üóëÔ∏è Deleting old cache:', cacheName);\n                            return caches.delete(cacheName);\n                        }\n                    })\n                );\n            })\n            .then(() => {\n                console.log('‚úÖ Root Service Worker activated');\n                return self.clients.claim();\n            })\n    );\n});\n\n// Fetch event - handle requests with secure caching strategy\nself.addEventListener('fetch', event => {\n    const { request } = event;\n    const url = new URL(request.url);\n    \n    // Skip non-GET requests and chrome-extension requests\n    if (request.method !== 'GET' || url.protocol === 'chrome-extension:') {\n        return;\n    }\n    \n    // Skip authenticated API routes and quiz content for security\n    if (url.pathname.startsWith('/api/') && \n        !url.pathname.includes('/connectivity-check')) {\n        return;\n    }\n    \n    // Handle different types of requests\n    if (isStaticAsset(request)) {\n        event.respondWith(handleStaticAsset(request));\n    } else if (isPublicRoute(request)) {\n        event.respondWith(handlePublicRoute(request));\n    }\n});\n\n// Check if request is for static assets\nfunction isStaticAsset(request) {\n    const url = new URL(request.url);\n    return url.pathname.startsWith('/static/') && \n           !url.pathname.includes('.js.map') &&\n           !url.pathname.includes('.css.map');\n}\n\n// Check if request is for public routes\nfunction isPublicRoute(request) {\n    const url = new URL(request.url);\n    const publicRoutes = ['/', '/login', '/register', '/api/connectivity-check'];\n    return publicRoutes.includes(url.pathname);\n}\n\n// Handle static assets - Cache First strategy\nasync function handleStaticAsset(request) {\n    try {\n        const cache = await caches.open(STATIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        \n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        const networkResponse = await fetch(request);\n        if (networkResponse.ok && !networkResponse.redirected) {\n            cache.put(request, networkResponse.clone());\n        }\n        return networkResponse;\n        \n    } catch (error) {\n        console.error('‚ùå Failed to handle static asset:', error);\n        \n        // Return cached version if available\n        const cache = await caches.open(STATIC_CACHE);\n        const cachedResponse = await cache.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        \n        // Return minimal offline response\n        return new Response('Offline - Asset not available', {\n            status: 503,\n            statusText: 'Service Unavailable'\n        });\n    }\n}\n\n// Handle public routes - Network First with limited caching\nasync function handlePublicRoute(request) {\n    try {\n        const networkResponse = await fetch(request);\n        return networkResponse;\n        \n    } catch (error) {\n        console.error('‚ùå Network error for public route:', error);\n        \n        // Only cache non-sensitive public pages\n        const url = new URL(request.url);\n        if (url.pathname === '/' || url.pathname === '/login') {\n            const cache = await caches.open(DYNAMIC_CACHE);\n            const cachedResponse = await cache.match(request);\n            if (cachedResponse) {\n                return cachedResponse;\n            }\n        }\n        \n        // Return offline page\n        return getOfflinePage();\n    }\n}\n\n// Generate minimal offline page\nfunction getOfflinePage() {\n    const html = `\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Offline - BigBossizzz</title>\n        <style>\n            body { font-family: system-ui, sans-serif; margin: 0; padding: 20px; text-align: center; }\n            .container { max-width: 400px; margin: 100px auto; }\n        </style>\n    </head>\n    <body>\n        <div class=\"container\">\n            <h1>üåê You're Offline</h1>\n            <p>Please check your connection and try again.</p>\n            <button onclick=\"location.reload()\">Try Again</button>\n        </div>\n        <script>\n            window.addEventListener('online', () => location.reload());\n        </script>\n    </body>\n    </html>\n    `;\n    \n    return new Response(html, {\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\nconsole.log('üîß BigBossizzz Root Service Worker loaded');","size_bytes":6259},"rbac_decorators.py":{"content":"\"\"\"\nBigBossizzz RBAC Decorators\nAdvanced permission-based decorators for route protection and access control\n\"\"\"\n\nfrom functools import wraps\nfrom flask import flash, redirect, url_for, request, jsonify, abort\nfrom flask_login import current_user\nimport logging\n\ndef require_permission(permission_name, redirect_url=None, api_mode=False):\n    \"\"\"\n    Decorator to require a specific permission for accessing a route\n    \n    Args:\n        permission_name (str): The permission name to check\n        redirect_url (str, optional): URL to redirect to if permission denied\n        api_mode (bool): If True, returns JSON error instead of redirect\n    \"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                if api_mode:\n                    return jsonify({'error': 'Authentication required'}), 401\n                flash('Please log in to access this page.', 'error')\n                return redirect(url_for('login'))\n            \n            if not current_user.has_permission(permission_name):\n                # Log unauthorized access attempt\n                logging.warning(f\"User {current_user.username} attempted to access {request.endpoint} without permission: {permission_name}\")\n                \n                if api_mode:\n                    return jsonify({\n                        'error': 'Permission denied',\n                        'required_permission': permission_name\n                    }), 403\n                \n                flash(f'Access denied. You need the \"{permission_name}\" permission to access this resource.', 'error')\n                \n                if redirect_url:\n                    return redirect(redirect_url)\n                else:\n                    # Redirect based on user role\n                    if current_user.is_admin():\n                        return redirect(url_for('admin_dashboard'))\n                    elif current_user.is_host():\n                        return redirect(url_for('host_dashboard'))\n                    else:\n                        return redirect(url_for('participant_dashboard'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\ndef require_any_permission(permission_names, redirect_url=None, api_mode=False):\n    \"\"\"\n    Decorator to require any of the specified permissions for accessing a route\n    \n    Args:\n        permission_names (list): List of permission names to check\n        redirect_url (str, optional): URL to redirect to if permission denied\n        api_mode (bool): If True, returns JSON error instead of redirect\n    \"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                if api_mode:\n                    return jsonify({'error': 'Authentication required'}), 401\n                flash('Please log in to access this page.', 'error')\n                return redirect(url_for('login'))\n            \n            if not current_user.has_any_permission(permission_names):\n                logging.warning(f\"User {current_user.username} attempted to access {request.endpoint} without any of permissions: {permission_names}\")\n                \n                if api_mode:\n                    return jsonify({\n                        'error': 'Permission denied',\n                        'required_permissions': permission_names\n                    }), 403\n                \n                flash(f'Access denied. You need one of these permissions: {\", \".join(permission_names)}', 'error')\n                \n                if redirect_url:\n                    return redirect(redirect_url)\n                else:\n                    return redirect(url_for('dashboard'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\ndef require_all_permissions(permission_names, redirect_url=None, api_mode=False):\n    \"\"\"\n    Decorator to require all specified permissions for accessing a route\n    \n    Args:\n        permission_names (list): List of permission names to check\n        redirect_url (str, optional): URL to redirect to if permission denied\n        api_mode (bool): If True, returns JSON error instead of redirect\n    \"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                if api_mode:\n                    return jsonify({'error': 'Authentication required'}), 401\n                flash('Please log in to access this page.', 'error')\n                return redirect(url_for('login'))\n            \n            if not current_user.has_all_permissions(permission_names):\n                logging.warning(f\"User {current_user.username} attempted to access {request.endpoint} without all permissions: {permission_names}\")\n                \n                if api_mode:\n                    return jsonify({\n                        'error': 'Permission denied',\n                        'required_permissions': permission_names\n                    }), 403\n                \n                flash(f'Access denied. You need all of these permissions: {\", \".join(permission_names)}', 'error')\n                \n                if redirect_url:\n                    return redirect(redirect_url)\n                else:\n                    return redirect(url_for('dashboard'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\ndef require_role(role_name, redirect_url=None, api_mode=False):\n    \"\"\"\n    Decorator to require a specific role for accessing a route\n    \n    Args:\n        role_name (str): The role name to check\n        redirect_url (str, optional): URL to redirect to if role not found\n        api_mode (bool): If True, returns JSON error instead of redirect\n    \"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                if api_mode:\n                    return jsonify({'error': 'Authentication required'}), 401\n                flash('Please log in to access this page.', 'error')\n                return redirect(url_for('login'))\n            \n            if not current_user.has_role(role_name):\n                logging.warning(f\"User {current_user.username} attempted to access {request.endpoint} without role: {role_name}\")\n                \n                if api_mode:\n                    return jsonify({\n                        'error': 'Role required',\n                        'required_role': role_name\n                    }), 403\n                \n                flash(f'Access denied. You need the \"{role_name}\" role to access this resource.', 'error')\n                \n                if redirect_url:\n                    return redirect(redirect_url)\n                else:\n                    return redirect(url_for('dashboard'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\ndef require_any_role(role_names, redirect_url=None, api_mode=False):\n    \"\"\"\n    Decorator to require any of the specified roles for accessing a route\n    \n    Args:\n        role_names (list): List of role names to check\n        redirect_url (str, optional): URL to redirect to if no role found\n        api_mode (bool): If True, returns JSON error instead of redirect\n    \"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                if api_mode:\n                    return jsonify({'error': 'Authentication required'}), 401\n                flash('Please log in to access this page.', 'error')\n                return redirect(url_for('login'))\n            \n            user_roles = current_user.get_roles()\n            if not any(role in user_roles for role in role_names):\n                logging.warning(f\"User {current_user.username} attempted to access {request.endpoint} without any of roles: {role_names}\")\n                \n                if api_mode:\n                    return jsonify({\n                        'error': 'Role required',\n                        'required_roles': role_names\n                    }), 403\n                \n                flash(f'Access denied. You need one of these roles: {\", \".join(role_names)}', 'error')\n                \n                if redirect_url:\n                    return redirect(redirect_url)\n                else:\n                    return redirect(url_for('dashboard'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\ndef admin_required(redirect_url=None, api_mode=False):\n    \"\"\"\n    Convenience decorator for admin-only routes\n    \"\"\"\n    return require_role('admin', redirect_url, api_mode)\n\ndef host_required(redirect_url=None, api_mode=False):\n    \"\"\"\n    Convenience decorator for host-only routes\n    \"\"\"\n    return require_role('host', redirect_url, api_mode)\n\ndef host_or_admin_required(redirect_url=None, api_mode=False):\n    \"\"\"\n    Convenience decorator for host or admin routes\n    \"\"\"\n    return require_any_role(['host', 'admin'], redirect_url, api_mode)\n\n# Permission checking functions (not decorators)\ndef check_permission(user, permission_name):\n    \"\"\"Check if a user has a specific permission\"\"\"\n    if not user or not user.is_authenticated:\n        return False\n    return user.has_permission(permission_name)\n\ndef check_any_permission(user, permission_names):\n    \"\"\"Check if a user has any of the specified permissions\"\"\"\n    if not user or not user.is_authenticated:\n        return False\n    return user.has_any_permission(permission_names)\n\ndef check_all_permissions(user, permission_names):\n    \"\"\"Check if a user has all specified permissions\"\"\"\n    if not user or not user.is_authenticated:\n        return False\n    return user.has_all_permissions(permission_names)\n\ndef get_user_permissions(user):\n    \"\"\"Get all permissions for a user\"\"\"\n    if not user or not user.is_authenticated:\n        return []\n    return user.get_all_permissions()\n\ndef get_user_roles(user):\n    \"\"\"Get all roles for a user\"\"\"\n    if not user or not user.is_authenticated:\n        return []\n    return user.get_roles()\n\n# Context processor for templates\ndef permission_context_processor():\n    \"\"\"Add permission checking functions to template context\"\"\"\n    return {\n        'check_permission': lambda perm: check_permission(current_user, perm),\n        'check_any_permission': lambda perms: check_any_permission(current_user, perms),\n        'check_all_permissions': lambda perms: check_all_permissions(current_user, perms),\n        'user_permissions': get_user_permissions(current_user) if current_user.is_authenticated else [],\n        'user_roles': get_user_roles(current_user) if current_user.is_authenticated else []\n    }","size_bytes":10953},"rbac_service.py":{"content":"\"\"\"\nBigBossizzz RBAC Service\nEnterprise role and permission management service with comprehensive utilities\n\"\"\"\n\nfrom flask import current_app, request\nfrom app import db\nfrom models import User, Role, Permission, UserRole, RolePermission, RoleAuditLog\nfrom datetime import datetime\nimport json\nimport logging\n\nclass RBACService:\n    \"\"\"\n    Comprehensive RBAC management service providing all role and permission operations\n    \"\"\"\n    \n    @staticmethod\n    def initialize_default_permissions():\n        \"\"\"Initialize default permissions for the system\"\"\"\n        default_permissions = [\n            # System Management\n            {'name': 'manage_system', 'display_name': 'Manage System', 'description': 'Full system administration access', 'category': 'system'},\n            {'name': 'view_system_logs', 'display_name': 'View System Logs', 'description': 'Access to system logs and monitoring', 'category': 'system'},\n            {'name': 'manage_integrations', 'display_name': 'Manage Integrations', 'description': 'Configure LTI and other integrations', 'category': 'system'},\n            \n            # User Management\n            {'name': 'manage_users', 'display_name': 'Manage Users', 'description': 'Create, edit, and delete user accounts', 'category': 'user'},\n            {'name': 'view_users', 'display_name': 'View Users', 'description': 'View user accounts and profiles', 'category': 'user'},\n            {'name': 'assign_roles', 'display_name': 'Assign Roles', 'description': 'Assign and remove user roles', 'category': 'user'},\n            {'name': 'reset_passwords', 'display_name': 'Reset Passwords', 'description': 'Reset user passwords', 'category': 'user'},\n            \n            # Role and Permission Management\n            {'name': 'manage_roles', 'display_name': 'Manage Roles', 'description': 'Create, edit, and delete roles', 'category': 'rbac'},\n            {'name': 'manage_permissions', 'display_name': 'Manage Permissions', 'description': 'Create, edit, and delete permissions', 'category': 'rbac'},\n            {'name': 'view_role_assignments', 'display_name': 'View Role Assignments', 'description': 'View user role assignments', 'category': 'rbac'},\n            {'name': 'audit_rbac_changes', 'display_name': 'Audit RBAC Changes', 'description': 'View role and permission change logs', 'category': 'rbac'},\n            \n            # Quiz Management\n            {'name': 'create_quizzes', 'display_name': 'Create Quizzes', 'description': 'Create new quizzes and exams', 'category': 'quiz'},\n            {'name': 'edit_quizzes', 'display_name': 'Edit Quizzes', 'description': 'Edit existing quizzes', 'category': 'quiz'},\n            {'name': 'delete_quizzes', 'display_name': 'Delete Quizzes', 'description': 'Delete quizzes permanently', 'category': 'quiz'},\n            {'name': 'manage_quiz_settings', 'display_name': 'Manage Quiz Settings', 'description': 'Configure quiz proctoring and advanced settings', 'category': 'quiz'},\n            {'name': 'view_all_quizzes', 'display_name': 'View All Quizzes', 'description': 'Access to all quizzes in the system', 'category': 'quiz'},\n            {'name': 'duplicate_quizzes', 'display_name': 'Duplicate Quizzes', 'description': 'Create copies of existing quizzes', 'category': 'quiz'},\n            \n            # Quiz Taking\n            {'name': 'take_quizzes', 'display_name': 'Take Quizzes', 'description': 'Participate in quizzes and exams', 'category': 'quiz'},\n            {'name': 'view_own_results', 'display_name': 'View Own Results', 'description': 'View personal quiz results', 'category': 'quiz'},\n            {'name': 'retake_quizzes', 'display_name': 'Retake Quizzes', 'description': 'Retake quizzes when allowed', 'category': 'quiz'},\n            \n            # Proctoring\n            {'name': 'manage_proctoring', 'display_name': 'Manage Proctoring', 'description': 'Configure proctoring settings', 'category': 'proctoring'},\n            {'name': 'view_proctoring_events', 'display_name': 'View Proctoring Events', 'description': 'Monitor proctoring violations', 'category': 'proctoring'},\n            {'name': 'review_violations', 'display_name': 'Review Violations', 'description': 'Review and resolve proctoring violations', 'category': 'proctoring'},\n            \n            # Reporting and Analytics\n            {'name': 'view_reports', 'display_name': 'View Reports', 'description': 'Access quiz and user reports', 'category': 'reports'},\n            {'name': 'generate_advanced_reports', 'display_name': 'Generate Advanced Reports', 'description': 'Create custom and advanced reports', 'category': 'reports'},\n            {'name': 'export_data', 'display_name': 'Export Data', 'description': 'Export quiz data and reports', 'category': 'reports'},\n            {'name': 'view_analytics', 'display_name': 'View Analytics', 'description': 'Access system analytics and insights', 'category': 'reports'},\n            {'name': 'view_plagiarism_reports', 'display_name': 'View Plagiarism Reports', 'description': 'Access plagiarism detection results', 'category': 'reports'},\n            \n            # Communication\n            {'name': 'send_notifications', 'display_name': 'Send Notifications', 'description': 'Send notifications to users', 'category': 'communication'},\n            {'name': 'manage_announcements', 'display_name': 'Manage Announcements', 'description': 'Create and manage system announcements', 'category': 'communication'},\n        ]\n        \n        created_count = 0\n        for perm_data in default_permissions:\n            try:\n                if not Permission.query.filter_by(name=perm_data['name']).first():\n                    permission = Permission()\n                    permission.name = perm_data['name']\n                    permission.display_name = perm_data['display_name']\n                    permission.description = perm_data['description']\n                    permission.category = perm_data['category']\n                    permission.is_system_permission = True\n                    db.session.add(permission)\n                    created_count += 1\n                    logging.info(f\"Created permission: {perm_data['name']}\")\n            except Exception as e:\n                logging.error(f\"Failed to create permission {perm_data['name']}: {e}\")\n        \n        if created_count > 0:\n            try:\n                db.session.commit()\n                logging.info(f\"Initialized {created_count} default permissions\")\n            except Exception as e:\n                logging.error(f\"Failed to commit permissions: {e}\")\n                db.session.rollback()\n                created_count = 0\n        \n        return created_count\n    \n    @staticmethod\n    def initialize_default_roles():\n        \"\"\"Initialize default roles with appropriate permissions\"\"\"\n        default_roles = [\n            {\n                'name': 'admin',\n                'display_name': 'System Administrator',\n                'description': 'Full system access with all permissions',\n                'permissions': [\n                    'manage_system', 'view_system_logs', 'manage_integrations',\n                    'manage_users', 'view_users', 'assign_roles', 'reset_passwords',\n                    'manage_roles', 'manage_permissions', 'view_role_assignments', 'audit_rbac_changes',\n                    'create_quizzes', 'edit_quizzes', 'delete_quizzes', 'manage_quiz_settings', 'view_all_quizzes', 'duplicate_quizzes',\n                    'manage_proctoring', 'view_proctoring_events', 'review_violations',\n                    'view_reports', 'generate_advanced_reports', 'export_data', 'view_analytics', 'view_plagiarism_reports',\n                    'send_notifications', 'manage_announcements'\n                ]\n            },\n            {\n                'name': 'host',\n                'display_name': 'Quiz Host/Instructor',\n                'description': 'Can create and manage quizzes, view results',\n                'permissions': [\n                    'view_users',\n                    'create_quizzes', 'edit_quizzes', 'manage_quiz_settings', 'duplicate_quizzes',\n                    'view_proctoring_events', 'review_violations',\n                    'view_reports', 'export_data', 'view_analytics', 'view_plagiarism_reports',\n                    'send_notifications'\n                ]\n            },\n            {\n                'name': 'participant',\n                'display_name': 'Quiz Participant/Student',\n                'description': 'Can take quizzes and view own results',\n                'permissions': [\n                    'take_quizzes', 'view_own_results', 'retake_quizzes'\n                ]\n            },\n            {\n                'name': 'moderator',\n                'display_name': 'Quiz Moderator',\n                'description': 'Can assist with quiz management and monitoring',\n                'permissions': [\n                    'view_users',\n                    'view_all_quizzes', 'manage_quiz_settings',\n                    'view_proctoring_events', 'review_violations',\n                    'view_reports', 'view_analytics'\n                ]\n            },\n            {\n                'name': 'analyst',\n                'display_name': 'Data Analyst',\n                'description': 'Can access reports and analytics',\n                'permissions': [\n                    'view_reports', 'generate_advanced_reports', 'export_data', 'view_analytics', 'view_plagiarism_reports'\n                ]\n            }\n        ]\n        \n        created_count = 0\n        for role_data in default_roles:\n            existing_role = Role.query.filter_by(name=role_data['name']).first()\n            if not existing_role:\n                role = Role()\n                role.name = role_data['name']\n                role.display_name = role_data['display_name']\n                role.description = role_data['description']\n                role.is_system_role = True\n                db.session.add(role)\n                db.session.flush()  # Get the role ID\n                \n                # Add permissions to role\n                for perm_name in role_data['permissions']:\n                    permission = Permission.query.filter_by(name=perm_name).first()\n                    if permission:\n                        role_permission = RolePermission()\n                        role_permission.role_id = role.id\n                        role_permission.permission_id = permission.id\n                        db.session.add(role_permission)\n                \n                created_count += 1\n        \n        if created_count > 0:\n            db.session.commit()\n            logging.info(f\"Initialized {created_count} default roles\")\n        \n        return created_count\n    \n    @staticmethod\n    def create_role(name, display_name, description, permission_names=None, created_by_user_id=None):\n        \"\"\"Create a new role with optional permissions\"\"\"\n        if Role.query.filter_by(name=name).first():\n            raise ValueError(f\"Role '{name}' already exists\")\n        \n        role = Role()\n        role.name = name\n        role.display_name = display_name\n        role.description = description\n        role.created_by = created_by_user_id\n        db.session.add(role)\n        db.session.flush()\n        \n        # Add permissions if provided\n        if permission_names:\n            for perm_name in permission_names:\n                permission = Permission.query.filter_by(name=perm_name).first()\n                if permission:\n                    role_permission = RolePermission()\n                    role_permission.role_id = role.id\n                    role_permission.permission_id = permission.id\n                    role_permission.granted_by = created_by_user_id\n                    db.session.add(role_permission)\n        \n        # Create audit log\n        RBACService._create_audit_log(\n            action='create',\n            entity_type='role',\n            entity_id=role.id,\n            performed_by=created_by_user_id,\n            new_values=json.dumps({\n                'name': name,\n                'display_name': display_name,\n                'description': description,\n                'permissions': permission_names or []\n            })\n        )\n        \n        db.session.commit()\n        return role\n    \n    @staticmethod\n    def update_role(role_id, **kwargs):\n        \"\"\"Update an existing role\"\"\"\n        role = Role.query.get_or_404(role_id)\n        \n        if role.is_system_role and 'name' in kwargs:\n            raise ValueError(\"Cannot modify name of system role\")\n        \n        old_values = {\n            'name': role.name,\n            'display_name': role.display_name,\n            'description': role.description\n        }\n        \n        # Update role fields\n        for key, value in kwargs.items():\n            if hasattr(role, key) and key not in ['id', 'created_at', 'is_system_role']:\n                setattr(role, key, value)\n        \n        role.updated_at = datetime.utcnow()\n        \n        # Create audit log\n        RBACService._create_audit_log(\n            action='update',\n            entity_type='role',\n            entity_id=role.id,\n            performed_by=kwargs.get('updated_by'),\n            old_values=json.dumps(old_values),\n            new_values=json.dumps(kwargs)\n        )\n        \n        db.session.commit()\n        return role\n    \n    @staticmethod\n    def delete_role(role_id, performed_by_user_id=None):\n        \"\"\"Delete a role (if not system role)\"\"\"\n        role = Role.query.get_or_404(role_id)\n        \n        if role.is_system_role:\n            raise ValueError(\"Cannot delete system role\")\n        \n        old_values = {\n            'name': role.name,\n            'display_name': role.display_name,\n            'description': role.description,\n            'user_count': role.user_count,\n            'permission_count': role.permission_count\n        }\n        \n        # Create audit log before deletion\n        RBACService._create_audit_log(\n            action='delete',\n            entity_type='role',\n            entity_id=role.id,\n            performed_by=performed_by_user_id,\n            old_values=json.dumps(old_values)\n        )\n        \n        db.session.delete(role)\n        db.session.commit()\n        return True\n    \n    @staticmethod\n    def assign_role_to_user(user_id, role_name, assigned_by_user_id=None, expires_at=None):\n        \"\"\"Assign a role to a user\"\"\"\n        user = User.query.get_or_404(user_id)\n        role = Role.query.filter_by(name=role_name).first()\n        \n        if not role:\n            raise ValueError(f\"Role '{role_name}' not found\")\n        \n        # Check if already assigned\n        existing = UserRole.query.filter_by(user_id=user_id, role_id=role.id).first()\n        if existing:\n            if existing.is_active:\n                raise ValueError(f\"User already has role '{role_name}'\")\n            else:\n                # Reactivate existing assignment\n                existing.is_active = True\n                existing.expires_at = expires_at\n                user_role = existing\n        else:\n            user_role = UserRole()\n            user_role.user_id = user_id\n            user_role.role_id = role.id\n            user_role.assigned_by = assigned_by_user_id\n            user_role.expires_at = expires_at\n            db.session.add(user_role)\n        \n        # Create audit log\n        RBACService._create_audit_log(\n            action='assign',\n            entity_type='user_role',\n            entity_id=user_role.id,\n            target_user_id=user_id,\n            performed_by=assigned_by_user_id,\n            new_values=json.dumps({\n                'user_id': user_id,\n                'role_name': role_name,\n                'expires_at': expires_at.isoformat() if expires_at else None\n            })\n        )\n        \n        db.session.commit()\n        return user_role\n    \n    @staticmethod\n    def revoke_role_from_user(user_id, role_name, revoked_by_user_id=None):\n        \"\"\"Revoke a role from a user\"\"\"\n        role = Role.query.filter_by(name=role_name).first()\n        if not role:\n            raise ValueError(f\"Role '{role_name}' not found\")\n        \n        user_role = UserRole.query.filter_by(user_id=user_id, role_id=role.id, is_active=True).first()\n        if not user_role:\n            raise ValueError(f\"User does not have active role '{role_name}'\")\n        \n        # Create audit log before revocation\n        RBACService._create_audit_log(\n            action='revoke',\n            entity_type='user_role',\n            entity_id=user_role.id,\n            target_user_id=user_id,\n            performed_by=revoked_by_user_id,\n            old_values=json.dumps({\n                'user_id': user_id,\n                'role_name': role_name,\n                'assigned_at': user_role.assigned_at.isoformat()\n            })\n        )\n        \n        db.session.delete(user_role)\n        db.session.commit()\n        return True\n    \n    @staticmethod\n    def get_user_permissions(user_id):\n        \"\"\"Get all permissions for a user through their roles\"\"\"\n        user = User.query.get_or_404(user_id)\n        return user.get_all_permissions()\n    \n    @staticmethod\n    def get_role_users(role_name):\n        \"\"\"Get all users with a specific role\"\"\"\n        role = Role.query.filter_by(name=role_name).first()\n        if not role:\n            return []\n        \n        user_roles = UserRole.query.filter_by(role_id=role.id, is_active=True).all()\n        return [ur.user for ur in user_roles]\n    \n    @staticmethod\n    def bulk_assign_roles(user_ids, role_names, assigned_by_user_id=None):\n        \"\"\"Assign multiple roles to multiple users\"\"\"\n        results = []\n        for user_id in user_ids:\n            for role_name in role_names:\n                try:\n                    user_role = RBACService.assign_role_to_user(\n                        user_id, role_name, assigned_by_user_id\n                    )\n                    results.append({'success': True, 'user_id': user_id, 'role': role_name})\n                except Exception as e:\n                    results.append({'success': False, 'user_id': user_id, 'role': role_name, 'error': str(e)})\n        \n        return results\n    \n    @staticmethod\n    def get_audit_logs(entity_type=None, entity_id=None, user_id=None, limit=100):\n        \"\"\"Get audit logs with optional filtering\"\"\"\n        query = RoleAuditLog.query\n        \n        if entity_type:\n            query = query.filter_by(entity_type=entity_type)\n        if entity_id:\n            query = query.filter_by(entity_id=entity_id)\n        if user_id:\n            query = query.filter_by(target_user_id=user_id)\n        \n        return query.order_by(RoleAuditLog.created_at.desc()).limit(limit).all()\n    \n    @staticmethod\n    def cleanup_expired_roles():\n        \"\"\"Remove expired role assignments\"\"\"\n        expired_roles = UserRole.query.filter(\n            UserRole.expires_at.isnot(None),\n            UserRole.expires_at < datetime.utcnow(),\n            UserRole.is_active == True\n        ).all()\n        \n        count = 0\n        for user_role in expired_roles:\n            # Create audit log for automatic expiration\n            RBACService._create_audit_log(\n                action='expire',\n                entity_type='user_role',\n                entity_id=user_role.id,\n                target_user_id=user_role.user_id,\n                performed_by=None,  # System action\n                old_values=json.dumps({\n                    'user_id': user_role.user_id,\n                    'role_id': user_role.role_id,\n                    'expires_at': user_role.expires_at.isoformat()\n                })\n            )\n            \n            user_role.is_active = False\n            count += 1\n        \n        if count > 0:\n            db.session.commit()\n            logging.info(f\"Deactivated {count} expired role assignments\")\n        \n        return count\n    \n    @staticmethod\n    def _create_audit_log(action, entity_type, entity_id, performed_by=None, \n                         target_user_id=None, old_values=None, new_values=None, reason=None):\n        \"\"\"Create an audit log entry\"\"\"\n        audit_log = RoleAuditLog()\n        audit_log.action = action\n        audit_log.entity_type = entity_type\n        audit_log.entity_id = entity_id\n        audit_log.target_user_id = target_user_id\n        audit_log.performed_by = performed_by\n        audit_log.old_values = old_values\n        audit_log.new_values = new_values\n        audit_log.reason = reason\n        audit_log.ip_address = request.remote_addr if request else None\n        audit_log.user_agent = request.headers.get('User-Agent') if request else None\n        db.session.add(audit_log)\n        return audit_log\n\ndef initialize_rbac_system():\n    \"\"\"Initialize the entire RBAC system with default data\"\"\"\n    logging.info(\"Initializing RBAC system...\")\n    \n    # Initialize permissions first\n    perm_count = RBACService.initialize_default_permissions()\n    \n    # Then initialize roles with permissions\n    role_count = RBACService.initialize_default_roles()\n    \n    logging.info(f\"RBAC initialization complete: {perm_count} permissions, {role_count} roles created\")\n    \n    return {'permissions_created': perm_count, 'roles_created': role_count}","size_bytes":21286},"validate_errors.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBigBossizzz Error Prevention Validation\nChecks for common issues that could cause recurring errors\n\"\"\"\n\nimport sys\nimport os\nimport re\nfrom pathlib import Path\n\ndef check_javascript_syntax_errors():\n    \"\"\"Check for question mark syntax errors in JS files\"\"\"\n    js_files = Path('static/js').glob('*.js')\n    issues = []\n    \n    for js_file in js_files:\n        try:\n            with open(js_file, 'r') as f:\n                content = f.read()\n            \n            # Check for problematic console.log patterns\n            if re.search(r'console\\.log\\s*\\(\\s*[\"'][\\?]+', content):\n                issues.append(f'{js_file}: Found question mark in console.log')\n                \n        except Exception as e:\n            issues.append(f'{js_file}: Error reading file - {e}')\n    \n    return issues\n\ndef check_hardcoded_routes():\n    \"\"\"Check for hardcoded routes in JavaScript that should use url_for\"\"\"\n    js_files = Path('static/js').glob('*.js')\n    issues = []\n    \n    hardcoded_patterns = [\n        r'href\\s*:\\s*[\"'][^{]*admin/',\n        r'href\\s*:\\s*[\"'][^{]*host/',\n        r'href\\s*:\\s*[\"'][^{]*participant/'\n    ]\n    \n    for js_file in js_files:\n        try:\n            with open(js_file, 'r') as f:\n                content = f.read()\n            \n            for pattern in hardcoded_patterns:\n                if re.search(pattern, content):\n                    issues.append(f'{js_file}: Found hardcoded route that could break')\n                    \n        except Exception as e:\n            issues.append(f'{js_file}: Error reading file - {e}')\n    \n    return issues\n\ndef check_import_guards():\n    \"\"\"Check that optional imports have proper guards\"\"\"\n    python_files = ['routes.py', 'app.py']\n    issues = []\n    \n    dangerous_imports = [\n        'pandas',\n        'PyPDF2', \n        'docx',\n        'lti_integration',\n        'analytics_engine',\n        'automated_proctoring_reports'\n    ]\n    \n    for py_file in python_files:\n        if not os.path.exists(py_file):\n            continue\n            \n        try:\n            with open(py_file, 'r') as f:\n                content = f.read()\n            \n            for import_name in dangerous_imports:\n                # Check for unguarded imports\n                if re.search(f'^import {import_name}', content, re.MULTILINE):\n                    if not re.search(f'try:\\s*\n.*import {import_name}', content, re.DOTALL):\n                        issues.append(f'{py_file}: Unguarded import of {import_name}')\n                        \n        except Exception as e:\n            issues.append(f'{py_file}: Error reading file - {e}')\n    \n    return issues\n\ndef main():\n    print('üîç BigBossizzz Error Prevention Check')\n    print('='*50)\n    \n    all_issues = []\n    \n    # Check JavaScript syntax errors\n    js_issues = check_javascript_syntax_errors()\n    if js_issues:\n        print('\n‚ùå JavaScript Syntax Issues:')\n        for issue in js_issues:\n            print(f'   {issue}')\n        all_issues.extend(js_issues)\n    else:\n        print('\n‚úÖ No JavaScript syntax issues found')\n    \n    # Check hardcoded routes\n    route_issues = check_hardcoded_routes()\n    if route_issues:\n        print('\n‚ùå Hardcoded Route Issues:')\n        for issue in route_issues:\n            print(f'   {issue}')\n        all_issues.extend(route_issues)\n    else:\n        print('\n‚úÖ No hardcoded route issues found')\n    \n    # Check import guards\n    import_issues = check_import_guards()\n    if import_issues:\n        print('\n‚ùå Import Guard Issues:')\n        for issue in import_issues:\n            print(f'   {issue}')\n        all_issues.extend(import_issues)\n    else:\n        print('\n‚úÖ All imports properly guarded')\n    \n    print('\n' + '='*50)\n    if all_issues:\n        print(f'‚ùå Found {len(all_issues)} issues that need fixing')\n        return 1\n    else:\n        print('‚úÖ All checks passed - no recurring error risks found!')\n        return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n","size_bytes":4003}},"version":1}