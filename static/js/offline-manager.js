/**
 * BigBossizzz Offline Manager
 * Comprehensive offline mode for quiz-taking with intelligent sync capabilities
 */

class OfflineManager {
    constructor() {
        this.isOnline = navigator.onLine;
        this.syncQueue = [];
        this.offlineQuizData = new Map();
        this.syncInProgress = false;
        this.serviceWorkerReady = false;
        this.offlineStorage = {
            quizzes: 'offline_quizzes',
            answers: 'offline_answers',
            attempts: 'offline_attempts',
            sync_queue: 'offline_sync_queue',
            user_data: 'offline_user_data'
        };
        
        this.init();
    }
    
    async init() {
        console.log('[INFO] Initializing Offline Manager...');
        
        // Register service worker
        await this.registerServiceWorker();
        
        // Setup online/offline detection
        this.setupConnectivityDetection();
        
        // Load offline data
        await this.loadOfflineData();
        
        // Setup periodic sync
        this.setupPeriodicSync();
        
        // Setup UI indicators
        this.setupOfflineUI();
        
        // Setup quiz offline functionality
        this.setupQuizOfflineMode();
        
        // Restore sync queue
        await this.restoreSyncQueue();
        
        console.log('[INFO] Offline Manager initialized successfully');
    }
    
    async registerServiceWorker() {
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
                console.log('[INFO] Root Service Worker registered for offline support');
                
                registration.addEventListener('updatefound', () => {
                    console.log('[INFO] Service Worker update found');
                });
                
                // Wait for service worker to be ready
                await navigator.serviceWorker.ready;
                this.serviceWorkerReady = true;
                
                // Setup message listener
                navigator.serviceWorker.addEventListener('message', this.handleServiceWorkerMessage.bind(this));
                
            } catch (error) {
                console.error('? Service Worker registration failed:', error);
            }
        }
    }
    
    setupConnectivityDetection() {
        // Listen for online/offline events
        window.addEventListener('online', this.handleOnline.bind(this));
        window.addEventListener('offline', this.handleOffline.bind(this));
        
        // Periodic connectivity check
        setInterval(() => {
            this.checkConnectivity();
        }, 30000); // Check every 30 seconds
        
        // Initial check
        this.checkConnectivity();
    }
    
    async checkConnectivity() {
        try {
            // Try to fetch with proper timeout using AbortController
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            
            const response = await fetch('/api/connectivity-check', {
                method: 'HEAD',
                cache: 'no-cache',
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            const wasOnline = this.isOnline;
            this.isOnline = response.ok;
            
            if (!wasOnline && this.isOnline) {
                this.handleOnline();
            } else if (wasOnline && !this.isOnline) {\n                this.handleOffline();\n            }\n            \n        } catch (error) {\n            if (this.isOnline) {\n                this.isOnline = false;\n                this.handleOffline();\n            }\n        }\n    }\n    \n    handleOnline() {\n        console.log('? Connection restored - Going online');\n        this.isOnline = true;\n        this.updateOfflineIndicator();\n        this.announceConnectionStatus('online');\n        \n        // Start syncing queued data\n        this.startSync();\n    }\n    \n    handleOffline() {\n        console.log('? Connection lost - Going offline');\n        this.isOnline = false;\n        this.updateOfflineIndicator();\n        this.announceConnectionStatus('offline');\n        \n        // Enable offline mode for current quiz\n        this.enableQuizOfflineMode();\n    }\n    \n    setupOfflineUI() {\n        // Create offline indicator\n        const offlineIndicator = document.createElement('div');\n        offlineIndicator.id = 'offline-indicator';\n        offlineIndicator.className = 'offline-indicator';\n        offlineIndicator.innerHTML = `\n            <div class=\"offline-status\">\n                <i class=\"fas fa-wifi\" id=\"connection-icon\"></i>\n                <span id=\"connection-text\">Online</span>\n                <div class=\"sync-indicator\" id=\"sync-indicator\">\n                    <i class=\"fas fa-sync-alt\"></i>\n                    <span>Syncing...</span>\n                </div>\n            </div>\n            <div class=\"offline-details\" id=\"offline-details\">\n                <p>You're currently offline. Your quiz progress is being saved locally and will sync when connection is restored.</p>\n                <button class=\"btn btn-sm btn-primary\" onclick=\"window.offlineManager.forcSync()\">Try Sync Now</button>\n            </div>\n        `;\n        \n        // Add styles\n        const styles = document.createElement('style');\n        styles.textContent = `\n            .offline-indicator {\n                position: fixed;\n                top: 10px;\n                right: 10px;\n                background: var(--card-bg);\n                border: 2px solid var(--border-color);\n                border-radius: 8px;\n                padding: 8px 12px;\n                box-shadow: 0 4px 12px var(--shadow-color);\n                z-index: 1060;\n                font-size: 0.875rem;\n                min-width: 120px;\n                transition: all 0.3s ease;\n            }\n            \n            .offline-indicator.offline {\n                border-color: var(--btn-warning-bg);\n                background: var(--warning-bg);\n            }\n            \n            .offline-indicator.syncing {\n                border-color: var(--btn-info-bg);\n            }\n            \n            .offline-status {\n                display: flex;\n                align-items: center;\n                gap: 6px;\n                cursor: pointer;\n            }\n            \n            .offline-details {\n                display: none;\n                margin-top: 8px;\n                padding-top: 8px;\n                border-top: 1px solid var(--border-color);\n                font-size: 0.8rem;\n            }\n            \n            .offline-indicator.offline .offline-details {\n                display: block;\n            }\n            \n            .sync-indicator {\n                display: none;\n                margin-left: auto;\n                color: var(--btn-info-bg);\n            }\n            \n            .sync-indicator.active {\n                display: flex;\n                align-items: center;\n                gap: 4px;\n            }\n            \n            .sync-indicator.active i {\n                animation: spin 1s linear infinite;\n            }\n            \n            #connection-icon.offline {\n                color: var(--btn-warning-bg);\n            }\n            \n            #connection-icon.online {\n                color: var(--btn-success-bg);\n            }\n            \n            @keyframes spin {\n                from { transform: rotate(0deg); }\n                to { transform: rotate(360deg); }\n            }\n        `;\n        \n        document.head.appendChild(styles);\n        document.body.appendChild(offlineIndicator);\n        \n        // Add click handler for status\n        offlineIndicator.querySelector('.offline-status').addEventListener('click', () => {\n            offlineIndicator.classList.toggle('expanded');\n        });\n        \n        this.updateOfflineIndicator();\n    }\n    \n    updateOfflineIndicator() {\n        const indicator = document.getElementById('offline-indicator');\n        const icon = document.getElementById('connection-icon');\n        const text = document.getElementById('connection-text');\n        \n        if (indicator && icon && text) {\n            if (this.isOnline) {\n                indicator.classList.remove('offline');\n                icon.className = 'fas fa-wifi online';\n                text.textContent = 'Online';\n            } else {\n                indicator.classList.add('offline');\n                icon.className = 'fas fa-wifi-slash offline';\n                text.textContent = 'Offline';\n            }\n        }\n    }\n    \n    updateSyncIndicator(show) {\n        const syncIndicator = document.getElementById('sync-indicator');\n        if (syncIndicator) {\n            if (show) {\n                syncIndicator.classList.add('active');\n                document.getElementById('offline-indicator').classList.add('syncing');\n            } else {\n                syncIndicator.classList.remove('active');\n                document.getElementById('offline-indicator').classList.remove('syncing');\n            }\n        }\n    }\n    \n    announceConnectionStatus(status) {\n        if (window.accessibilityManager) {\n            const message = status === 'online' ? \n                'Connection restored. Your offline data will now sync.' :\n                'Connection lost. Offline mode activated. Your progress will be saved locally.';\n            window.accessibilityManager.makeAnnouncement(message, 'assertive');\n        }\n    }\n    \n    setupQuizOfflineMode() {\n        // Intercept quiz form submissions\n        document.addEventListener('submit', this.handleQuizSubmission.bind(this));\n        \n        // Auto-save quiz progress\n        document.addEventListener('change', this.handleQuizChange.bind(this));\n        \n        // Periodic auto-save\n        setInterval(() => {\n            this.autoSaveQuizProgress();\n        }, 30000); // Save every 30 seconds\n    }\n    \n    enableQuizOfflineMode() {\n        const quizContainer = document.querySelector('.quiz-container');\n        if (quizContainer) {\n            // Show offline mode indicator\n            this.showQuizOfflineNotification();\n            \n            // Pre-cache current quiz data\n            this.cacheCurrentQuizData();\n        }\n    }\n    \n    showQuizOfflineNotification() {\n        const existingNotification = document.querySelector('.quiz-offline-notification');\n        if (existingNotification) return;\n        \n        const notification = document.createElement('div');\n        notification.className = 'quiz-offline-notification alert alert-warning';\n        notification.innerHTML = `\n            <div class=\"d-flex align-items-center\">\n                <i class=\"fas fa-wifi-slash me-2\"></i>\n                <div>\n                    <strong>Offline Mode Active</strong><br>\n                    <small>Your quiz progress is being saved locally and will sync when connection is restored.</small>\n                </div>\n            </div>\n        `;\n        \n        const quizContainer = document.querySelector('.quiz-container');\n        if (quizContainer) {\n            quizContainer.insertBefore(notification, quizContainer.firstChild);\n        }\n    }\n    \n    async handleQuizSubmission(event) {\n        const form = event.target;\n        if (!form.classList.contains('quiz-form') && !form.action.includes('/quiz/')) {\n            return;\n        }\n        \n        if (!this.isOnline) {\n            event.preventDefault();\n            await this.saveQuizSubmissionOffline(form);\n            this.showOfflineSubmissionMessage();\n        }\n    }\n    \n    async handleQuizChange(event) {\n        const input = event.target;\n        if (input.name && input.name.startsWith('question_')) {\n            await this.saveQuizAnswerOffline(input);\n        }\n    }\n    \n    async saveQuizSubmissionOffline(form) {\n        const formData = new FormData(form);\n        const submissionData = {\n            id: `submission_${Date.now()}`,\n            url: form.action,\n            method: form.method || 'POST',\n            data: Object.fromEntries(formData),\n            timestamp: new Date().toISOString(),\n            type: 'quiz_submission'\n        };\n        \n        // Add to sync queue\n        this.syncQueue.push(submissionData);\n        await this.saveSyncQueue();\n        \n        console.log('? Quiz submission saved offline:', submissionData.id);\n    }\n    \n    async saveQuizAnswerOffline(input) {\n        const quizId = this.getCurrentQuizId();\n        if (!quizId) return;\n        \n        const answerData = {\n            quizId: quizId,\n            questionId: input.name.replace('question_', ''),\n            answer: input.value,\n            timestamp: new Date().toISOString()\n        };\n        \n        // Store in local storage\n        const offlineAnswers = JSON.parse(localStorage.getItem(this.offlineStorage.answers) || '{}');\n        if (!offlineAnswers[quizId]) {\n            offlineAnswers[quizId] = {};\n        }\n        offlineAnswers[quizId][answerData.questionId] = answerData;\n        \n        localStorage.setItem(this.offlineStorage.answers, JSON.stringify(offlineAnswers));\n        \n        console.log('? Quiz answer saved offline:', answerData);\n    }\n    \n    async autoSaveQuizProgress() {\n        if (this.isOnline) return;\n        \n        const quizForm = document.querySelector('.quiz-form, form[action*=\"/quiz/\"]');\n        if (!quizForm) return;\n        \n        const formData = new FormData(quizForm);\n        const progressData = {\n            quizId: this.getCurrentQuizId(),\n            progress: Object.fromEntries(formData),\n            timestamp: new Date().toISOString(),\n            percentage: this.calculateQuizProgress(quizForm)\n        };\n        \n        localStorage.setItem(`quiz_progress_${progressData.quizId}`, JSON.stringify(progressData));\n        console.log('? Quiz progress auto-saved:', progressData.percentage + '%');\n    }\n    \n    calculateQuizProgress(form) {\n        const totalQuestions = form.querySelectorAll('[name^=\"question_\"]').length;\n        const answeredQuestions = form.querySelectorAll('[name^=\"question_\"]:checked, [name^=\"question_\"][value!=\"\"]').length;\n        return totalQuestions > 0 ? Math.round((answeredQuestions / totalQuestions) * 100) : 0;\n    }\n    \n    getCurrentQuizId() {\n        // Extract quiz ID from URL or form\n        const match = window.location.pathname.match(/\\/quiz\\/(\\d+)/);\n        return match ? match[1] : null;\n    }\n    \n    async cacheCurrentQuizData() {\n        const quizId = this.getCurrentQuizId();\n        if (!quizId) return;\n        \n        try {\n            // Cache quiz questions and structure\n            const quizData = {\n                id: quizId,\n                questions: this.extractQuizQuestions(),\n                timestamp: new Date().toISOString()\n            };\n            \n            const offlineQuizzes = JSON.parse(localStorage.getItem(this.offlineStorage.quizzes) || '{}');\n            offlineQuizzes[quizId] = quizData;\n            localStorage.setItem(this.offlineStorage.quizzes, JSON.stringify(offlineQuizzes));\n            \n            console.log('? Quiz data cached for offline use:', quizId);\n        } catch (error) {\n            console.error('? Failed to cache quiz data:', error);\n        }\n    }\n    \n    extractQuizQuestions() {\n        const questions = [];\n        const questionElements = document.querySelectorAll('.question-card, .quiz-question');\n        \n        questionElements.forEach(element => {\n            const questionData = {\n                id: element.dataset.questionId || element.querySelector('[name^=\"question_\"]')?.name.replace('question_', ''),\n                text: element.querySelector('.question-text')?.textContent || '',\n                type: this.detectQuestionType(element),\n                options: this.extractQuestionOptions(element)\n            };\n            questions.push(questionData);\n        });\n        \n        return questions;\n    }\n    \n    detectQuestionType(element) {\n        if (element.querySelector('input[type=\"radio\"]')) return 'multiple_choice';\n        if (element.querySelector('input[type=\"checkbox\"]')) return 'multiple_select';\n        if (element.querySelector('textarea')) return 'text';\n        if (element.querySelector('input[type=\"file\"]')) return 'file_upload';\n        return 'text';\n    }\n    \n    extractQuestionOptions(element) {\n        const options = [];\n        const optionElements = element.querySelectorAll('.quiz-option, .option');\n        \n        optionElements.forEach(option => {\n            const input = option.querySelector('input');\n            if (input) {\n                options.push({\n                    value: input.value,\n                    text: option.textContent.trim(),\n                    id: input.id\n                });\n            }\n        });\n        \n        return options;\n    }\n    \n    showOfflineSubmissionMessage() {\n        const message = document.createElement('div');\n        message.className = 'alert alert-info';\n        message.innerHTML = `\n            <i class=\"fas fa-cloud-upload-alt me-2\"></i>\n            <strong>Quiz Submitted Offline</strong><br>\n            Your answers have been saved and will be submitted automatically when connection is restored.\n        `;\n        \n        const quizContainer = document.querySelector('.quiz-container');\n        if (quizContainer) {\n            quizContainer.appendChild(message);\n            \n            // Remove message after 5 seconds\n            setTimeout(() => {\n                if (message.parentNode) {\n                    message.parentNode.removeChild(message);\n                }\n            }, 5000);\n        }\n    }\n    \n    async startSync() {\n        if (this.syncInProgress || !this.isOnline) {\n            return;\n        }\n        \n        this.syncInProgress = true;\n        this.updateSyncIndicator(true);\n        \n        try {\n            console.log('? Starting sync process...');\n            \n            // Sync quiz submissions\n            await this.syncQuizSubmissions();\n            \n            // Sync saved progress\n            await this.syncSavedProgress();\n            \n            // Clear sync queue\n            await this.clearSyncQueue();\n            \n            console.log('? Sync completed successfully');\n            this.showSyncSuccessMessage();\n            \n        } catch (error) {\n            console.error('? Sync failed:', error);\n            this.showSyncErrorMessage();\n        } finally {\n            this.syncInProgress = false;\n            this.updateSyncIndicator(false);\n        }\n    }\n    \n    async syncQuizSubmissions() {\n        const submissionsToSync = this.syncQueue.filter(item => item.type === 'quiz_submission');\n        \n        for (const submission of submissionsToSync) {\n            try {\n                const response = await fetch(submission.url, {\n                    method: submission.method,\n                    headers: {\n                        'Content-Type': 'application/x-www-form-urlencoded',\n                        'X-CSRFToken': this.getCSRFToken()\n                    },\n                    body: new URLSearchParams(submission.data)\n                });\n                \n                if (response.ok) {\n                    console.log('? Synced submission:', submission.id);\n                    // Remove from sync queue\n                    const index = this.syncQueue.findIndex(item => item.id === submission.id);\n                    if (index > -1) {\n                        this.syncQueue.splice(index, 1);\n                    }\n                } else {\n                    console.error('? Failed to sync submission:', response.status);\n                }\n                \n            } catch (error) {\n                console.error('? Network error syncing submission:', error);\n            }\n        }\n    }\n    \n    async syncSavedProgress() {\n        const progressKeys = Object.keys(localStorage)\n            .filter(key => key.startsWith('quiz_progress_'));\n        \n        for (const key of progressKeys) {\n            try {\n                const progressData = JSON.parse(localStorage.getItem(key));\n                \n                // Send progress update to server\n                const response = await fetch('/api/quiz/sync-progress', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-CSRFToken': this.getCSRFToken()\n                    },\n                    body: JSON.stringify(progressData)\n                });\n                \n                if (response.ok) {\n                    console.log('? Synced progress for quiz:', progressData.quizId);\n                    localStorage.removeItem(key);\n                }\n                \n            } catch (error) {\n                console.error('? Failed to sync progress:', error);\n            }\n        }\n    }\n    \n    async forcSync() {\n        if (this.isOnline) {\n            await this.startSync();\n        } else {\n            this.showSyncErrorMessage('Cannot sync while offline');\n        }\n    }\n    \n    async loadOfflineData() {\n        try {\n            const savedQueue = localStorage.getItem(this.offlineStorage.sync_queue);\n            if (savedQueue) {\n                this.syncQueue = JSON.parse(savedQueue);\n            }\n        } catch (error) {\n            console.error('? Failed to load offline data:', error);\n        }\n    }\n    \n    async saveSyncQueue() {\n        try {\n            localStorage.setItem(this.offlineStorage.sync_queue, JSON.stringify(this.syncQueue));\n        } catch (error) {\n            console.error('? Failed to save sync queue:', error);\n        }\n    }\n    \n    async clearSyncQueue() {\n        this.syncQueue = [];\n        localStorage.removeItem(this.offlineStorage.sync_queue);\n    }\n    \n    async restoreSyncQueue() {\n        if (this.isOnline && this.syncQueue.length > 0) {\n            setTimeout(() => {\n                this.startSync();\n            }, 2000); // Wait 2 seconds before starting sync\n        }\n    }\n    \n    setupPeriodicSync() {\n        // Try to sync every 5 minutes when online\n        setInterval(() => {\n            if (this.isOnline && this.syncQueue.length > 0 && !this.syncInProgress) {\n                this.startSync();\n            }\n        }, 300000); // 5 minutes\n    }\n    \n    handleServiceWorkerMessage(event) {\n        const { type, data } = event.data;\n        \n        switch (type) {\n            case 'CACHE_UPDATED':\n                console.log('? Cache updated by service worker');\n                break;\n            case 'OFFLINE_FALLBACK':\n                console.log('? Service worker served offline fallback');\n                break;\n        }\n    }\n    \n    showSyncSuccessMessage() {\n        if (window.accessibilityManager) {\n            window.accessibilityManager.makeAnnouncement('Offline data synced successfully', 'polite');\n        }\n    }\n    \n    showSyncErrorMessage(customMessage) {\n        const message = customMessage || 'Failed to sync offline data. Will retry automatically.';\n        if (window.accessibilityManager) {\n            window.accessibilityManager.makeAnnouncement(message, 'assertive');\n        }\n    }\n    \n    getCSRFToken() {\n        const tokenElement = document.querySelector('[name=csrf-token]');\n        return tokenElement ? tokenElement.getAttribute('content') : '';\n    }\n    \n    // Public API\n    isOffline() {\n        return !this.isOnline;\n    }\n    \n    getSyncQueueSize() {\n        return this.syncQueue.length;\n    }\n    \n    getOfflineData() {\n        return {\n            quizzes: JSON.parse(localStorage.getItem(this.offlineStorage.quizzes) || '{}'),\n            answers: JSON.parse(localStorage.getItem(this.offlineStorage.answers) || '{}'),\n            syncQueue: this.syncQueue\n        };\n    }\n    \n    clearOfflineData() {\n        Object.values(this.offlineStorage).forEach(key => {\n            localStorage.removeItem(key);\n        });\n        this.syncQueue = [];\n        console.log('?? Offline data cleared');\n    }\n}\n\n// Auto-initialize offline manager\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.offlineManager = new OfflineManager();\n});\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = OfflineManager;\n}